<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Set]]></title>
    <url>%2F2019%2F03%2F15%2Fset%2F</url>
    <content type="text"><![CDATA[Set ES6 提供的数据结构类似于数组，值是唯一的，通过 Set 构造函数来生成 1234567891011const arr = [1,2,2,3,4,5,3,2,3,4,5];//参数可以是一个可以迭代的数据结构const set = new Set(arr); //Set(5)&#123;1,2,3,4,5&#125;[...set] //[1,2,3,4,5]const set1 = new Set('12343333433225'); //Set(5) &#123;"1", "2", "3", "4", "5"&#125;set1.size //5//数组去重const arr1 = [... new Set([1,2,3,4,3,3,3,3])];const arr2 = Array.from(new Set([1,2,3,4,3,3,3,3])); 属性和方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//属性const s = new Set() s.constructor //指向 Set 函数 s.size //成员总数/** * 操作方法 *///也可以通过 add()方法添加 只有一个参数const set2 =new Set();set2.add(1) //Set(1) &#123;1&#125;//不会发生类型转换 NaN 会 = NaN set2.add("1") //Set(2) &#123;1,"1"&#125;set2.add(NaN).add(NaN)// Set(3) &#123;1,"1",NaN&#125; 链式调用//两个对象不相等set2.add(&#123;&#125;)set2.size //4set2.add(&#123;&#125;)set2.size //5//通过 delete() 删除某个值 返回 Boolean 值 set2.delete(1) //trueset2.delete(&#123;&#125;) //false //has() 是否存在某个值 set2.has(NaN) //trueset2.has(&#123;&#125;) // false//clear() 清除所有成员set2.clear() //Set(0) &#123;&#125;/** * 遍历方法 *//** * keys 返回键名的迭代器， values 返回 键值的迭代器， 由于 Set 键名和键值 相同 所以 * keys 和 values 方法返回值相同 */ const sK = new Set([1,2,3,4,5]).keys() //SetIterator &#123;1, 2, 3, 4, 5&#125; const sV= new Set([1,2,3,4,5]).values() //SetIterator &#123;1, 2, 3, 4, 5&#125; //enters 返回键值对 for (let item of new Set([1,2,3,4,5]).entries()) &#123; console.log(item);&#125;// [1, 1]// [2, 2]// [3, 3]// [4, 4]// [5, 5]// Set的遍历顺序就是插入顺序。使用 Set 保存一个回调函数列表，调用时能保证按照添加顺序调用。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[symbol]]></title>
    <url>%2F2019%2F03%2F15%2Fsymbol%2F</url>
    <content type="text"><![CDATA[含义 ES6 引入的原始数据类型，表示独一无二的值通过 Symbol函数生成的原始值，不是对象，所以无法添加属性和方法1234567891011121314151617let s = Symbol();let s1 = new Symbol('s'); //TypeError// 不能通过 new Symbol 否则会报错s.toString()//"Symbol()"let s2 = Symbol();s == s2 // false//独一无二的特性Boolean(s) //true!s // falses + s1 //error s + 1 //error s + "1" // error //symbol 不能参与任何值的运算 对象中的 symbol 无法通过 . 点运算访问123456let sm = Symbol()const s =&#123; [sm]: 1&#125;;s.sm //undefineds[sm]//1 消除魔术字符串 代码中多次出现，与代码形成强耦合的某一个具体的字符串或者数值。123456789101112131415161718192021222324252627282930313233function getDate(num,options)&#123; let data = 1; switch (num)&#123; case 1: data = num + 1; break case 2 : data = num * 2; break &#125; return data&#125;// case 右边的 1， 2 就是魔术数值//一般把魔术字符串 变成变量来消除let obj =&#123; one:Symbol(), two:Symbol()&#125;function getDate(num,options)&#123; let data = 1; switch (num)&#123; case obj.one: data = options + 2; break case obj.two : data = options * 2; break &#125; return data&#125;getDate(obj.one,3) 作为对象属性名 for...in、for...of，Object.keys() , Object.getOwnPropertyNames(),JSON.stringify()返回。 不是私有属性，可以通过 Object.getOwnPropertySymbols()获取指定symbol名123456789let a = Symbol('a');let b = Symbol('b');const obj = &#123; a:1, [a]:'hello', [b]:'word'&#125;console.log(Object.getOwnPropertySymbols(obj)) //(2) [Symbol(a), Symbol(b)] -可以通过 Reflect.ownKeys() 返回所有类型的属性名12345678let a = Symbol('a');let b = Symbol('b');const obj = &#123; a:1, [a]:'hello', [b]:'word'&#125;Reflect.ownKeys(obj) // ["a", Symbol(a), Symbol(b)] Symbol.for()与Symbol() Symbol(‘a’) 和 Symbol.for():两种方法都会生成新的 Symbol 值Symbol(‘a’) 使用10次，会生成10个新的 SymbolSymbol.for(‘a’)，使用10次，会生成一个 Symbol 并创建一个key值Symbol.keyFor(Symbol.for(‘a’)),会返回一个全局 key 值，可以在不同的iframe 或 service worker 获取同一个key 1234567let s = Symbol('a');let s1 = Symbol.for('s');let s2 = Symbol.for('s');s == s1 //falses1 == s2 //truelet key = Symbol.keyFor(s2) //s]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pormise]]></title>
    <url>%2F2019%2F03%2F14%2Fpormise%2F</url>
    <content type="text"></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步操作原理（二）]]></title>
    <url>%2F2019%2F03%2F13%2FeventLoop%2F</url>
    <content type="text"><![CDATA[事件循环(eventLoop) 详解并行和并发： 并行性是指两个或多个事件在同一时刻发生；并发性是指两个或多个事件在同一时间段内发生。 任务队列 和 事件循环 JS 将变量存储在 堆 heap 和 栈 stack中堆中存放对象比如 ：数组，对象，函数栈中存放变量和对象的指针运行时同步任务会排好队，依次执行，而排队的地方就叫执行栈（先进后出） JS运行时，除了有一个主线程运行，引擎还提供任务队列 task queue , 里面是各种需要当前程序处理的异步任务。（不止一个任务队列） 异步任务通常是一个回调函数；如果一个异步任务没有回调函数，是不会放入异步任务队列中，同样也不会进入主线程中执行。 执行过程： 主线程会先执行完所有同步任务 同步任务结束，查看任务队列（先进先出的数据结构，排在前面的事件，优先被主线程读取。）里面的异步任务 查看所有满足执行条件的异步任务，放入主线程中变成同步任务，执行对应的回调函数。 执行完毕再将下一个满足执行条件的异步任务放入主线程中执行。 不断重复前三步操作 只要同步任务执行完毕，JS引擎会不停的监测检查任务队列中的异步任务，将满足执行条件且最先进入的任务加入到执行栈中去执行，如此往复。这种检查机制就叫事件循环 Event Loop 微任务与宏任务异步任务还会分两层： 微任务(micro task) 宏任务(macro task) 主线程会先查看微任务 micro task；如果没有满足条件的任务，再去宏任务中查找；如果有则将所有满足条件的微任务按顺序依次加入到主进程中；执行完毕后再去红任务队列中查找，往复循环。常见宏任务： 定时器 I/O（输入/输出）操作 微任务(jobs)： Promise async/awaitnodeJSnodeJS 中任务队列 加入了 process.nextTick 和 setImmediate。前者比后者先执行123456789101112131415161718192021process.nextTick(function A() &#123; console.log(1); process.nextTick(function B()&#123;console.log(2);&#125;);&#125;);setImmediate(function ()&#123; setImmediate(function A() &#123; console.log(3); setImmediate(function B()&#123;console.log(4);&#125;); &#125;); setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED'); &#125;, 0);&#125;);// 1// 2// 3// TIMEOUT FIRED// 4//这个结果是不确定的可能是 1234 TIMEOUT FIRED || 12 TIMEOUT FIRED 34 其二者的调用顺序取决于当前event loop的上下文，如果他们在异步i／o callback之外调用，其执行先后顺序是不确定的。123456789101112var fs = require('fs')fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout') &#125;, 0) setImmediate(() =&gt; &#123; console.log('immediate') &#125;)&#125;)//immediate//timeout 这是因为fs.readFile callback执行完后，程序设定了timer 和 setImmediate，因此poll阶段不会被阻塞进而进入check阶段先执行setImmediate，后进入timer阶段执行setTimeout。setTimeout和setImmediate的差异 process.nextTick在最新版nodejs中不被推荐使用，推荐使用setImmediate ，原因在于nextTick是在当前帧介绍后立即执行，会阻断I/O并且有最大数量限制；而setImmediate不会阻断I/O，更像是setTimeout(func, 0)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步操作原理(一)]]></title>
    <url>%2F2019%2F03%2F11%2Fasync%2F</url>
    <content type="text"><![CDATA[单线程 javascript 只再一个线程上运行，同时只能执行一个任务 javascript 运行在单线程上，并不代表 JavaScript引擎就是单线程的，其实它有多个线程，单个脚本只能在一个线程上运行（主线程），其他线程在后台配合运行。 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 这种模式好处在于， 实现起来简单，环境单纯。 但是 耗时较长，后面的任务必须等待前面的任务执行完毕。 同步和异步任务 同步未被引擎挂起、在主线程上排队执行的任务。需要前面的任务执行完后才能执行。 异步 被引擎挂起，暂不处理的任务,不进入主线程、而进入任务队列; 只有达到某个条件，异步任务才会进入主线程，不会堵塞异步任务后面的代码 （ajax 是最具代表性的异步任务） 异步操作模式回调函数 Callback 把函数的指针（地址）作为参数传递给另一个函数，并通过一定的条件调用。回调函数是异步操作最基本的方法 容易出现回调地狱（Callback hell)比如多个 ajax 嵌套请求123456789ajax(url, () =&gt; &#123; // 处理逻辑 ajax(url1, () =&gt; &#123; // 处理逻辑 ajax(url2, () =&gt; &#123; // 处理逻辑 &#125;) &#125;)&#125;) 这种方式容易理解和简单，但是不利于维护和阅读；耦合度高，结构混乱，错误较难追踪，而且每个任务只能指定一个回调。 事件监听 采用事件驱动。 类似 jQuery写法 12345678fn.on('click',function()&#123;&#125;);//等同于function fn ()&#123; setTimeout(function()&#123; //do someing fn.trigger('done') &#125;,1000)&#125; 这种方法比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，可以去“耦合”(decoupling),便于实现模块化。 但是整个程序都会变成事件驱动，流程不清晰。 发布/订阅 可以把事件理解成“信号”,如果存在一个“信号中心”； 某个任务执行完成，就向信号中心“发布” (publish) 一个信号，其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己开始执行 1234567891011//订阅jQuery.subscribe("done",fn);// 发布function foo()&#123; setTimeout(function()&#123; //do someing jQuery.publish('done') &#125;,1000)&#125;//取消订阅jQuery.unsubscribe('done',fn) 当 foo 执行完毕后，想消息纵向发布 done信号，引发执行fn 异步操作的流程控制（多个异步操作如何确定异步操作的执行顺序，如何保证这种顺序执行）串行执行 一个任务执行完毕后，再执行另一个 123456789101112131415161718 let arr = [1,2,3,4,5]; let results = [];const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res);const series = item =&gt;&#123; if(item)&#123; async(item,result=&gt;&#123; results.push(result); return serise(items.shift();) &#125;) &#125;else&#123; return final(results[results.length-1]); &#125;&#125;series(items.shift()); 上面代码 series 就是一个串行函数； 类似与同步任务 并行执行 所有异步任务同时执行，全部执行完毕，再执行 最终 (final) 函数 12345678910111213141516 let arr = [1,2,3,4,5]; let results = [];const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res); for (let item of items)&#123; async(item,(result) =&gt;&#123; results.push(result) &#125;) if(results.length == items.length)&#123; final(results[results.length-1]); &#125; &#125; 上面代码，for 循环会同时执行5异步任务，等他们执行完毕再执行 final 函数。 过个并行任务较多，容易耗尽系统资源，拖慢运行 并串结合 限制并行执行任务的数量，避免占用过多系统资源 1234567891011121314151617181920let items = [1,2,3,4,5];let results = [];let running = 0,limit = 2;const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res);const launcher = () =&gt; &#123; while (running &lt; limit &amp;&amp; items.length&gt;0)&#123; let item = items.shift()； async (item,(res)=&gt;&#123; results.push(result); running--; items.length? launcher(): final(results); &#125;) running++ &#125;&#125; 上面代码，最多只能运行两个异步任务，当前 running 记录运行的任务数量，低于门槛 limit 就会新增一个任务，直到任务执行完毕。 轮询12345678let hash = window.location.hash;const hashWatcher = () =&gt;&#123; if(window.location.hash != hash)&#123; updatePage() &#125;&#125;setInterval(hashWatcher,1000) setInterval 时间 间隔是” 开始执行 “ 之间的间隔,不会考虑每次执行的任务时间，所以两次执行间隔会小于指定时间。比如 指定 100ms 任务本身消耗 105 ms，那么第一次执行完毕后，第二次会立即执行。 如果要固定间隔，可以使用 setTimeout12345678let hash = window.location.hash;const hashWatcher = () =&gt;&#123; if(window.location.hash != hash)&#123; updatePage() &#125; setTimeout(hashWatcher,1000)&#125;setTimeout(hashWatcher,1000) 注意： HTML标准规定 setTimeout 最大间隔 4ms 由于定时器每执行一次,会返回一个整数，连续执行，返回值比上一次大1 123456789101112131415161718 (function() &#123; // 每轮事件循环检查一次 var gid = setInterval(clearAllTimeouts, 1000); function clearAllTimeouts() &#123; var id = setTimeout(function() &#123; console.log("g:"+gid) &#125;,0); while (id &gt; 0) &#123; if (id !== gid) &#123; clearTimeout(id); &#125; id--; &#125; &#125;&#125;)(); 防抖（debounce） 在某些场景下不希望事件执行太频繁，我们可以设置一个阀门临界值，再一段时间内只执行一次,或者一段时间过后执完所有任务 123456789101112131415161718192021222324252627282930//一段时间只执行一次let perform = (fn,time) =&gt; &#123; let flag = true; return function () &#123; let self = this,arg = arguments; if(flag)&#123; flag = false; fn.apply(self,arg); setTimeout(() =&gt; &#123; flag = true &#125;,time) &#125; &#125;&#125;let fn = () =&gt; console.log(1);setInterval(perform(fn,2000),500); // 经过一段时间再执行所有要执行的任务 let debounce = (fn,delay) =&gt;&#123; let timer = null; return function ()&#123; let self = this,arg = arguments; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(self,arg) &#125;,delay) &#125; &#125;setInterval(perform(fn,2500),500); 参考原文链接： http://wangdoc.com]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发(二)]]></title>
    <url>%2F2019%2F03%2F07%2Fmodularization%2F</url>
    <content type="text"><![CDATA[什么是模块化 将一组模块（及其依赖项）以正确的顺序拼接到一个文件（或一组文件）中的过程。 ES6 详解 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。 顶层的this指向undefined，即不应该在顶层代码使用this。 严格模式主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface）上面这些限制，模块都必须遵守。 export命令 export除了输出变量，还可以输出函数或类（class）,还可以通过 as 更改输出名。 12345678let age = 18;let obj =&#123;name: "Owen"&#125;;let multiply = (x, y) =&gt; x * y;export &#123; age, obj as monicker, //改变量名 multiply&#125; 导出的对象必须是对外的接口 1234let num =2;export num ; //error 因为实际输出的是一个值，须放在对象中 &#123;num&#125;exprot 2 //error 输出的是值 而不是一个对外接口 =&gt; 须改成 export let num =2； 不能放到局部作用域中导出， 因为导出的对象是动态绑定的12let foo = (r) =&gt; r++;let fn = () =&gt; export default foo; //error export default 全局只能有一个 export default export default 后面不能有 变量声明的关键字 使用 export default ，import 就不需要使用 {},只需要自定义一个变量即可 123456export default var a=1; //errorexport default obj =&#123;name:'Owen'&#125;;//orlet num = 1;let obj1 = &#123;name:"Owen"&#125;;export default &#123;num, obj1&#125; import 配合 from 导入模块, 通过 as 修改导入接口, 接口不能重新赋值，但对象可以修改内部属性或方法。 12345import &#123;age, monicker as obj, multiply&#125; from './preson.js'; age = 0 ; //error obj.feature = "handsome Owen"; console.log(age, obj。name, multiply(1,2)) import * as preson from "./preson.js" //引入所有接口 import 具有提升的效果，会提升到作用域顶部执行，同一个模块多次引入只执行一次，并且不能再局部作用域中引入。 12345678multiply(2,2); //4import &#123;age, monicker as obj, multiply&#125; from './preson.js';if (true)&#123;import &#123;age, monicker as obj, multiply&#125; from './preson.js'; //error&#125; import() 因为require是运行时加载模块，import命令无法取代require的动态加载功能。因此，有一个提案，引入import()函数，完成动态加载。 import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。 和 require类似，不同之处在于 import()是同步加载 require()是异步加载 1const path =import('path'); 我们可以利用 import() 进行按需加载,动态加载，按条件加载: 12345678910import('./a.js') .then(r =&gt; &#123; r.fn(); &#125;) .catch(error =&gt; &#123; /* Error handling */ &#125;)if( x == 1)&#123; const path =import('path');&#125; 如果想同时加载多个模块，可以采用下面的写法 123456789 Promise.all([ import('./a.js'), import('./b.js'), import('./c.js'),]) .then(([a,b,c]) =&gt; &#123; // ... &#125;).catch(error =&gt; &#123; /* Error handling */ &#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>moduleDevelop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 升级 webpack4 配置]]></title>
    <url>%2F2019%2F03%2F07%2Fwebpack%2F</url>
    <content type="text"><![CDATA[升级webpack4 先删除之前的webpack1npm i -D webpack webpack-cli webpack-dev-server build/base.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119const os = require('os') //node OS模块 可查看主机系统相关信息const path = require('path') //node path模块 c处理文件路径const utils = require('./utils') //vue-cli封装的公用模块const webpack = require('webpack')const config = require('../config')//vue-cli封装的配置const HappyPack = require("happypack")//开启多个子进程去并发执行const HtmlWebpackPlugin = require('html-webpack-plugin')//webpack主要插件，可以简化HTML文件的创建const CleanWebpackPlugin = require('clean-webpack-plugin');//清空打包好的文件const ProgressBarPlugin = require('progress-bar-webpack-plugin')//查看进度const vueLoaderConfig = require('./vue-loader.conf')// 处理less,sass等样式配置文件 const VueLoaderPlugin = require('vue-loader/lib/plugin');const argv = require("yargs-parser")(process.argv.slice(2))//获取运行 scripts 里面的指令 --mode 后面参数 const isPro = argv.mode == "production"const resolve = dir =&gt; path.resolve(__dirname, "..", dir)module.exports = &#123; context: path.resolve(__dirname, '../'), entry: &#123; app: "./src/main.js" &#125;, output: &#123; path: config.build.assetsRoot, filename: '[name].js', publicPath: isPro ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue': 'vue/dist/vue.esm.js', 'src': path.resolve(__dirname, '../src/common'), '@': resolve('src'), '~': resolve('src/components/common'), 'static': path.resolve(__dirname, '../static'), &#125; &#125;, module: &#123; rules: [&#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loaders: 'happypack/loader?id=babel',//配合 happypack插件使用 exclude: /(node_modules|bower_components)/, include: [resolve('src'), resolve('test')] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;, node: &#123; setImmediate: false, dgram: 'empty', fs: 'empty', net: 'empty', tls: 'empty', child_process: 'empty' &#125;, plugins: [ new ProgressBarPlugin(), new CleanWebpackPlugin(), new HappyPack(&#123; id: 'babel', loaders: [&#123; loader: 'babel-loader', options: &#123; babelrc: true, cacheDirectory: true, &#125;, publicPath: "/" &#125;], //共享进程池 threadPool: HappyPack.ThreadPool(&#123; size: os.cpus().length //cpu nunbers &#125;), //允许 HappyPack 输出日志 verbose: true, &#125;), new webpack.DefinePlugin(&#123; 'process.env': &#123; 'NODE_ENV': JSON.stringify(argv.mode) &#125; &#125;), new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true, favicon: './src/assets/img/favicon.ico' &#125;), new webpack.ProvidePlugin(&#123;//引入全局变量 $: 'jquery', jQuery: 'jquery', // 加上这个 &#125;), new VueLoaderPlugin() ]&#125; build/dev.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566'use strict'const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')//可以合并 base.conf 配置文件const baseWebpackConfig = require('./webpack.base.conf')const HtmlWebpackPlugin = require('html-webpack-plugin')const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')//让日志更加友好const portfinder = require('portfinder') //查找开放端口或域接字的简单工具 const HOST = process.env.HOSTconst PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)const devWebpackConfig = merge(baseWebpackConfig, &#123; mode:'development', module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, devtool: config.dev.devtool, devServer: &#123; clientLogLevel: 'warning', historyApiFallback: true, hot: true, compress: true, host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll, &#125;, disableHostCheck: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125;)module.exports = new Promise((resolve, reject) =&gt; &#123; portfinder.basePort = process.env.PORT || config.dev.port portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; process.env.PORT = port devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`], &#125;, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) pluguin1npm i -D happypack html-webpack-plugin clean-webpack-plugin progress-bar-webpack-plugin yargs-parser friendly-errors-webpack-plugin portfinder webpack-merge extract-text-webpack-plugin@next optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin chalk rimraf babel-loader1npm i babel-loader @babel/cli @babel/core @babel/ @babel/preset-env plugin-proposal-class-properties @babel/ plugin-proposal-decorators @babel/ plugin-syntax-dynamic-import @babel/plugin-transform-classes @babel/plugin-transform-runtime -D 1npm i --save @babel/runtime @babel/runtime-corejs2 .babelrc123456789101112131415161718&#123; "presets": [ ["@babel/preset-env", &#123; "useBuiltIns": "usage" &#125;] ], "plugins": [ ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;], "@babel/proposal-class-properties", ["@babel/plugin-transform-runtime", &#123; "corejs": 2 &#125;], "@babel/plugin-syntax-dynamic-import", "@babel/plugin-transform-classes" ]&#125; build/prod.conf.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394'use strict'const path = require('path')const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const CopyWebpackPlugin = require('copy-webpack-plugin')//复制文件和目录const HtmlWebpackPlugin = require('html-webpack-plugin')const ExtractTextPlugin = require('extract-text-webpack-plugin')//提取样式文件，只有extract-text-webpack-plugin@^4.0.0-beta.0 才支持webpack4 //或者使用 mini-css-extract-plugin 用法详见 ![GitHub](https://github.com/search?q=mini-css-extract-plugin)const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin') //用于优化\最小化 CSSconst UglifyJsPlugin = require('uglifyjs-webpack-plugin') // 压缩JS资源const webpackConfig = merge(baseWebpackConfig, &#123; mode: 'production', module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true, usePostCSS: true &#125;) &#125;, devtool: config.build.productionSourceMap ? config.build.devtool : false, output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[chunkhash].js'), chunkFilename: utils.assetsPath('js/[id].[chunkhash].js') &#125;, optimization: &#123; splitChunks: &#123; chunks: 'all', // initial、async和all minSize: 30000, // 形成一个新代码块最小的体积 maxAsyncRequests: 5, // 按需加载时候最大的并行请求数 maxInitialRequests: 3, // 最大初始化请求数 automaticNameDelimiter: '~', // 打包分割符 name: true &#125;, minimizer: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true &#125;), // extract css into its own file new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[hash].css'), allChunks: true, &#125;), new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), new HtmlWebpackPlugin(&#123; filename: config.build.index, template: 'index.html', inject: true, favicon: './src/assets/img/favicon.ico', minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, chunksSortMode: 'dependency' &#125;), new webpack.optimize.ModuleConcatenationPlugin(), new CopyWebpackPlugin([&#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125;]) ] &#125;&#125;)module.exports = webpackConfig build.js123456789101112131415161718192021222324252627282930313233343536'use strict'require('./check-versions')()process.env.NODE_ENV = 'production'const rm = require('rimraf')//删除文件const path = require('path')const chalk = require('chalk')//终端字符串样式const webpack = require('webpack')const config = require('../config')const webpackConfig = require('./webpack.prod.conf')rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; if (err) throw err webpack(webpackConfig, (err, stats) =&gt; &#123; if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, chunks: false, chunkModules: false &#125;) + '\n\n') if (stats.hasErrors()) &#123; console.log(chalk.red(' 构建失败，错误.\n')) process.exit(1) &#125; console.log(chalk.cyan(' Build success.\n')) console.log(chalk.yellow( ' 打包文件应该通过HTTP服务器启用.\n' )) &#125;)&#125;)]]></content>
      <categories>
        <category>package</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发(一)]]></title>
    <url>%2F2019%2F03%2F07%2Fmodule%2F</url>
    <content type="text"><![CDATA[传统的模块化做法。 模块是实现特定功能的一组属性和方法的封装。 将模块写成一个对象，所有的模块成员都放到这个对象里面。1234567var module1 = new Object(&#123; _count:0, f1:function()&#123;&#125;, f2:function()&#123;&#125;&#125;)module1.f1()module1.f2() 上面的对象可以改变里面的属性和方法，不安全 123456789var module1 = （function()&#123; var count=0; return &#123; f1:function()&#123;&#125;, f2:function()&#123;&#125;&#125;&#125;());module1.f1()module1.f2()module1.count //undefined 使用立即执行函数 将相应的方法和属性封装在函数中,这样就不会暴露私有成员 利用构造函数封装对象12345678910111213function Father ()&#123; var arr =[]; this.add = function (val)&#123; arr.push(val) &#125; this.toString = function()&#123; return arr.join(''); &#125;&#125;var a = new Father();a.add(1);//[1]a.toString();//"1"a.arr // undefined 上面的函数将 arr 变成私有变量，在函数外部无法访问，但是形成了闭包，非常耗费内存；违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。12345678910111213function ToString() &#123; this._buffer = [];&#125;ToString.prototype = &#123; constructor: ToString, add: function (str) &#123; this._buffer.push(str); &#125;, toString: function () &#123; return this._buffer.join(''); &#125;&#125;; 虽然上面的构造函数未生成闭包，但是外部可以修改方法和属性，不安全 放大模式如果一个模块很大或者一个模块需要继承另一个模块可以利用立即执行函数的特效来封装123456var module1 = (function(m1)&#123;mod1.col=function()&#123; console.log(this)&#125;;return mod1;&#125;(window.modlue2 ||&#123;&#125;)) //有些模块可能是null 确保函数正常执行 采用兼容模式 window.modlue2 ||&#123;&#125; 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。123var module1 = (function ($, Swiper) &#123; //...&#125;(jQuery, Swiper)); 上面的 module1 引入 jQuery 和 Swiper 当做两个参数传入模块中，保证了模块的独立性，还使得模块之间的依赖关系变得明显。 立即执行函数还可以起到命名空间的作用。123456789101112131415161718192021(function($, window, document) &#123; function go(num) &#123; &#125; function handleEvents() &#123; &#125; function initialize() &#123; &#125; function dieCarouselDie() &#123; &#125; //attach to the global scope window.finalCarousel = &#123; init : initialize, destroy : dieCarouselDie &#125;&#125;( jQuery, window, document )); 以上都有一个共同点:使用单个全局变量箭头代码包装在函数中，使用闭包建立私有空间但是都有缺点： 不知道模块(库) 的加载顺序 还是有可能引起命名冲突，比如两个库都有相同的名称，或者使用哪个版本有几种良好实施的方法：CommonJS、AMD和CMD。可以解决以上的缺陷 CommonJS CommonJS 是一种思想, 本质上是可复用的JavaScript,它导出特定的对象，提供其它程序使用。 由于 JavaScript 没有模块系统、标准库较少、缺乏包管理工具,因此CommonJS是为它的表现来制定规范。 每个JavaScript 文件 都将模块存储在自己独有的作用域中。 需要使用 module.exports 和 exports.obj 来导出对象，并在需要它的程序中使用 require(&#39;module&#39;) 加载 1234567891011121314151617181920 //文件1 function myModule() &#123; this.hello = function() &#123; return 'hello!'; &#125; this.goodbye = function() &#123; return 'goodbye!'; &#125;&#125;module.exports = myModule; //文件2 var myModule = require('myModule');var myModuleInstance = new myModule();myModuleInstance.hello(); // 'hello!'myModuleInstance.goodbye(); // 'goodbye!' 实现原理 123456789101112var module1 = &#123; export1:&#123;&#125;&#125;;(function (module,exports)&#123; exports.add = functon(val)&#123; return val *10 &#125;&#125;(module1,module1.export1));var fn = module1.export1.add;fn(2)//20 利用立即执行函数 接受两个参数 module 和 exports， 模块就通过立即执行函数赋值，然后导出模块，即可实现模块的加载这种方法的好处： 避免全局污染 明确依赖项目 语法清晰缺点： 由于 CommonJS 采用服务器优先方法并且同步加载模块，因此在浏览器中使用它会阻止浏览器运行其他内容，直到加载完成。 我们可以使用 AMD 来异步加载 AMD(Asynchromous Module Definition) 定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。 AMD模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 定义了一个函数 define，通过 define 方法定义模块。 1234 define(['myModule', 'myOtherModule'], function(myModule, myOtherModule) &#123; console.log(myModule.hello());&#125;); 上面的 define 函数将每个模块的依赖项，以数组的形式作为参数。 这些依赖项会在后台异步加载，一旦加载完成，define 函数就调用模块给出的回调函数myModule 可能像下面一样定义： 1234567891011 define([], function() &#123; return &#123; hello: function() &#123; console.log('hello'); &#125;, goodbye: function() &#123; console.log('goodbye'); &#125; &#125;;&#125;); CMD(Common Module Definition) CMD由玉伯大佬提出并用于SeaJS CMD 和 AMD 很相似，都有 define 函数， 通过 require 加载 CMD和AMD 不同点： 对于依赖的模块 CMD 延迟执行， AMD 提前执行(requireJS 高版本也开始延迟执行) CMD使用依赖就近原则（按需加载）： 12345678910111213141516 define(function(require, exports, module) &#123; var near = require('./a') near.doSomething() // 此处略去 100 行 var nearOne = require('./b') // 依赖可以就近书写 nearOne.doSomething() // ... &#125;) ``` - AMD使用依赖前置原则（必须先加载完依赖）： ```javascript define(['./a', './b'], function(nearTow, nearThree) &#123; // 必须一开始加载 nearTow.doSomething() // 此处略去 100 行 nearThree.doSomething() ... &#125;) CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。 AMD 和 CommonJS 不同点：AMD： 采用浏览器优先的方法，异步加载，主要用于浏览器 先加载依赖项 依赖项可以说 对象、函数、构造函数、字符串等等其他JS类型 CommonJS: 采用服务器优先的方法，同步加载，主要用于服务器 支持对象作为模块共同点： 先加载依赖项 通用模块定义 UMD 同时支持 AMD和 CommonJS本质 创建了一种方法来使用两者的任何一种，同时支持全局变量定义，(JS兼容性的常用思想)所以 UMD 可以在客户端和服务器上工作1234567891011121314151617181920(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['myModule', 'myOtherModule'], factory); &#125; else if (typeof exports === 'object') &#123; // CommonJS module.exports = factory(require('myModule'), require('myOtherModule')); &#125; else &#123; root.returnExports = factory(root.myModule, root.myOtherModule); &#125;&#125;(this, function (myModule, myOtherModule) &#123; function notHelloOrGoodbye()&#123;&#125;; function hello()&#123;&#125;; function goodbye()&#123;&#125;; return &#123; hello: hello, goodbye: goodbye &#125;&#125;)); ES6模块（即 ES2015/ECMAScript 6、ES6） 使用 import 关键字引入模块，通过 export 关键字导出模块 ES6目前无法在浏览器中执行,只能通过babel将不被支持的import编译为当前受到广泛支持的 require。 12345678910111213141516171819//a.jsexport let cun =1; export function add() &#123; cun++;&#125;//----------------import &#123; cun, add &#125; from './a.js';console.log(cun); // 1incCounter();console.log(cun); // 2export var fo ='a';setTimeout(() =&gt; fo ='b',500);import &#123;fo&#125; from './a.js';console.log(fo);//'a'setTimeout(()=&gt; console.log(fo),500)//'b'//ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。fo = 's' //error ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。CommonJS、AMD和CMD相比: ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 ES6 对外接口只是一种静态定义，在代码静态解析阶段就会生成。 ES6 module编译时输出接口(加载)，输出的是值的引用。(静态编译) CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。 CommonJS 模块运行时加载，输出的是一个值的拷贝。(动态编译)一旦输出一个值，模块内部的变化就影响不到这个值。12345678910111213141516171819202122232425// lib/counter.jsvar counter = 1;function increment() &#123; counter++;&#125;function decrement() &#123; counter--;&#125;module.exports = &#123; counter: counter, increment: increment, decrement: decrement&#125;;// src/main.jsvar counter = require('../../lib/counter');counter.increment();console.log(counter.counter); // 1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>moduleDevelop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(三)]]></title>
    <url>%2F2019%2F03%2F05%2Foop3%2F</url>
    <content type="text"><![CDATA[对象继承A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。 JavaScript 语言的继承不通过 class，而是通过“原型对象”prototype实现 传统原型链式继承 过多的继承属性 比如一个函数用不到某个原型方法或属性，那么方法或属性就过剩了123456789101112function Grand()&#123;&#125;;Grand.prototype.name="grand";let grand = new Grand();Father.prototype=grand;function Father()&#123;&#125;let father = new Father();Son.prototype=father;function Son()&#123;&#125;let son = new Son(); 借用构造函数 使用call/appply 不是真正继承，因为不能调用原型上的方法，而且每调用一次都会调用多次函数，实际上步骤没有变少 工业级推荐使用 缺点无法添加私有原型 123456789101112 function Father() &#123; &#125;function Son() &#123; Father.call(this); // 调用父类构造函数&#125;Son.prototype.print = function() &#123; Father.prototype.print.call(this);//只使用单个方法&#125;// 子类继承父类的原型Son.prototype = Object.create(Father.prototype);Son.prototype.constructor = Son; 共有原型1234567891011Father.prototype =&#123; name:"common"&#125;function Father()&#123;&#125;Son.prototype = Object.create(Father.prototype)function Son()&#123;&#125;function inherit (Target,Origin)&#123;//继承源 Target.prototype = Origin.prototype;&#125; 圣杯模式 隐式附加的东西就私有化，可以公共定义的东西提取出来公有化1234567891011let inherit =(function()&#123; let Interim =function Interim() &#123;&#125;; return function (Target,Origin)&#123;//继承源 Interim.prototype =Object.create(Origin); Target.prototype = Interim.prototype; //现在 可以 制定自己的私有属性，但是 constuctor 不是 原函数所一手动赋值回来，如果想要知道函数真正继承那个原型需要保存它 Target.prototype.constuctor = Target; Target.prototype.yliluokka =Origin; &#125; &#125;()) 多重继承JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过Object.assign，实现这个功能。这种模式称之为 Mixin (混入)123456789101112function Fn1()&#123; &#125;function Fn2()&#123; &#125;function Son()&#123; F1.call(this); F2.call(this); &#125;//继承F1Son.prototype =Object.create(Fn1.prototype);//继承F2Object.assign(Son.prototype,Fn2.prototype);Son.prototype.constructor =Son;let a =new Son(); call，apply and bind 都可改变函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 call and apply1234567function test() &#123;&#125; //test() == test.call()let obj =&#123;&#125;;Object.prototype.toString.call(obj) //"[object Object]"//因为call 和 apply 会将函数中的this指向第一个参数//相当于 obj.toString() call and apply 二者区别在于传参： call 第二个参数开始单个单个参数传 apply 第二个参数为数组或类数组123456//返回数组中最大的数let a = [1, 2, 4, 1, 15];Math.max.apply(null, a) // 15//将数组的空元素变为undefinedArray.apply(null [1,,3,,4)//[1,undefined,3,undefined,4]; 空元素与undefined的差别 forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 转换类似数组的对象 12let obj=&#123;0: 1, length: 2&#125;Array.protetype.slice.apply(obj);//[1,undefined] 被处理的对象必须有length属性，以及相对应的数字键。 参数为空、null和undefined，则默认传入全局对象。 bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 1234567891011121314151617181920212223let counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;let func = counter.inc.bind(counter);func();counter.count // 1let add = function (x, y) &#123; return x * this.m + y * this.n;&#125;let obj = &#123; m: 2, n: 2&#125;;let newAdd = add.bind(obj, 5); //将x 绑定为 5 newAdd(5) // 20newAdd(1,5)//12 第一个参数是null或undefined，等于将this绑定到全局对象 bind方法使用注意点 bind方法每运行一次，就返回一个新函数 需要一个变量接收 结合回调函数使用 1234567891011121314let counter = &#123; count: 0, inc: function () &#123; 'use strict'; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 结合call方法使用 1234567891011121314151617181920[1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1]//将Array.prototype.slice变成Function.prototype.call方法所在的对象//调用时就变成了Array.prototype.slice.call。let slice = Function.prototype.call.bind(Array.prototype.slice);Function.prototype.slice.call([1, 2, 3], 0, 1) // [1]//slice([1, 2, 3], 0, 1) let push = Function.prototype.call.bind(Array.prototype.push);let pop = Function.prototype.call.bind(Array.prototype.pop);let a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 将Function.prototype.bind方法变成Function.prototype.call的方法，就意味着bind的调用形式也可以被改写 1234567function f() &#123; console.log(this.v);&#125;let o = &#123; v: 123 &#125;;let bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123 Object 系统默认方法 getPrototypeOf 获取对象原型,只有一个参数 12345678910function Foo ()&#123;&#125;let obj = new Foo ();Object.getPrototypeOf(obj) // Foo.prototype//空对象原型 Object.getPrototypeOf(&#123;&#125;) // Object.prototype// Object.prototype 原型 Object.getPrototypeOf(Object.prototype) //null// FooObject.getPrototypeOf(Foo) // Function.prototype setPrototypeOf 设置对象原型有两个参数： 现有对象 继承的原型对象12345let now = &#123;&#125;;let pro = &#123;name:"Owen"&#125;;Object.setPrototypeOf(now,pro);now.name //"Owen" Object.create() 生成实例对象的常用方法 参数必须为对象 或 null 参数为 null 会生成一个不会继承任何属性和方法的对象12345678910111213141516171819202122232425262728293031let obj = Object.create(null);obj.toString()// Error //会继承第二个参数的属性和方法let obj = Object.create(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true, configurable: true, writable: true, &#125;, p2: &#123; value: 'Owen', enumerable: true, configurable: true, writable: true, &#125; &#125;);// 等同于let obj = Object.create(&#123;&#125;);obj.p1 = 123;obj.p2 = 'Owen';//生成的对象会继承它的原型对象的构造函数。function Foo() &#123;&#125;let f = new Foo();let b = Object.create(f);b.constructor === Foo // trueb instanceof Foo // true object.isPrototypeOf 判断对象是否再参数对象的原型链上 123function F()&#123;&#125;let f = new F()F.prototype.isPrototypeOf(f) //true 获取原型的三种方法 obj.__proto__ obj.constructor.prototype Object.getPrototypeOf(obj) 前两种不可靠，都个一手动修改， 而且 __proto__ 只有浏览器才需要部署 getOwnPropertyNames 和 keys 以数组形式返回参数对象所有属性名(不包含继承属性) 1234//不管可不可遍历都会返回出来Object.getOwnPropertyNames(Date);//["length", "name", "prototype", "now", "parse", "UTC"]//返回可遍历属性Object.keys(Date)// [] hasOwnProperty 判断参数是否是自身的属性，唯一一个不会遍历原型链的方法1Array.hasOwnProperty('length')//true 拷贝对象拷贝对象需要确保两件事情： 与原对象具有同样的原型。 与原对象具有同样的实例属性。 1234567891011121314151617function copyOwn (target,origin)&#123; Object.getOwnPropertyNames(origin).forEach((key)=&gt;&#123; let desc =Object.getOwnPropertyDescriptor(origin,key); Object.defineProperty(target,origin,desc); &#125;) return target&#125;function copy(origin)&#123; let clone = Object.create (Object.getPrototypeOf(origin)); copyOwn(clone,origin) return clone&#125;//es8const copyTwo = origin =&gt;Object.create( Object.getPropertyOf(origin),Object.getOwnPropertyDescriptor(origin) );]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(二)]]></title>
    <url>%2F2019%2F03%2F05%2Fopp2%2F</url>
    <content type="text"><![CDATA[原型对象 prototype 原型对象的所有属性和方法,都能被实例对象共享 JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。123456789function Cat (name, color) &#123; this.name = name; this.color = color;&#125;var cat1 = new Cat('小明', '白色');cat1.name // '小明'cat1.color // '白色' 构造函数缺点： 一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。 解决方法，就是 JavaScript 的原型对象 prototype，因为原型对象的所有属性和方法，都能被实例对象共享。 123456789function Cat (name, color) &#123; this.name = name;&#125;Cat.prototype.color ="白色";&#125;var cat1 = new Cat('巧克力');var cat2 = new Cat('布丁');cat1.color //白色cat2.color//白色 JavaScript规定，每个函数都有一个prototype属性，指向一个对象。 对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。 实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。 12function f() &#123;&#125;typeof f.prototype // "object" 每个 JS 对象都有 __proto__ 属性，这个属性可以访问到 原型（[[prototype]]） 内部属性。这个属性在现在来说已经不推荐直接去使用它了。 原型链 任何对象，都可以充当其他对象的原型；原型对象也有自己的原型。对象到原型，再到原型的原型，一层层向上找到Object.prototype。 可以说 基本上所有对象都继承了Object.prototype的属性；而 Object.prototype 的原型是 null通过 getPrototypeOf 方法返回参数对象原型1Object.getPrototypeOf(Object.prototype) //null 读取对象属性时，引擎会先在自身属性上查找，没有就查找原型，一级级向上查找，如果到Object.prototype还是没有，则返回undefined。一级级向上，对性能有影响，寻找的层级越多，性能影响越大 原型链：- 实例 F1 通过__proto__ 访问对应构造函数的原型 -&gt; FOO.prototype- 函数原型再通过__proto__ 访问Object的原型 -&gt; Object.prototype- Object的原型的__proto__ 指向 null- 构造函数 Foo.prototype 通过constructor访问构造函数本身- Object.constructo 指向 Function- Function.constructo 指向 本身- Function.__proto__ 指向一个匿名函数- 每个构造函数通过 prototype 访问原型只有函数才拥有prototype属性,基本上所有函数都有这个属性1let fun = Function.prototype.bind()当声明一个函数时自动创建 prototype 属性，这个属性的值是一个对象（也就是原型），且只有一个属性 constructor### constructor prototype 有一个属性 constructor，默认指向原型所在的构造函数 12345678function Fn ()&#123;&#125;var f = new Fn ();f.constructor == Fn //truef.constructor == Function //false//可以从实例对象新建另一个实例var b =new f.constructor();b.constructor == Fn //true constructor是一个公有且不可枚举的属性。一旦我们改变了函数的 prototype ，那么新对象就没有这个属性了,如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。1234function A()&#123;&#125;console.log(A.prototype) // &#123;constructor: ƒ&#125;constructor: ƒ A()__proto__: ObjectA.prototype="a"console.log(A.prototype) //"a"constructor作用：- 让实例对象知道是什么函数构造了它 &gt; 可以得知某个实例对象，是哪一个构造函数产生的。- 如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 xx.constructor.method 来扩展### __proto__基本上每个对象都有的隐式原型属性，指向创建该对象的构造函数的原型，实际指向[[prototype]]， 内部属性，我们并不能访问到，所以使用 proto 来访问。12console.log(&#123;&#125;)//__proto__: Objectconstructor: ƒ Object()hasOwnProperty: ....当我们使用 new 操作符时，生成的实例对象拥有了 __proto__属性。1234567function Foo() &#123;&#125;// 这个函数是 Function 的实例对象// function 就是一个语法糖// 内部调用了 new Function(...)const a =1;const fn = new Function("console.log(a)") // Function 的this始终指向 全局对象，除非手动改变this指向fn()//1&gt; 所有对象都可以通过原型链最终找到 Object.prototype ，虽然 Object.prototype 也是一个对象，但是这个对象却不是 Object 创造的，而是引擎自己创建了 Object.prototype 。可以这样说，所有实例都是对象，但是对象不一定都是实例。 -首先引擎创建了 Object.prototype ，然后创建了 Function.prototype ，并且通过proto 将两者联系了起来。 Function.prototype 以后才有了 function Function() ，然后其他的构造函数都是 function Function() 生成的。 函数通过 new Function() 生成, 不是所有函数都是 new Function()产生的。 Object 是所有对象的爸爸，所有对象都可以通过proto 找到它 Function 是所有函数的爸爸，所有函数都可以通过proto 找到它 Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎来创建 除了以上两个特殊对象，其他对象都是通过构造器 new 出来的 函数的 prototype 是一个对象，也就是原型对象的proto 指向原型，proto将对象和原型连接起来组成了原型链]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(一)]]></title>
    <url>%2F2019%2F03%2F04%2Fopp1%2F</url>
    <content type="text"><![CDATA[什么是对象对象是单个实物的抽象，通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。 面向对象编程的第一步，就是要生成对象。 对象是一个容器，封装了属性（property）和方法（method），属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。 JavaScript 语言的对象体系，不是基于“类”的，而是基于构造数constructor和原型链prototype；所以JS 专门使用构造函数作为对象模板；一个构造函数，可生成多个实列对象，它们有相同的结构 构造函数与普通函数区别 构造函数就是一个普通的函数，但是有自己的特征和用法。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。123456789101112//constructor var Bird = function () &#123; this.name = 'lai fu';&#125;;var bird1 = new Bird(); // 也可以使用 new Bird; 推荐使用前者console.log(bird1.name) // "lai fu"//ordinaryvar a =Bird();console.log(a) // undefinedconsole.log(a.name) // typeErrorname // 'laifu' 防止把构造函数constructor当普通函数使用1234567891011121314151617 //使用 严格模式function Fubar(foo, bar)&#123; 'use strict'; this._foo = foo; this._bar = bar;&#125;Fubar()// TypeError//判断 this 不是构造函数（constructor）的实列对象 那么手动返回自身constructorfunction Far(a)&#123; if (!(this instanceof Far)) return new Far(a); this._a=a;&#125;Far(1)._a new命令的原理 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 12345678910111213141516171819202122/***新生成一个空对象*链接到原型*绑定 this*返回新对象**/function _new(constuctor,param) &#123; // 获得构造函数 let Con = [].shift.call(arguments); // 链接到原型 let obj = Object.create(Con.prototype); // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return (typeof(result) === 'object' &amp;&amp; result != null) ? result : obj&#125; var fn = _new( function Person (name,age)&#123; this.name =name; this.age=age &#125;, '张三', 28);fn.name // '张三' new.target12345678910111213141516function f() &#123; console.log(new.target === f);&#125;f() // falsenew f() // true //可利用 它来判断是否使用 new 命令function f() &#123; if (!new.target) &#123; throw new Error('请使用 new 命令调用！'); &#125; // ...&#125;f() // Uncaught Error: 请使用 new 命令调用！ this实质 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。 1var obj = &#123; a: 1 &#125;; JavaScript 存储变量实际上是以下面的形式保存的。 12345678&#123; a: &#123; [[value]]: 1 //函数的地址 [[writable]]: true //是否可赋值 [[enumerable]]: true//是否可枚举 [[configurable]]: true//是否可配置 &#125;&#125; 属性的值保存在属性描述对象的value属性里面。 如果 a 属性的值是引用值 那么属性将以下面的形式保存的：1234567891011var obj = &#123; fn: function () &#123;&#125; &#125;;/*&#123; fn: &#123; [[value]]: [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125;*/ 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f n= function () &#123;&#125;;var obj = &#123; f: fn &#125;;// 单独执行 fn()// obj 环境执行obj.f() JavaScript 允许在函数体内部，引用当前环境的其他变量。 由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 下面这几种用法，都会改变this的指向。1234567891011121314151617181920(obj.fn = obj.fn)() // window// 等同于(function () &#123; console.log(this);&#125;)()(false || obj.fn)() // window// 等同于(false || function () &#123; console.log(this);&#125;)()(4, obj.fn)() // window// 等同于(4, function () &#123; console.log(this);&#125;)() 数组调用forEach 方法时函数内部this 指向window ，将父级上下文传递给forEach 改变this指向1234567891011var o = &#123; v: 'hello', p: [ 'a1', 'a2' ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + '-' + item); &#125;, this); //将外层的this传递给forEach方法 &#125;&#125;o.f() // hello-a1 hello-a2 end]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
</search>
