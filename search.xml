<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[algorithm]]></title>
    <url>%2F2019%2F04%2F21%2Falgorithm%2F</url>
    <content type="text"><![CDATA[&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。======= 术语 时间复杂度: 一个算法执行所耗费的时间。 一个算法花费的时间与算法中语句的执行次数成正比例,一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化，要知道变化时呈现什么规律就引入了时间复杂度概念算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 空间复杂度: 运行完一个程序所需内存的大小。 一个算法所需的存储空间用f(n)表示。S(n)=O(f(n)) 其中n为问题的规模，S(n)表示空间复杂度。 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 更多信息 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素(自己不能跟自己加起来等于target)。 d71c39e5118389885ef986735a9a15598115e5b9 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解答：12345678910/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADvar twoSum = function(nums, target) &#123; &#125;; =======// 方法一 嵌套循环 时间复杂度：O(n^2) 空间：O(2)var twoSum = function(nums, target) { for (let [i,k] of nums.entries()){ for (let j = i+1; j&lt; nums.length; j++) { if( (target - k) === nums[j]) { return [i,j]; } } }};// 方法二 嵌套循环 比 方法一 更快var twoSum = function(nums, target) { let len = nums.length; for (let i = 0; i&lt;len; i++){ for (let j = i+1; j&lt;len; j++) { if( (target - nums[i]) === nums[j]) { return [i,j]; } } }};// 方法三 has表 时间复杂度：O(n) 空间：O(n)/** 存储对应的值 和 索引*/var twoSum = function(nums, target) { const m = new Map(); const len = nums.length； for (let i = 0; i &lt; len; i++ ) { if(m.has(nums[i]) &amp;&amp; m.get(nums[i]) !== i){ return [m.get(nums[i]),i] } m.set((target - nums[i]),i); } }; //orvar twoSum = function(nums, target) { const m = new Map(); const len = nums.length； for (let i = 0; i &lt; len; i++ ) { let res = target - nums[i]; if(m.has(res) &amp;&amp; m.get(res) !== i){ return [m.get(res),i] } m.set(nums[i],i); }};123456789101112131415161718192021222324252627### 整数反转- 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。```javascript/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123; let res =( x+&apos;&apos; ).split(&quot;&quot;); if(res[0] !== &apos;-&apos;)&#123; let num = parseInt(res.reverse().join(&apos;&apos;),10); if( num&gt; Math.pow(2,31) -1)&#123; return 0 &#125; return num; &#125;else&#123; res.reverse().pop(); let num = parseInt(res.join(&apos;&apos;),10); if( num&gt; Math.pow(2,31) -1)&#123; return 0 &#125; return &apos;-&apos; + num; &#125;&#125;; 回文数 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数 。 输入: 121 输出: true输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。注意 0 是回文数 进阶: 不将整数转为字符串来解决这个问题 123456789101112131415161718192021222324/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */ // 方法 一 转化未字符串var isPalindrome = function(x) &#123; return x &lt; 0? false: (parseInt((x+'').split('').reverse().join('')) === x ? true : false);&#125;;/** * 方法二 中间数的右边反转后 等于 左边 * 提取中间数的右边 通过 *10 、 %10 来提取 * */ var isPalindrome = function(int) &#123; if(int &lt; 0 || (int%10 === 0 &amp;&amp; int !== 0)) return false; let num = 0; while (int &gt; num )&#123; num = num * 10 + int % 10; int = parseInt(int/10); &#125; return int === num || int === parseInt(num/10);&#125;; d71c39e5118389885ef986735a9a15598115e5b9]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Sum of two numbers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios]]></title>
    <url>%2F2019%2F04%2F17%2Faxios%2F</url>
    <content type="text"><![CDATA[原生ajaxXMLHttpRequest 对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function Ajax(obj) &#123; this.url = obj.url ||''; this.type = obj.type || 'get'; this.data = obj.data ||&#123;&#125;; this.success = obj.success || null; this.error = obj.error || null;&#125;Ajax.prototype.send = function()&#123; var self = this; var toStr = Object.prototype.toString; if (self.data === null &amp;&amp; typeof self.data !== 'object' &amp;&amp; Array.isArray(obj)) return; return (function()&#123; // 实例化 XML对象 var xhr = new XMLHttpRequest(); var data = ''; // 序列化参数 for (var k in self.data)&#123; data += k + '=' + self.data[k] + '&amp;'; &#125; data = data.substr(0,data.length - 1); // 接收回调函数 xhr.onreadystatechange = function()&#123; if (xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; isFunction(self.success) &amp;&amp; self.success(xhr.responseText) &#125;else&#123; isFunction(self.error) &amp;&amp; self.error(xhr) &#125; &#125; &#125; // 初始化请求 if(self.type.toLocaleLowerCase() === 'post')&#123; xhr.open ('post',self.url,true) // 设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); //发送请求 xhr.send(data) &#125; else &#123; xhr.open('get', self.url + "?" + data,true) xhr.send(null) &#125; &#125;());&#125;;function isFunction(obj)&#123; return toStr.call(obj) === "[object Function]"&#125;var ajax = new Ajax(&#123; type:'post', url:"/login", data:&#123; loginname:"admin", password:"admin" &#125;, success:function(e)&#123; console.log(e) &#125;, error:function(err)&#123; console.log(err) &#125;, &#125;).send(); XMLHttpRequest Level 2 相比于 老版本的 XMLHttpRequest 新增以下内容：可以设置 HTTP 请求超时时间 123456789var xhr = XMLHttpRequest();xhr.open('GET'.'url');// 超时 2sxhr.timeout = 2000;// 超时处理xhr.ontimeout = function(e) &#123; console.log(e)&#125;xhr.send(null) 可以通过 FormData 发送表单数据 1234567 // 实例化 FormDatavar formData = new FormData(); // 添加数据 formData.append(key,value); xhr.open('POST','url'); xhr.send(formData); 可以上传文件 FormData 除了可以添加字符串数据，也可以添加 blob、file 类型的数据，因此可以用于上传文件。 在浏览器中，一般是通过文件上传输入框来获取 file 对象，比如： 1&lt;input type="file" name='uploadFile' id="upload-file" /&gt; 12345678document.getElementById('upload-file') .addEventListener('change', function () &#123; var formData = new FormData(); // 获取数据 formData.append('uploadFile', this.files[0]) xhr.send(formData) &#125;) 支持跨域请求 浏览器默认是不允许跨域请求的，有时候又是必要的，在以前通常使用JSONP来解决（IE10 以下不支持） 为了标准化跨域请求， W3C提出 跨域资源共享（CORS）前端无须修改代码，只需 服务器返回 Access-Control-Allow-Origin 响应头，指定允许对应的域 CORS 默认不发送 cookie 如果需要发送，前端需要设置 withCredentials属性，同时服务器需要 返回 Access-Control-Allow-Credentials: true,1xhr.withCredentials = true; 可以获取服务端二进制数据 使用 overrideMimeType 方法覆写服务器指定的 MIME 类型，从而改变浏览器解析数据的方式123456// 参数 MIME 类型// 告诉浏览器，服务器响应的内容是用户自定义的字符集 xhr.overrideMimeType('text/plain; charset=x-user-defined');// 浏览器就会将服务器返回的二进制数据当成文本处理，我们需要做进一步的转换才能拿到真实的数据 // 获取二进制数据的第 i 位的值 var byte = xhr.responseText.charCodeAt(i) &amp; 0xff “&amp; 0xff” 运算 参考 阮一峰的文章 xhr.responseType 用于设置服务器返回的数据的类型,将返回类型设置为 blob 或者 arraybuffer，然后就可以从 xhr.response 属性获取到对应类型的服务器返回数据。12345xhr.responseType = 'arraybuffer'xhr.onload = function () &#123;var arrayBuffer = xhr.response// 接下来对 arrayBuffer 做进一步处理...&#125; 可以获取数据传输进度信息 参考资料 使用 onload 监听了一个数据传输完成的事件。 1234567// 上传进度监听xhr.upload.addEventListener('progress', onProgressHandler, false);// 传输成功完成xhr.upload.addEventListener('load', onLoadHandler, false);// 传输失败信息xhr.upload.addEventListener('error', onErrorHandler, false); 更多资料参考 阮一峰的文章]]></content>
  </entry>
  <entry>
    <title><![CDATA[class]]></title>
    <url>%2F2019%2F04%2F17%2Fclass%2F</url>
    <content type="text"><![CDATA[class 生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令 123456789class Point &#123; // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 实例的属性除非显式定义在其本身（即定义在this对象上）， 否则都是定义在原型上（即定义在class上）。 12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 与 ES5 一样，类的所有实例共享一个原型对象。 避免对环境产生依赖，生产环境中，我们可以使用 Object.getPrototypeOf方法来获取实例对象的原型，然后再来为原型添加方法/属性。 12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return 'Oops' &#125;;p1.printName() // "Oops"p2.printName() // "Oops"var p3 = new Point(4,2);p3.printName() // "Oops" 由于p1的原型就是p2的原型，因此p2也可以调用这个方法。 而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 constructor constructor方法是类的默认方法, 通过new命令生成对象实例时，自动调用该方法。 一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。相当于es5 new Vue 1234567891011class Point &#123;&#125;// 等同于 class Point &#123; constructor() &#123;&#125; //JavaScript 引擎会自动为它添加一个空的constructor方法。&#125;// 等同于new Point ()&#123; &#125; constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 表达式定义12345678910const MyClass = class Me &#123; getClassName() &#123; return Me.name; //这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。 &#125;&#125;;//内部没用到Me的话可以省略Meconst YouClass = class &#123;//...&#125;; 采用 Class 表达式，可以写出立即执行的 Class。 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // "张三" 不存在变量提升 （hoist），必须保证子类在父类之后定义 ，这一点与 ES5 完全不同。12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 继承类123456&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; //Bar继承Foo &#125;&#125; 私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。有三种方法可模拟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//第一种class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // _bar方法前面的下划线，表示这是一个只限于内部使用的私有方法 但是，在类的外部，还是可以调用到这个方法。&#125;//第二种class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // 内部调用了bar.call(this, baz)，成为了当前模块的私有方法&#125;//私有方法移出模块function bar(baz) &#123; return this.snaf = baz;&#125;//第三种const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。&#125;; 私有属性的提案 方法是在属性名之前，使用#表示。 1234567891011121314class Point &#123; #x=0;// 私有属性可以指定初始值，在构造函数执行时进行初始化。 constructor(x = 0) &#123; #x = +x; // 写成 this.#x 亦可 &#125; get #x() &#123; return #x &#125; set #x(value) &#123; #x = +value &#125; #sum() &#123; return #a + #b; &#125; //私有方法 // #x是一个私有属性，它的读写都通过get #x()和set #x()来完成。 #x和x是两个不同的属性&#125;//JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。@已经留给了 Decorator。 私有属性不限于从this引用，类的实例也可以引用私有属性 123456789class Foo &#123; #privateValue = 42; static getPrivateValue(foo) &#123; return foo.#privateValue; &#125;&#125;Foo.getPrivateValue(new Foo()); // 42console.log(Foo.#privateValue) // 报错 class 的取值函数（getter）和存值函数（setter）12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter']]></content>
  </entry>
  <entry>
    <title><![CDATA[JSquestion]]></title>
    <url>%2F2019%2F04%2F10%2FJSquestion%2F</url>
    <content type="text"><![CDATA[赋值运算符多次出现，优先计算问题(结合性) 赋值表达式为右结合先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用。1234567891011121314151617181920212223242526272829303132333435363738394041424344a = b = c = v/*先解析 左侧的操作数1. refa2. refb3. refc4. value v*/refa = (refb = (refc = value v))/* 再计算右侧表达式的值 然后和从右到左赋值1. value v 赋值 refc2. value v 赋值 refb3. calue v 赋值 refa4. 返回 value v*/ //examplevar foo = &#123;n:1&#125;;var bar = foo;foo.x = foo = &#123;n:2&#125;;/* 变量名 存储在栈中， 引用对象存储在堆中根据规则 先解析 =号左侧的引用 refx = (refo = &#123;n:2&#125;)再赋值refo = &#123;n:2&#125; //refo 开辟新指针 foo 指向 &#123;n:2&#125; refx = &#123;n:2&#125; // 在原refo指针对象中开辟新指针 指向 &#123;n:2&#125;结果 refo.x == undefined*//* 或者 foo.x赋值前是&#123;n:1,x:unfiend&#125;;赋值后&#123;n:1,x:&#123;n:2&#125;&#125;;*/foo.x //undefinedbar.x // &#123;n: 1, x: &#123;n:2&#125;&#125;; split123456'81 newO'.split('') //["8", "1", " ", "n", "e", "w", "O"] '81 newO'.split(' ')// ["81", "newO"]'81 newO'.split('').reverse().join('');//"Owen 18"]]></content>
      <tags>
        <tag>JSquestion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interator]]></title>
    <url>%2F2019%2F04%2F04%2FInterator%2F</url>
    <content type="text"><![CDATA[Interator “集合”数据的结构主要有 Array 、Object、 Set and Map ，任何数据结构只要部署 Iterator 接口，就可完成遍历操作 遍历过程： 创建指针，指向当前数据结构起始位。（遍历对象本质是一个指针对象）。 依次循环调用指针对象的 next方法，对应指向数据结构成员，直至结束。每次调用next方法，返回对象当前成员的信息{value：text,done:true},其中value表示成员值，done` 表示遍历是否结束 123456789101112131415161718let arr = ['Owen','18'];let makeInterator = array =&gt;&#123; let index = 0; return &#123; next ()&#123; return index &lt; array.length ? &#123;value:array[index++],done:false&#125; : &#123;value:undefined, done:true&#125; &#125; &#125;&#125;let inter = makeInterator(arr);inter.next()it.next() // &#123; value: "Owen", done: false &#125;it.next() // &#123; value: 18, done: false &#125;it.next() // &#123; value: undefined, done: true &#125; 对与遍历器对象来说 done: false and value:undefined 可省略 原生具备 Iterator 的数据结构：Array 、 String 、 Map、 Set 、arguments and NodeList 都默认部署 [Symbol.iterator] 方法1234567891011121314151617181920212223//const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;;obj[Symbol.iterator]().next() //&#123;value: 1, done: true&#125;let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125;iter.next() // &#123; value: undefined, done: true &#125; 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//原型上部署Interatorclass RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; return &#123;done: true, value: undefined&#125;; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value); // 0, 1, 2&#125;//对象上部署Interatorfunction Obj(value) &#123; this.value = value; this.next = null;&#125;Obj.prototype[Symbol.iterator] = function() &#123; var iterator = &#123; next: next &#125;; var current = this; function next() &#123; if (current) &#123; var value = current.value; current = current.next; return &#123; done: false, value: value &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; return iterator;&#125;var one = new Obj(1);var two = new Obj(2);var three = new Obj(3);one.next = two;two.next = three;for (var i of one)&#123; console.log(i); // 1, 2, 3&#125; 类似数组对象，可引用 Array.prototype[Symbol.iterator]123456789101112131415161718//NodeListNodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];// 或者NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];[...document.querySelectorAll('div')] //objlet iterable = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for (let item of iterable) &#123; console.log(item); // 'a', 'b', 'c'&#125; 一些 默认调用 Iterator 的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 解构赋值let set = new Set().add('a').add('b').add('c');let [x,y] = set; // x='a'; y='b'let [first, ...rest] = set; // first='a'; rest=['b','c'];//扩展运算符var str = 'hello';[...str] // ['h','e','l','l','o']let arr = ['b', 'c'];['a', ...arr, 'd'] // ['a', 'b', 'c', 'd']//yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125;// for...of//for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、 Generator 对象，以及字符串。let arr = document.querySelectorAll("p");for (let item of arr ) &#123; console.log(item)&#125;/* 其他操作*/Array.from()Map(), Set(), WeakMap(), WeakSet() //生成对应数据结构Promise.all()Promise.race() 遍历器return方法和throw方法return() return方法必须返回一个对象。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。如果for…of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。 1234567891011121314151617181920212223242526function readFile(file) &#123; return &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123;done:false&#125; &#125;, return()&#123; file.close() return &#123;done:true&#125; &#125; &#125;; &#125; &#125;;&#125;//触发 return()for (let line of readFile(fileName)) &#123; console.log(line); break;&#125;//触发 return()for (let line of readLinesSync(fileName)) &#123; console.log(line); throw new Error();&#125; for…of 和其他遍历语法对比12345678910111213141516171819202122232425262728293031323334353637383940414243let arr = [1,2];//普通 `for`循环 for (var index = 0; index &lt;arr.length; index++) &#123; console.log(arr[index]);&#125;/** * 书写比较麻烦*/// Array.forEach arr.forEach(function(item)&#123; console.log(item)&#125;)/** * 无法跳出循环，无法使用 break or return */// for...infor (let index in arr) &#123; console.log(arr[index]);&#125;/** * 1.数组键名为字符串形式的数字 * 2.会遍历出原型链上的键，和手动添加的键 * 3.有些情况是无顺序遍历 */for (let item of arr) &#123; console.log(item);&#125;/** * 1.语法简洁 * 2.没有 for...in 的缺点 * 3.可以使用 return、break and continue * */]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Interator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator]]></title>
    <url>%2F2019%2F04%2F04%2Fgenerator%2F</url>
    <content type="text"><![CDATA[Generator ES6 提供的一种异步编程解决方案Generator 函数是一个状态机，封装了多个内部状态。还是一个遍历器对象生成函数。返回遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 Generator 函数特征 function关键字和函数名之间 有 * ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。 函数体内部有 yield 表达式123456789101112131415function* generator() &#123; yield 'Owen'; yield 18; return 'end';&#125;//调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象 Iterator let person = generator();person.next() //&#123;value:'Owen',done:false&#125;person.next() //&#123;value:18,done:false&#125;person.next() //&#123;value:'end',done:true&#125;person.next() //&#123;value:undefined,done:true&#125;person.next() //&#123;value:undefined,done:true&#125; yield yield 后面的表达式以分号作为结束语句一种可以暂停函数执行的表达式，配合 next方法使用。只能再在 Generator 函数中使用，普通函数中使用会报错.yield 如果用在另一个表达式中,必须用圆括号包起来，作为函数参数或者赋值表达式右边可以不用加括号。 next 运行逻辑 调用 next 遇到 yield表达式 暂停执行函数后面的操作，并且 紧跟 yield 后面的表达式的值作为返回对象 value 属性的值。 再次调用 next,继续执行yield表达式 后面的逻辑代码，直到下一个 yield表达式 或者 return 语句，返回值为 对象 value 属性的值。 如果没有 return 语句 ，则 value 属性的值为 undefined。 只有调用next方法，才会执行对应 yield 后面的表达式12345678function* g()&#123; yield 1 + 2&#125;let num = g() num //g &#123;&lt;suspended&gt;&#125;num.next() //&#123;value:3,done:false&#125;num.next() //&#123;value:undefined,done:true&#125; 使用 Interator 由于 Generator 函数是遍历器生成函数，因此 把它赋值给对象的 [Symbol.interator]属性，该对象就可以被遍历123456789let iter = &#123;&#125;;iter[Symbol.iterator] = function* ()&#123; yield 1; yield 2; yield 3;&#125;[...iter] //[1, 2, 3] next 参数 yield 本身的返回值为 undefined， 而 next方法可以带一个参数，当作上一个 yield的返回值 12345678910111213141516171819202122232425262728293031let g = fn(); g.next() //&#123;value:0,done:false&#125; g.next() //&#123;value:1,done:false&#125; g.next() //&#123;value:2,done:false&#125; g.next(1) //&#123;value:0,done:false&#125; function* fn ()&#123; for (let i = 0; true; i++)&#123; let reset = yield i; if(reset) i = -1; &#125; &#125;function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result';&#125;let genObj = dataConsumer();genObj.next();// Started//&#123;value: "undefined", done: fales&#125;genObj.next('a')//1. a//&#123;value: "undefined", done: fales&#125;genObj.next('b')//2. b//&#123;value: "result", done: true&#125; for…of 中使用 Generator 可以不用调用 next 方法 如果 返回对象 done属性值为 true， 循环终并且不包含该对象返回值；1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function* fn()&#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let i of fn())&#123; console.log(i); //1 2 3 4 5 undefined&#125;//斐波那契数列function* fibonacci() &#123; let [prev, curr] = [0, 1]; for (;;) &#123; yield curr; [prev,curr] = [curr, prev + curr]; &#125;&#125;for (let f of fibonacci()) &#123; if (f &gt; 1000) break; console.log(f)&#125;//遍历任意对象方法function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let key of propKeys)&#123; yield [key,obj[key]]; &#125;&#125;let person = &#123;name:'Owen', age:18&#125;;for (let [key,value] of Object.entries(person))&#123; console.log(key,value); //name Owen // age 18&#125;for (let [key,value] of objectEntries(person))&#123; console.log(key,value); //name Owen // age 18&#125;//或者person[Symbol.interator] = objectEntriesfor (let [key,value] of person)&#123; console.log(key,value); //name Owen // age 18&#125; Generator throw 在函数体外抛出错误，再在 函数体内捕获。throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。因为只有执行一次 next方法，函数才开始执行。 1234567891011121314151617181920212223function* g() &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部1',e ) &#125;; try &#123; yield; &#125; catch (e) &#123; console.log('内部2',e) &#125;; &#125;let t = g();t.next(); //&#123;value: undefined, done: false&#125;try&#123; t.throw('a'); t.throw('b'); t.throw('c');&#125; catch(e)&#123; console.log('外部',e)&#125;//内部1 a//内部2 b//外部 c Generator return 结束 Generator 函数 并且给定对象返回值如果有 try...finally，且在执行中，return方法会等待finally 执行完毕，再执行。12345678910111213141516171819202122232425262728293031function* g()&#123; yield 1; yield 2;&#125;let ge = g();ge.next(); // &#123; value: 1, done: false &#125;ge.return('Owen'); // &#123; value:"Owen", done: true &#125;ge.next() // &#123; value: undefined, done: true &#125;// try...finallyfunction* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var nun = numbers();nun.next() // &#123; value: 1, done: false &#125;nun.next() // &#123; value: 2, done: false &#125;nun.return(7) // &#123; value: 4, done: false &#125;nun.next() // &#123; value: 5, done: false &#125;nun.next() // &#123; value: 7, done: true &#125; next()、throw()、return() 都是让 Generator 恢复执行，并且使用不同语句替换 yield yield* Generator 函数默认不在内部调用另一个 Generator 函数 是没有效果的，如果放到 yield 后面 会返回一个遍历器对象yield* 后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个 for...of 循环。如果 yield* 后面紧跟数组，会遍历数组成员（数组原始支持遍历器）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//默认function* f()&#123; yield 1; yield 2;&#125;function* g()&#123; yield 'x'; f(); yield 'y';&#125;for(let key of g())&#123; console.log(key) //"x" "y"&#125;//yield*function* y()&#123; yield 'x'; yield* f(); yield 'y';&#125;for (let k of y()) &#123; console.log(k); // "x" "y" 1 2&#125;//无 returnfunction* concat(iter1, iter2) &#123; yield* iter1; yield* iter2;&#125;// 等同于function* concat(iter1, iter2) &#123; for (var value of iter1) &#123; yield value; &#125; for (var value of iter2) &#123; yield value; &#125;&#125;// yield* array 如果去掉 * 会返回整个数组//任何数据结构只要有 Iterator 接口，就可以被yield*遍历。function* gen()&#123; yield* ["a", "b", "c"];&#125;var g = gen();g.next() //&#123;value: "a", done: false&#125;g.next() //&#123;value: "b", done: false&#125;g.next() //&#123;value: "c", done: false&#125;g.next() //&#123;value: undefined, done: true&#125;//取出嵌套数组的所有成员function* iterTree(tree) &#123; if (Array.isArray(tree))&#123; for (let arr of tree) &#123; yield* iterTree(arr) &#125; &#125;else&#123; yield tree &#125;&#125;const tree = [1,[2,3],[4,[5,6],7],8];for (let v of iterTree(tree))&#123;console.log(v)&#125;//1 2 3 4 5 6 7 8[...iterTree(tree)] //[1, 2, 3, 4, 5, 6, 7, 8]//遍历完全二叉树// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 下面生成二叉树function make(array) &#123; // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123; result.push(node);&#125;result // ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 对象属性中的 Generator 函数1234567891011let obj = &#123; * generator()&#123; &#125;&#125;//orlet obj1 = &#123; generator :function* () &#123; &#125;&#125; Generator 函数的this Generator 函数不能和 new 一起使用 函数总返回一个遍历器，并且它指向 函数实例，同时继承 函数原型对象上的方法12345678910111213141516171819202122232425262728293031323334353637383940function* g() &#123; this.say = function()&#123; return 18 &#125;;&#125;g.prototype.say = function () &#123; return "Owen"&#125;let obj =g() //g &#123;&lt;suspended&gt;&#125;obj instanceof g //trueobj.say() //"Owen"obj.next() //&#123;value: undefined, done: true&#125;obj.say() //"Owen"//因为 next 返回的是遍历器对象而不是 this 对象,所以不会返回 18//通过call 绑定thisfunction* Gen()&#123; this.age = 18; yield this.name = "Owen";&#125;let obj = Gen.call(Gen.prototype);obj.next()obj.age // 18obj.next();obj.name //"Owen"// 使用 new 的变通方法function G()&#123; return Gen.call(Gen.prototype)&#125;let obj1 = new G();obj1.next()obj1.age // 18obj1.next();obj1.name //"Owen" Generator 函数异步应用 异步: 执行一个任务的时候还不能马上返回结果，那么先将其搁置到后台，执行其他任务，等到有结果返回之后放到消息队列中，等主线程任务执行完毕后，再从消息队列中取出对应任务（callback），执行。同步： 执行一个任务，中间无法中断，只能等待任务返回结果，才能执行其他任务。 异步编程： 回调函数123456$.ajax(&#123; url:&apos;url&apos;, success:function(res)&#123; console.log(res) &#125;&#125;) 事件监听 起初由网景公司知道一套事件驱动机制（事件捕获），之后IE 推出自己的驱动机制（事件冒泡）利用驱动机制实现事件代理委托12345678910111213141516el.addEventListener(event,function()&#123;&#125;,boolean);//IE8 以下el.attachEvent(event,function()&#123;&#125;)//事件代理委托var parent = document.getElementById('parent');parent.addEventListener('click',showColor,false); function showColor(e)&#123; var son = e.target; if(son.nodeName.toLowerCase() === 'li')&#123; console.log('The color is ' + son.innerHTML); &#125; &#125; 发布/订阅（观察者模式）123456789101112131415161718192021222324252627282930313233343536373839404142434445//实现一个简单的发布订阅/* 订阅一个事件，发布对应事件并且执行方法 需要先有代理主题 message proxy 然后订阅者去订阅 然后发布者发布消息执行方法 */ function PubSub () &#123;&#125;; // message proxy PubSub.prototype.message = &#123;&#125;; // publish PubSub.prototype.pub = function () &#123; // Turn arguments into real array let args = [].slice.call(arguments,0); let event = args.shift(); if(!this.message[event]) return this; let list = this.message[event]; for (let item of list) &#123; item.apply(this,args); &#125; return this; &#125; // subscribe PubSub.prototype.sub = function (event,callback)&#123; if( !this.message[event]) &#123; this.message[event] = []; &#125; this.message[event].push(callback); return this; &#125; // unsubscribe PubSub.prototype.unsub = function (event) &#123; if (!this.message[event]) return this; this.message[event] = null; &#125; Promise 对象 为了解决 “回调地狱”（callback hell）而提出的写法允许将 callback 变成链式调用12345678// read I/Olet readFile = require('fs-readfile-promise');readFile(fileA) .then( (data) =&gt; console.log(data.toString())) .then( () =&gt; readFile(fileB)) .then( (data) =&gt; console.log(data.toString())) .catch((err) =&gt; console.log(err)); Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 Generator 函数（es6）协程 多个线程相互协作，完成异步任务步骤 A方法开始任务 A方法执行到一半，暂停，将执行权转移到主线程 一段时间后主线程交还执行权 A方法恢复执行 12345678//examplefunction* async () &#123; //... do something let file = yield readFile(fileA); //... do something&#125;//异步操作需要暂停的地方，都用yield语句注明。 协程代码的写法非常像同步操作，Generator 函数最大优点是可以交出函数执行权 函数通过next 进行数据交换，通过 throw进行错误处理123456789101112function* async (num) &#123; let n; try&#123; n = yield ++num; &#125;catch(err)&#123; console.log(err) &#125; return n&#125;let g = async(1);g.next()g.throw('error'); 封装异步任务使用node-fetch 模块 返回一个Promise 对象123456789101112let fetch = require('node-fetch');let g = gen();let result = g.next();result.value.then((data) =&gt; data.json()) .then((data) =&gt; g.next(data) );function* gen() &#123; let url = '/index.json'; let result = yield fetch(url);&#125; Thunk (形实转换)函数传值策略 传值调用（参数在传入函数前计算）,简单易懂，不过可能会造成性能损失 传名调用（将参数放到一个临时函数，再将这个临时函数传入函数体（Thunk 函数)） 1234567891011//传值var x = 3;function fn (x,b) &#123; return x * 3 &#125;;fn(x + 1) // 4 * 3//传名fn(x + 1) // (x + 1) * 3 //等同于var thunk = function ()&#123; return x + 1&#125;fn (thunk) // thunk() * 3 async/await（es7)]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>async</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflect]]></title>
    <url>%2F2019%2F04%2F02%2FReflect%2F</url>
    <content type="text"><![CDATA[Reflect 将Object对象中一些属于语言内部的方法，放到 Reflect对象中会逐渐替换Object对象 中对应的方法优化一些放法返回的结果只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法,不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。 静态方法 13 个静态方法 作用对应Object同名方法 所有方法第一个参数，必须是对象，否则报错 Reflect.apply(target, thisArg, args) 等同于 Function 构造函数中的Function.prototype.apply.call(func, thisArg, args)1234567891011const ages = [11, 33, 12, 54, 18, 96];// ES5const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// Reflectconst youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []); Reflect.construct(target, args) 对应 new target(...args) 提供了一种不使用 new，来调用构造函数的方法。123456789function Greeting(name) &#123; this.name = name;&#125;// new 的写法const instance = new Greeting('Owen');// Reflect.construct 的写法const instance = Reflect.construct(Greeting, ['Owen']); Reflect.get(target, name, receiver) 查找目标对象属性值并返回1234567891011121314151617let obj = &#123; name : 'Owen', age:18, get baz()&#123; return this.name + this.age &#125;&#125;Reflect.get(obj,'name') //'Owen'Reflect.get(obj,'baz') //'Owen18'// receiver 改变 get 函数 this 指向let obj1 =&#123; name : 'Owen', age:16,&#125;Reflect.get(obj,'baz',obj1) //'Owen16 Reflect.set(target, name, value, receiver)123456789101112131415161718let obj = &#123; name : 'Owen', age:18, set baz(val)&#123; return this.age = val; &#125;&#125;Reflect.set(obj,'name','wen') obj.name //'wen'Reflect.set(obj,'baz', 16)obj.age // 16//receiver 改变 set this 指向let obj1 = &#123; name: 'wen'&#125;Reflect.set(obj,'baz', 16,obj1)obj.name // wen 如果 Proxy和 Reflect 联合使用，并且传入 receiver ， 那么 Reflect.set 会触发Proxy.defineProperty1234567891011121314151617181920212223let proxy = &#123; name:'Owen'&#125;let handler = &#123; set (target, key, value, receiver)&#123; console.log('set') Refelect.set(target, key, value, receiver) &#125;, defineProerty(target, key, attribute)&#123; console.log('defineProperty') Reflect.defineProperty(target, key, attribute) &#125;&#125;let obj = new Proxy(proxy,handler)obj.name = 'wen';// set// defineProperty/* 因为Proxy.set的receiver参数总是指向当前的 Proxy实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截。*/ Reflect.defineProperty(target, propertykey, attribute) 对应 Object.defineProperty12345678910111213function MyDate() &#123; /*…*/&#125;// es5Object.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;);// es6Reflect.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;); Reflect.deleteProperty(target, name) 对应 delete obj.name12345678let obj = &#123; name:'Owen'&#125;//es5 delete obj.name// ReflectReflect.deleteProperty(obj,'name') Reflect.has(target, name) 对应 name in obj 中的 in 运算12345678let obj = &#123; name:'Owen'&#125;//es5 'name' in obj // ture//ReflectReflect.has(obj,'name') //true Reflect.ownKeys(target) 对应 Object.getOwnPropertyNames and Object.getOwnPropertySymbols 返回对象所有属性1234567891011121314151617let obj = &#123; name:'Owen', age:18, [Symbol.for('name')]:'Owen', [Symbol.for('age')]:18&#125;//es5Object.getOwnPropertyNames(obj)// ['name', 'age']Object.getOwnPropertySymbols(obj)//[Symbol(name), Symbol(age)]//es6Reflect.ownKeys(obj)//['name', 'age',Symbol(name), Symbol(age)] Reflect.isExtensible(target) 对应 Object.isExtensible 返回 boolean，表示当前对象是否可扩展。123456const obj =&#123;&#125;//es5Object.isExtensible(obj) //true//es6Reflect.isExtensible(obj) //true Reflect.preventExtensions(target) 对应 Object.preventExtensions 让一个对象变为不可扩展。它返回 boolean，表示是否操作成功。123456const obj =&#123;&#125;// es5 Object.preventExtensions(obj) // Object &#123;&#125;// es6Reflect.preventExtensions(obj) // true Reflect.getOwnPropertyDescriptor(target, propertyKey) 对应 Object.getOwnPropertyDescriptors 返回对象所有自身属性（非继承） 的描述对象1234567891011var obj t = &#123;&#125;;Object.defineProperty(obj, 'hidden', &#123; value: true, enumerable: false,&#125;);// es5var theDescriptor = Object.getOwnPropertyDescriptor(obj, 'hidden');// es6theDescriptor = Reflect.getOwnPropertyDescriptor(obj, 'hidden'); Reflect.getPrototypeOf(target) 获取对象原型参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。1234567const myObj = new FancyThing();// es5 Object.getPrototypeOf(myObj) === FancyThing.prototype;// ReflectReflect.getPrototypeOf(myObj) === FancyThing.prototype; Reflect.setPrototypeOf(target, prototype) 对应Object.setPrototypeOf 设置 原型对象， 返回 Boolean 123456789101112const obj = &#123;&#125;;function Person ()&#123;&#125;//es5Object.setPrototypeOf(obj,Person.prototype);//es6 Reflect.setPrototypeOf(obj,Person.prototype);obj.length //0 Proxy Observer Mode 函数字段观察数据对象，如果数据改变，函数自动执行 1234567891011121314151617181920212223242526272829303132333435const queue = new Set();//队列函数const observe = callback =&gt; queue.add(callback);//观察目标const observable = obj =&gt; new Proxy(obj,&#123;set&#125;);//自动执行function set (target,key,value,receiver)&#123; const result = Reflect.set(target,key,value,receiver); queue.forEach(observer =&gt; observer() ); return result&#125;const person = observable(&#123; name:'Owen', age:18&#125;) function auto()&#123; console.log(`$&#123;person.name&#125;,$&#123;person.age&#125;`); &#125;observe(auto);person.name = 'Owen';/* 先定义一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。 */]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[proxy]]></title>
    <url>%2F2019%2F03%2F26%2Fproxy%2F</url>
    <content type="text"><![CDATA[Proxy 用于修改某些操作的默认行为。（对编程语言进行编程）在目标对象之前架设一层‘门户’，外界访问对象时，必须先访问这个门户，对外界的访问进行过滤和改写 生成: ES6中 所有proxy实例 通过 Proxy 构造函数生成12345678910 new Proxy(target,handler);// target对象 要访问的对象， handler对象 拦截行为var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35 Proxy 支持的操作get(target, propKey, proxy) 拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。12345678910111213141516171819202122/***get 接收三个参数*target 目标对象*property 属性名*proxy 实例本身**/var obj = &#123; name:"Owen"&#125;;var proxy = new Proxy(obj, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError("Property \"" + property + "\" does not exist."); &#125; &#125;&#125;);proxy.name // "Owen"proxy.age // error:Property "age" does not exist.//如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 set(target, propKey, value, proxy) 拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。12345678910111213141516171819202122232425262728293031/***set 有4 个参数*target 目标对象*property 属性名*value 属性值*proxy 实例本身 */ let validator = &#123; set: function(obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('The age is not an integer'); &#125; if (value &gt; 100) &#123; throw new RangeError('The age seems invalid'); &#125; &#125; // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; return true //严格模式下 return false or undefined 会报错 &#125;&#125;;let obj = new Proxy(&#123;&#125;, validator);obj.age = 18;obj.age ='18'; //errorobj.age =101;//error//每当对象发生变化时，会自动更新 DOM。 has(target, propKey) 拦截propKey in proxy的操作，返回一个布尔值。1234567891011121314151617/***接收两个参数*target目标对象*key 查询的属性名**/var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: 'Owen' &#125;;var proxy = new Proxy(target, handler);'_prop' in proxy // false//拦截以‘_’开头的属性名 对for ...in 遍历不生效 deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。1234567891011121314151617var handler = &#123; deleteProperty (target, key) &#123; invariant(key, 'delete'); delete target[key]; return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private "$&#123;key&#125;" property`); &#125;&#125;var target = &#123; _prop: 'foo' &#125;;var proxy = new Proxy(target, handler);delete proxy._prop// Error: Invalid attempt to delete private "_prop" property ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。123456789101112131415161718//拦截对象自身属性的读取操作let target = &#123; _bar: 'foo', _prop: 'bar', prop: 'Owen'&#125;;let handler = &#123; ownKeys (target) &#123; return Reflect.ownKeys(target).filter(key =&gt; key[0] !== '_'); &#125;&#125;;let proxy = new Proxy(target, handler);for (let key of Object.keys(proxy)) &#123; console.log(target[key]);&#125;//会自动过滤 不存在的属性，Symbol，不可遍历属性 getOwnPropertyDescriptor(target, propKey) 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。12345678910111213141516var handler = &#123; getOwnPropertyDescriptor (target, key) &#123; if (key[0] === '_') &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: 'bar', baz: 'tar' &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, 'wat')// undefinedObject.getOwnPropertyDescriptor(proxy, '_foo')// undefinedObject.getOwnPropertyDescriptor(proxy, 'baz')// &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125; defineProperty(target, propKey, propDesc) 拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。12345678var handler = &#123; defineProperty (target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.owen = 'Owen' // 不会生效 preventExtensions(target) 拦截Object.preventExtensions(proxy)，返回一个布尔值。该方法必须返回一个布尔值，否则会被自动转为布尔值。目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true12345678var proxy = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125;&#125;);Object.preventExtensions(proxy)//error getPrototypeOf(target) 拦截Object.getPrototypeOf(proxy)，返回一个对象。12345678910111213141516//主要拦截获取对象原型/** *Object.prototype.__proto__*Object.prototype.isPrototypeOf()*Object.getPrototypeOf()*Reflect.getPrototypeOf()*instanceof**/var proto = &#123;&#125;;var p = new Proxy(&#123;&#125;, &#123; getPrototypeOf(target) &#123; return proto; &#125;&#125;);Object.getPrototypeOf(p) === proto // true//返回值必须是对象或者null，否则报错 isExtensible(target) 拦截Object.isExtensible(proxy)，返回一个布尔值。123456789var p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; console.log("Owen"); return true; &#125;&#125;);Object.isExtensible(p)//返回值必须是Boolean setPrototypeOf(target, proto) 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。12345678910var handler = &#123; setPrototypeOf (target, proto) &#123; throw new Error('Changing the prototype is forbidden'); &#125;&#125;;var proto = &#123;&#125;;var target = function () &#123;&#125;;var proxy = new Proxy(target, handler);Object.setPrototypeOf(proxy, proto);// Error: Changing the prototype is forbidden apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。1234567891011121314151617/***接收三个参数 *target 目标对象*this 目标对象上下文*目标对象的参数数组*/var target = function () &#123; return 'I am the target'; &#125;;var handler = &#123; apply: function () &#123; return 'I am the proxy'; &#125;&#125;;var p = new Proxy(target, handler);p()// "I am the proxy" construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。123456789101112131415//接收两个参数/***target 目标对象*args 构造函数参数对象函数必须返回对象，否则会报错 */ let obj = &#123; construct: function(target, args) &#123; console.log('Owen: ' + args.join(', ')); return &#123; value: args[0] * 10 &#125;; // retirn '18'; error &#125; &#125; var p = new Proxy(function () &#123;&#125;, obj) new p(2).value // 20 Proxy.revocable Proxy.revocable方法返回一个可取消的 Proxy 实例。使用场景： 目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。1234567891011121314let target = &#123;&#125;let handler = &#123;&#125;let &#123;proxy, revoke&#125; = Proxy.revocable(target,handler);/* Proxy.revocable(target, handler);&#123;proxy: Proxy, revoke: ƒ&#125;*/proxy.name = 'Owen'proxy.namerevoke() //取消 proxy 实例proxy.name //error Proxy this 在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 123456 const target = new Date();const handler = &#123;&#125;;const proxy = new Proxy(target, handler);proxy.getDate();//error Proxy 实例使用123456789101112131415const service = createWebService('http://example.com/data');service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ···&#125;);function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl+'/' + propKey); &#125; &#125;);&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Extend]]></title>
    <url>%2F2019%2F03%2F19%2Fextend%2F</url>
    <content type="text"><![CDATA[String Extend被 for ... of 遍历1234567for (let val of 'abc')&#123; console.log(val); //a //b //c&#125; 查找字符12345678910let str = 'Hello Brother!';//includes 是否包含参数字符串str.includes('Br'); //true//startsWith 开头是否存在参数字符串str.startsWith('Hello') //true//endsWith 结尾是否存在参数字符串str.endsWith('er!')//true 重复字符12345678910//repeat 重复 n 次， n 为参数,返回新字符串let re = 'Hello Brother!';re.repeat(2); //"Hello Brother!Hello Brother!"re.repeat(-2); // Invalid count valuere.repeat(Infinity); // Invalid count value//小数会取整 re.repeat(1.9) // "Hello Brother!"re.repeat(-0.9) // "" 补全字符1234567891011121314//补全开头 padStart 补齐尾部 padEndlet pd = 'Brother!'; pd.padStart(14,'Hello '); //"Hello Brother!"//第一个参数为补齐的最大长度（整串字符） 第二个参数为补齐缺省的字符串//如果原始字符长度大于等于最大长度，返回原字符串pd.padStart(7,'Hello ')// 'Brother!'pd.padStart(8,'Hello ')// 'Brother!'//如果最大长度小于补齐长度，则去除超出部分pd.padStart(9,'Aay ')//'ABrother!'//如果缺省第二个参数则 默认使用空格补齐pd.padStart(9)//' Brother!' 模板字符 通过反引号 “ ” 当普通字符串使用1234567891011121314//所有换行和空格会保留，嵌入变量，须将变量包含在 `$&#123;&#125;` 中，并且可进行运算,函数调用，对象调用let num =1,obj =&#123;name:'Owen'&#125;, fn=()=&gt; 3;const str =` $&#123;num * 3 + 1 + fn() + obj.name&#125;`;console.log(str)/* " 7Owen"*///如果紧更在函数名后，函数将被调用（标签模板）alert`123` // 等同于alert(123) 转义符 \12345678//以 x 开头,会被当做 16 进制 `\x23` // # //以 u 开头,会被当做 unicode 字符 `\u004F` //"O"//如果无法编译将会报错 ES2018 放松了对标签模板里面的字符串转义的限制，无法转义的返回undefined； 123console.log`\uw`;//[undefined, raw: Array(1)]//undefined Function Extend形参指定默认值 形参 不能再次使用 let 和 const 声明形参不能重名函数 length 不包含设置默认值和后面的形参个数使用 ...arg 中的参数 length 也不包含 12345678910111213const fn = (x, y = 'Owen') =&gt;( console.log(x,y));fn(1) // 1 "Owen"//默认参数 惰性求值let x = 99;function foo(y = x + 1) &#123; console.log(y);&#125;foo() // 100x = 100;foo() // 101//调用一次计算一次 事实上 每次调用函数，如果不传递参数， 形参默认传递 undefined 12345678910111213 // 默认参数最好定义再尾部，因为使用形参默认参数，那么那个位置的形参必传function f(x, y = 5, z， ...arg) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2]//length 不包含设置默认值 和后面的形参 的个数，f().length // 1 作用域 函数中的变量无法访问 默认值函数中的形参名不能和默认名一样123456789101112131415161718192021222324//函数变量无法访问默认值function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // ReferenceError: x is not defined//函数中的形参名不能和默认名一样//参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错function f(x = x) &#123; console.log(x);&#125;f()// x is not definedvar x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 由于 var 声明的 x 和函数形参 x 不再同一个作用域 ， 因此调用 y() x值不变；如果 去掉 var , 那么 x 就指向 形参 x ,调用 y() x = 2。 reset 参数 （…） 使用形式 ...arg 实数以数组的形势赋给变量reset 参数后不能再有形参，否则报错123456789function fn (a,...arg)&#123; return arg;&#125;fn(0,2,3,4,5)//[2,3,4,5]function foo (a,...arg,b)&#123; return arg;&#125;//ught SyntaxError: Rest parameter must be last formal parameter 只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425// 报错function f(a, b = a) &#123; 'use strict'; // code&#125;// 报错const foo = function (&#123;a, b&#125;) &#123; 'use strict'; // code&#125;;// 报错const fn = (...a) =&gt; &#123; 'use strict'; // code&#125;;const obj = &#123; // 报错 fn(&#123;a, b&#125;) &#123; 'use strict'; // code &#125;&#125;;#### 箭头函数&gt;使用 () =&gt; 定义函数注意：- this 指向函数定义时所绑定的普通函数，不会被(bind,call,apply)更改,也不会被调用时的上下文改变。1234567891011121314151617181920212223let fn = () =&gt;console.log(this);let obj = &#123;name:"Owen"&#125;;fn.call(obj) //windowfn.bind(obj)fn() //windowfn.apply(obj) //window //可以通过改变宿主环境来改变 this 指向 function foo ()&#123; return () =&gt;&#123; console.log(this); return ()=&gt; &#123;console.log(this)&#125;; &#125;&#125;foo.call(obj)() //&#123;name: "Owen"&#125;foo.call(obj)()() //&#123;name: "Owen"&#125; &#123;name: "Owen"&#125;- 外层没有普通函数 ，严格模式和非严格模式下它的this都会指向window(全局对象)。- 不可以当作构造函数，也就是说，不可以使用new命令，没有prototype属性，不支持new.target,否则会抛出一个错误。- 参数和箭头之间不能换行- 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。- 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。123456789101112131415161718192021222324252627282930313233343536//定义简单函数let fn = () =&gt; 'Owen';fn()// 'Owen'let foo = r =&gt; r;foo('Owen') // 'Owen'let f = (num1,num2) =&gt; num1 + num2;f(1,2)//3//如果返回一个对象需要小括号包裹,f否则会报错let f = (name,age) =&gt; (&#123;name,age&#125;);f('Owen',18)//&#123;name: "Owen", age: 18&#125;//如果代码部分大于一条语句，那么需要 大括号包裹，使用return 返回值let fn1 = r =&gt; &#123; let a = 1; console.log(a); return r + a;&#125;#### **不推荐使用场景**- 在对象中使用 this.```javascriptvar obj = &#123; gender:"man", getSex: () =&gt; &#123;console.log(this.gender)&#125;&#125;obj.getSex() //undefined//this -&gt; global- 动态使用 this.12345var lis = document.querySelector('li');lis.addEventListener('click',() =&gt; &#123; console.log(this)&#125;)// this -&gt; global- 内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数#### 双冒号运算符 ::&gt; 目前只是一个提案，用来绑定函数的 this 类似于 (bind,call,apply)&gt; 将做边的对象作为参数，绑定到右边函数上。1234567bar:: fn//等同于fn.bind(bar);bar::fn(...arguments);//等同于fn.apply(bar, arguments);#### 函数调用12345678 function f()&#123; foo()&#125; function foo()&#123; fn()&#125;function fn()&#123;&#125;f()&gt; 函数调用会在内存中形成一个 调用记录（调用帧），保存着调用位置和内部变量等信息。&gt; 函数 f内部调用 foo函数，f调用帧的上方会形成 foo的调用帧， foo运行接受并且将结果返回给 f，foo的调用帧才会消失，同理，foo函数 内部调用fn函数，还会有 fn 的调用帧，以此类推，形成一个调用栈。#### 尾调用&gt; 指某个函数的最后一步是调用另一个函数。&gt; 不一定出现在函数尾部，只要是最后一步操作即可。123456789101112131415161718192021222324252627//尾调用function f(x)&#123; return fn(x);&#125;//不属于尾调用// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; //等同于function f(x)&#123; g(x); return undefined;&#125;——### Array Extend#### 扩展运算 (…)&gt;主要用于函数调用， 将一个数组，变为参数序列。12345function add(x, y) &#123; return x + y;&#125;add(... [1,2]) // 3##### clone数组 123456789 //es5 let arr = [1,2];let arr1 = arr.concat(); //es6let [...arr2] = arr;let arr3 = [...arr];##### 合并数组1234567let arr = [1,2];let arr1 = [3,4];let arr2 = [5,6];//es5let arr3 = arr.concat(arr1,arr2);//es6let arr4 = [...arr,...arr1,...arr2];合并和clone 都是浅拷贝；##### 配合解构赋值1234567891011121314151617const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = ["foo"];first // "foo"rest // []//扩展运算符，只能放在参数的最后一位，否则会报错。const [first, ...middle, last] = [1, 2, 3, 4, 5];//error##### 将伪数组(内部实现了Iterator)转化伪数组1234567891011121314151617//内部实现Iterator//字符串， Set, Map, Generator, NodeList, htmlcollection, classList ,argument内部都实现了迭代接口let nodes = document.querySelectorAll('div');let divs = [...nodes];//内部未实现Iteratorlet objs = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr =[...objs];//error//可通过 Array.from方法转化let arr1 = Array.from(objs)#### Array.from&gt; 将伪数组转化为数组123456789101112131415161718192021222324252627let arrLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr = Array.from(arrLike)/*第二个参数 遍历每个元素并返回运算结果*/Array.from(arrLike, x =&gt; x * x);// 等同于Array.from(arrLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9]//将布尔值为false的成员转为0Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3]//获取DOM 节点的文本内容。Array.from(document.querySelectorAll('span.name');, s =&gt; s.textContent)//第三个参数 绑定第二个参数中回调函数的this#### find and findIndex&gt; 回调函数遍历所有成员，返回符合条件的值， 没有则返回 undefined&gt; find 返回值为，第一个符合条件的成员&gt;findIndex ，没有则返回 -1&gt; 回调函数接受三个参数（成员，位置，原数组）&gt; 第二个参数 绑定回调函数 this&gt; 可以识别NaN1234567[1, 4, -5, 10].find(function(v,i,arr)&#123; return v&lt;0;&#125;)// -5[1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0)// 2#### fill&gt; 填充数组,修改原数组&gt; 第一个参数为填充值，第二个参数为开始填充的位置，第三个参数为结束位置12345let arr =[1,2,3];arr.fill('Owen');//["Owen","Owen","Owen"]arr.fill(1,0,2);//[1,1,3]#### Interator&gt; keys,values,entries 对应属性遍历123456789101112131415161718// keyslet arr = ['o','w','e','n'];for (let key of arr.keys())&#123; console.log(key); //0 1 2 3&#125;for (let item of arr.values())&#123; console.log(item); //o w e n&#125;for (let [i,item] of arr.entries())&#123; console.log(i,item)//1 "w"//2 "e"//3 "n"&#125;#### includes&gt; 返回一个Boolean ,数组是否包含给定的值1234567891011[1,2,3,4].includes(3)//true//第二个参数为搜索的起始位置[1,2,3,4].includes(3,4)//false/* 是否支持 */const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false#### flat ,flatMap&gt; 将二维数组变成一位数组，并返回新数组12345678910[1,2,[3,4]].flat()//[1,2,3,4]//默认拉平1层[1,2,[3,[4]]].flat(2)//[1,2,3,4]//将所有维度变成一维array.flat(Infinty)//会忽略空位[1,,[3,4]].flat()//[1,3,4]—#### ES5 methods##### every- 访问每一个成员,给定某个条件，如果所有成员满足条件就返回true123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.every(function(item,key,array)&#123; return ( item&gt;2 )&#125;) n //false#### some- 访问每一个成员,给定某个条件，只要有一个成员满足条件就返回true- 有一个满足条件的成员之后的不再执行123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.some(function(item,key,array)&#123; return ( item &gt; 2 )&#125;) n //true##### filter- 访问每一个成员,给定某个条件，将满足条件的成员组成数组返回， 否则返回 []- 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用 123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.filter(function(item,key,array)&#123; return ( item &gt; 2 )&#125;) n //[3, 4, 5, 4, 3] map 访问每一个成员,将每次访问执行的结果组成数组返回，也就是说每个成员都 必须要有return返回结果，否则都是unndefined map不支持continue跳出循环 123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.map(function(item,key,array)&#123; return item * 2&#125;) n // [0, 2, 4, 4, 6, 8, 10, 6, 10] forEach 访问每一个成员,没有返回值 中途不能用常规操作跳出循环 不支持链式操作123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.map(function(item,key,array)&#123; return item * 2&#125;) n // undefined reduce and reduceRight reduce 从数组的第一项开始，逐个遍历到最后。 reduceRight 从数组的最后一项开始，向前遍历到第一项。 接收两个参数 回调函数和 回调函数第一个参数的值，默认数组第一个元素。 返回 累计处理的结果 12345678910111213141516171819 /** * @param * prev 上次调用回调时的累积值 * cur 当前数组成员 * i 数组索引 * arrary 原数组 * */var num = [0,1,2,2,3,4,5,3,5];var n = num.reduce(function(prev,cur,i,array)&#123; return prev*2 + cur&#125;) n // 431 var num = [0,1,2,2,3,4,5,3,5];var n = num.reduce(function(prev,cur,i,array) &#123; return prev*2 + cur&#125;) n // 2186 以上都不会修改原数组，除非使用第三个参数做些操作，注意数组成员是值类型，还是引用类型 sort 对数组排序 默认排序按字母升序（根据字符串Unicode ） 参数为回调函数callback(a,b) 返回值为负数 那么 a 会被排列到 b 之前 返回值为 0 位置不变 返回值为正数 b 会被排列到 a 之前12345var num = [1,3,2,7,44,2,3,4,9];num.sort(function(a,b)&#123; return a-b&#125;)num // [1, 2, 2, 3, 3, 4, 7, 9, 44] reverse 翻转数组123var num = [1,3,2,7,44,2,3,4,9];num //[9, 4, 3, 2, 44, 7, 2, 3, 1]num.reverse() 数组去重 has方法 会发生隐式转化 1 ==’1’ 123456789101112131415161718192021222324252627282930 var arr = [2,3,4,2,3,5,6,4,3,2];var unique = function(arr) &#123; var obj = &#123;&#125;; var res = []; arr.forEach(function(item,i)&#123; if(!obj[item])&#123; obj[item] = true; res.push(item) &#125; &#125;) return res&#125;unique(arr)&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD=======- map has方法 不会发生隐式转化var unique = function(arr) &#123; var m = new Map(); var res = []; arr.forEach(function(item,i)&#123; if(!m.has(item))&#123; res.push(item) &#125; m.set(item,2); &#125;) return res&#125;unique(arr)&gt;&gt;&gt;&gt;&gt;&gt;&gt; d71c39e5118389885ef986735a9a15598115e5b9 filter 1234567891011121314151617//会忽略 undefinedvar arr = [null,null,null,undefined,undefined,'','',1,1,1];var unique = function (arr) &#123; return arr.sort().filter(function(item,i,array) &#123; return item !== array[i+1]; &#125;)&#125; unique(arr) // ["", 1, null]var unique = function(arr) &#123; return arr.filter( function(item, idx ) &#123; return arr.indexOf(item) === idx; &#125;)&#125;unique(arr) //[null, undefined, "", 1] Object extend对象中的简写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//函数const obj =&#123; methode()&#123; return 'Owen' &#125;, * m() &#123; yield 'hello world'; &#125;&#125;//等同于const obj =&#123; methode:function()&#123; return 'Owen' &#125; m:function* ()&#123; yield 'hello world'; &#125;&#125;//使用变量定义对象 //默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。let lastWord = 'last word';const obj = &#123; 'first word': 'hello', [lastWord]: 'world', ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj['first word'] // "hello"obj[lastWord] // "world"obj['last word'] // "world"obj.hello() // hi//对象中 函数 name属性//对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。const key1 = Symbol('description');const key2 = Symbol();let obj = &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;, sayName() &#123; console.log('Owen'); &#125;, get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;obj[key1].name // "[description]"obj[key2].name // ""obj.sayName.name // "sayName"const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');descriptor.get.name // "get foo"descriptor.set.name // "set foo"//通过构造函数创立的函数(new Function()).name // "anonymous"//通过 bind 绑定的函数var doSomething = function() &#123; // ...&#125;;doSomething.bind().name // "bound doSomething" 枚举和遍历 Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象 12345678910let obj = &#123; name:'Owen'&#125;Objct.getOwnPropertyDescriptor(obj,'name');// &#123;// value: Owen,// writable: true,// enumerable: true, //可枚举// configurable: true// &#125; 如果 enumerable 为 false有些操作会忽略，当前属性 for…in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 (ES6) Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 共有 5 种方法可以遍历对象的属性。 for…in for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。 super this 总是指向函数所在的当前对象super 指向当前对象的原型对象。super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。12345678910111213const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // "hello" 对象扩展运算符 ES2018 将这个运算符引入了对象。解构赋值的拷贝是浅拷贝不能复制继承自原型对象的属性。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 解构//必须保证右方为对象，否则报错let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125;//与函数参数扩展运算类似，解构赋值须最后一个参数let &#123; ...x, y, z &#125; = someObject; // 句法错误let &#123; x, ...y, ...z &#125; = someObject; // 句法错误//无法继承原型let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2.__proto__ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined//扩展运算//数组是特殊的对象，所以对象的扩展运算符也可以用于数组let foo = &#123; ...['a', 'b', 'c'] &#125;;foo// &#123;0: "a", 1: "b", 2: "c"&#125;//扩展运算符后面是一个空对象，无效果&#123;...&#123;&#125;, a: 1&#125;// &#123; a: 1 &#125;//扩展运算符后面不是对象，则会自动将其转为对象 &#123;...1&#125; // &#123;&#125;//扩展运算符后面是字符串，它会自动转成一个类似数组的对象&#123;...'Owen'&#125;//&#123;0: "O", 1: "w", 2: "e", 3: "n"&#125;let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b);//完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。// 写法一 非浏览器环境不一定部署 __proto__const clone1 = &#123; __proto__: Object.getPrototypeOf(obj), ...obj&#125;;// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj);// 写法三const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj))//对象的扩展运算符后面可以跟表达式const obj = &#123; ...(x &gt; 1 ? &#123;a: 1&#125; : &#123;&#125;), b: 2,&#125;;//扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行let aWithXGetter = &#123; ...a, get x() &#123; throw new Error('not throw yet'); &#125;&#125;;// 会抛出错误，因为 x 属性被执行了let runtimeError = &#123; ...a, ...&#123; get x() &#123; throw new Error('throw now'); &#125; &#125;&#125;; New method for objectsObject.is() 比较两个值是否严格相等 和 === 的区别12345678910111213141516171819+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // truees5 实现Object.defineProperty(Object,'is',&#123; value: function(x, y) &#123; if (x === y) &#123; // 针对+0 不等于 -0的情况 return x !== 0 || 1 / x === 1 / y; &#125; // 针对NaN的情况 return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;) Object.assign() 浅拷贝对象，无法拷贝原型,也不拷贝不可枚举的属性。总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。同属性后面的覆盖前面的值 12345678Object.assign(&#123;b: 'c'&#125;, Object.defineProperty(&#123;&#125;, 'invisible', &#123; enumerable: false, value: 'hello' &#125;) )// &#123; b: 'c' &#125;Object.assign([1, 2, 3], [4, 5])//[4,5,3] Object.getOwnPropertyDescriptors() 返回目标对象所有自身属性（非继承） 的描述对象12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return 'Owen' &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; 主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。1234567891011121314151617const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target = &#123;&#125;;const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source));shallowMerge(target,source)Object.getOwnPropertyDescriptor(target, 'foo')// &#123; get: undefined,// set: [Function: set foo],// enumerable: true,// configurable: true &#125; 配合Object.create()方法，将对象属性克隆到一个新对象1234const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); 实现一个对象继承另一个对象。123456789101112131415//一const obj1 = Object.create(prot);obj.foo = 123;//二const obj2 = Object.assign( Object.create(prot), &#123; foo: 123, &#125;//三const obj3 = Object.create(prot,Object.getOwnPropertyDescriptors(&#123; name:'Owen'&#125;))); 实现Mixin1234567891011121314let mix = (obj) =&gt; ( &#123; with:(...mixins) =&gt; mixins.reduce( (c,mixin) =&gt; Object.create( c, Object.getOwePropertyDescriptors( minxin )), obj ) &#125;)let a = &#123;a: 'a'&#125;;let b = &#123;b: 'b'&#125;;let c = &#123;c: 'c'&#125;;let d = mix(c).with(a, b);d.c // "c"d.b // "b"d.a // "a" proto属性，Object.setPrototypeOf()，Object.getPrototypeOf() 设置，和 获取原型12345678910111213141516171819202122232425//setlet proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40//getfunction Rectangle() &#123; // ...&#125;const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false Object.keys()，Object.values()，Object.entries()1234567891011//keyslet obj = &#123; foo: 'bar', baz: 42 &#125;; //es5Object.keys(obj)// ["foo", "baz"]//valuesObject.values(obj)//['bar,42]Object.entries(obj)// [['foo', 'bar'], ['baz', 42]] Object.fromEntries() Object.entries 方法的逆操作12345Object.fromEntries([ ['foo', 'bar'], ['baz', 42]])// &#123; foo: "bar", baz: 42 &#125; 目前谷歌版本 Chrome/72.0.3626.121 Safari/537.36 及以下不支持]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Extend Methods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map]]></title>
    <url>%2F2019%2F03%2F19%2Fmap%2F</url>
    <content type="text"><![CDATA[Map 键值对的集合 键名的范围不限制于字符串 1234567891011121314151617const m = new Map();const obj = &#123;name: 'Owen'&#125;;const fn = function()&#123;&#125;;//设值m.set(obj,"boy"); //将 obj 作为键名， 给它赋值//可以是对象，数组，甚至是函数，任何数据类型都可以当作属性名（键名）m.set(fn,1) //对同一个键名赋值，后面的将覆盖前面的//获值m.get(obj) // 'boy'//查询m.has(obj) // true//删除m.delete(obj)//true Map 参数 任何 Iterator 接口，并且每个成员都是双元素数组的数据结构 都可以作为参数123456789101112131415161718192021222324252627282930313233343536373839let arr = [[1,2],[2,3]];const ma = new Map(arr); //Map(2) &#123;1 =&gt; 2, 2 =&gt; 3&#125;ma.get(1) //2ma.get(2) //3//如果几组双元素成员相同那么只会生成一个值arr = [[1,2],[1,2]];mss = new Map(arr); //Map(1) &#123;1 =&gt; 2&#125;ma.size//2mss.size//1// keys 键名for (let key of ma.keys())&#123; console.log(key) //1 //2&#125;//values 值for (let val of ma.values())&#123; console.log(val) //2 //3&#125;//entries 键值 等同于 遍历 ma 默认遍历的是entries for (let [key,val] of ma.entries())&#123; console.log(key,val) //1,2 //2,3&#125;//转化为数组[... ma.keys() ] //[1,2][... ma.values() ] //[2,3][... ma] //[[1,2],[2,3]]]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set]]></title>
    <url>%2F2019%2F03%2F15%2Fset%2F</url>
    <content type="text"><![CDATA[Set ES6 提供的数据结构类似于数组，值是唯一的，通过 Set 构造函数来生成 1234567891011const arr = [1,2,2,3,4,5,3,2,3,4,5];//参数可以是一个可以迭代的数据结构const set = new Set(arr); //Set(5)&#123;1,2,3,4,5&#125;[...set] //[1,2,3,4,5]const set1 = new Set('12343333433225'); //Set(5) &#123;"1", "2", "3", "4", "5"&#125;set1.size //5//数组去重const arr1 = [... new Set([1,2,3,4,3,3,3,3])];const arr2 = Array.from(new Set([1,2,3,4,3,3,3,3])); 属性和方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//属性const s = new Set() s.constructor //指向 Set 函数 s.size //成员总数/** * 操作方法 *///也可以通过 add()方法添加 只有一个参数const set2 =new Set();set2.add(1) //Set(1) &#123;1&#125;//不会发生类型转换 NaN 会 = NaN set2.add("1") //Set(2) &#123;1,"1"&#125;set2.add(NaN).add(NaN)// Set(3) &#123;1,"1",NaN&#125; 链式调用//两个对象不相等set2.add(&#123;&#125;)set2.size //4set2.add(&#123;&#125;)set2.size //5//通过 delete() 删除某个值 返回 Boolean 值 set2.delete(1) //trueset2.delete(&#123;&#125;) //false //has() 是否存在某个值 set2.has(NaN) //trueset2.has(&#123;&#125;) // false//clear() 清除所有成员set2.clear() //Set(0) &#123;&#125;/** * 遍历方法 *//** * keys 返回键名的迭代器， values 返回 键值的迭代器， 由于 Set 键名和键值 相同 所以 * keys 和 values 方法返回值相同 */ const sK = new Set([1,2,3,4,5]).keys() //SetIterator &#123;1, 2, 3, 4, 5&#125; const sV= new Set([1,2,3,4,5]).values() //SetIterator &#123;1, 2, 3, 4, 5&#125; //enters 返回键值对 for (let item of new Set([1,2,3,4,5]).entries()) &#123; console.log(item);&#125;// [1, 1]// [2, 2]// [3, 3]// [4, 4]// [5, 5]//推荐使用for of const sI = new Set([1,2,3,4,5]);for (let key of sI) &#123; console.log(key); //1 2 3 4 5&#125;// Set的遍历顺序就是插入顺序。使用 Set 保存一个回调函数列表，调用时能保证按照添加顺序调用。//forEachsI.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 2 : 2// 3 : 3// 4 : 4// 5 : 5 weakSet 和Set 类似 但是只能存储对象，不可遍历如果其他对象未应用该对象，垃圾回收机制会自动收回所占用的内存适合存储临时对象和绑定对应对象的信息 12345678910const ws = new WeakSet([[1, 2], [3, 4]]); //WeakSet &#123;[1, 2], [3, 4]&#125;//a 的成员自动成为 weakSet 的成员//add 方法let arr =[[1]];ws.add(arr);//delete 删除对应成员ws.delete(arr); //true// has 是否包含ws.has(arr) //false 由于 WeakSet 的成员都是弱引用随时可能被回收，因此可以存储DOM节点，不用担心节点移除时，发生内存泄漏。 1234567891011const foo = new WeakSet() class Foo &#123; constructor()&#123; foo.add(this) &#125; method ()&#123; if(!foo.has (this))&#123; throw new TypeError("method 只能在Foo 实例上使用"); &#125; &#125; &#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[symbol]]></title>
    <url>%2F2019%2F03%2F15%2Fsymbol%2F</url>
    <content type="text"><![CDATA[含义 ES6 引入的原始数据类型，表示独一无二的值通过 Symbol函数生成的原始值，不是对象，所以无法添加属性和方法1234567891011121314151617let s = Symbol();let s1 = new Symbol('s'); //TypeError// 不能通过 new Symbol 否则会报错s.toString()//"Symbol()"let s2 = Symbol();s == s2 // false//独一无二的特性Boolean(s) //true!s // falses + s1 //error s + 1 //error s + "1" // error //symbol 不能参与任何值的运算 对象中的 symbol 无法通过 . 点运算访问123456let sm = Symbol()const s =&#123; [sm]: 1&#125;;s.sm //undefineds[sm]//1 消除魔术字符串 代码中多次出现，与代码形成强耦合的某一个具体的字符串或者数值。123456789101112131415161718192021222324252627282930313233function getDate(num,options)&#123; let data = 1; switch (num)&#123; case 1: data = num + 1; break case 2 : data = num * 2; break &#125; return data&#125;// case 右边的 1， 2 就是魔术数值//一般把魔术字符串 变成变量来消除let obj =&#123; one:Symbol(), two:Symbol()&#125;function getDate(num,options)&#123; let data = 1; switch (num)&#123; case obj.one: data = options + 2; break case obj.two : data = options * 2; break &#125; return data&#125;getDate(obj.one,3) 作为对象属性名 for...in、for...of，Object.keys() , Object.getOwnPropertyNames(),JSON.stringify()返回。 不是私有属性，可以通过 Object.getOwnPropertySymbols()获取指定symbol名123456789let a = Symbol('a');let b = Symbol('b');const obj = &#123; a:1, [a]:'hello', [b]:'word'&#125;console.log(Object.getOwnPropertySymbols(obj)) //(2) [Symbol(a), Symbol(b)] -可以通过 Reflect.ownKeys() 返回所有类型的属性名12345678let a = Symbol('a');let b = Symbol('b');const obj = &#123; a:1, [a]:'hello', [b]:'word'&#125;Reflect.ownKeys(obj) // ["a", Symbol(a), Symbol(b)] Symbol.for()与Symbol() Symbol(‘a’) 和 Symbol.for():两种方法都会生成新的 Symbol 值Symbol(‘a’) 使用10次，会生成10个新的 SymbolSymbol.for(‘a’)，使用10次，会生成一个 Symbol 并创建一个key值Symbol.keyFor(Symbol.for(‘a’)),会返回一个全局 key 值，可以在不同的iframe 或 service worker 获取同一个key 1234567let s = Symbol('a');let s1 = Symbol.for('s');let s2 = Symbol.for('s');s == s1 //falses1 == s2 //truelet key = Symbol.keyFor(s2) //s]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Async/await]]></title>
    <url>%2F2019%2F03%2F14%2FasyncEs8%2F</url>
    <content type="text"><![CDATA[ES2017引入async 函数 Generator 的语法糖 1234567891011121314151617181920212223242526272829//generatorconst fs = require('fs');const readFile = function (path) &#123; return new Promise(function (resolve,reject) &#123; fs.readFile(path, function(err,data) &#123; if (err) return reject(err); resolve(data); &#125;); &#125;);&#125;;const g = function* () &#123; const f1 = yield readFile(url1); const f2 = yield readFile(url2);&#125;// asyncconst asyncFile = async function () &#123; const f1 = await readFile(url1); const f2 = await readFile(url2);&#125;/** * 将 g 函数的 * 变成 axync * 将 yield 变成 await */ async 对 generator 进行以下优化 不再需要调用 next 方法就能执行 更加语义化 实用性更强 await 后面可以是 Promise , 原始类型值（会自动转成立即 resolved 的 Promise 对象） 返回值为Promise 对象更加方便，当函数执行遇到 await 时暂停执行，等到异步操作完成，再执行后面的代码 async 函数 return 的返回值会成为 then 方法的参数 async 函数内部抛出错误 将会被 catch方法接收 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// examplefunction timeout(ms) &#123; return new Promise(resolve =&gt; setTimeout(resolve,ms))&#125;async function asyncPrint(val, ms ) &#123; await timeout(ms); console.log(val)&#125;asyncPrint('Owen',1000) //1s 后 "Owen"//因为 asnyc 返回 Promise 所以可以改用 asyncasync function timout(ms) &#123; await new Promise(resolve =&gt; setTimeout(resolve,ms));&#125;async function asyncPrint(val, ms ) &#123; await timeout(ms); console.log(val)&#125;asyncPrint('Owen',1000) //1s 后 "Owen"/* 定义 async 函数 *///声明async function f()&#123;&#125;//表达式const fn = async function () &#123;&#125;;// 对象const obj = &#123; async f()&#123;&#125;&#125;// class class Storage &#123; async getAvatar(name) &#123; &#125;&#125;//箭头函数const foo = async () =&gt; &#123;&#125;;/* then方法接收return 的参数 */async function foo ()&#123; return "Owen"&#125;foo().then(re =&gt;console.log(re)); //Owen/* 接收错误对象 */async function fn ()&#123; throw new Error(18)&#125;fn().catch(er =&gt;console.log(er)) //error asyn回调只有等所有 await 后面的Promise 执行完毕或者报错和return才会执行。 123456789101112async function fn() &#123; var time = + new Date() console.log(time,1) let p1 = await new Promise(resolve =&gt; setTimeout(resolve,1000)); console.log(+ new Date() - time ,2) let p2 = await new Promise(resolve =&gt; setTimeout(resolve,2000)); return +new Date() - time;&#125;fn().then(time =&gt; console.log(time,3));// 1s 1// 2s 2// 3s 3 await await 后面是 thenable 对象，会和返回 promise 对象 一样返回结果 123456789101112131415161718class Sleep &#123; constructor(timeout) &#123; this.timeout = timeout; &#125; then(resolve, reject) &#123; const startTime = Date.now(); setTimeout( () =&gt; resolve(Date.now() - startTime), this.timeout ); &#125;&#125;(async () =&gt; &#123; const actualTime = await new Sleep(1000); console.log(actualTime);&#125;)(); 如果 await 后面的Promise 状态为 rejected 那么结果将会传递给 catch 方法；并且函数会中断执行,除非使用 try..catch 或者 对应的 Pomise 使用 catch方法 。 12345678910async function ay () &#123; await Promise.reject(18).catch((err) =&gt; &#123; console.log(err) &#125;) return "Owem"&#125;ay().then(res =&gt;console.log(res))//18//Owem 多个 await 后面的异步，如果不存在继发关系，最好同时触发 1234567891011async function fn() &#123; var time = + new Date() console.log(time,1) let [p1,p2] = await Promise.all([ new Promise(resolve =&gt; setTimeout(resolve,1000)), new Promise(resolve =&gt; setTimeout(resolve,2000))]); return +new Date() - time;&#125;fn().then(time =&gt; console.log(time,2)); 只能再 async 函数中使用 await 12345678async function ay () &#123; function ()&#123; await 1 &#125; return "Owem"&#125;ay() //error async 原理 将Generator 函数和执行器包装再一个函数中 1234567891011121314151617181920212223function autoactuator (gen) &#123; return new Promise((resolve,reject) =&gt; &#123; const g = gen(); let step = (next) =&gt; &#123; let n; try&#123; n = next(); &#125;catch(err) &#123; return reject(err) &#125; if(n.done)&#123; return resolve(n.value) &#125; Promise.resolve(next.value).ten((v) =&gt;&#123; step(() =&gt; g.next(v)); &#125;,function(e)&#123; setp(() =&gt; g.throw(e)); &#125;); &#125; step(() =&gt; g.next(undefined)); &#125;)&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pormise]]></title>
    <url>%2F2019%2F03%2F14%2Fpromise%2F</url>
    <content type="text"><![CDATA[Promise 为了解决 “回调地狱”（callback hell）而提出的写法允许将 callback 变成链式调用它是一个容器，保存着某个异步操作的结果。 特点 对象的状态部受外界影响；有三种状态， 进行中( pending ) 、 成功( fulfilled ) 、 失败( rejected );只有异步操作的结果可以决定那种状态。 状态一旦改变，就不会更改（resolved 定型），状态的改变只会是两种情况 pengding -&gt; fulfilled or pengding -&gt; rejected; 一旦建立就会立即执行 , 中途无法取消，无法得知事件进展，不设置callback，内部将会抛出错误 简单实列 使用 Promise 构造函数生成实例12345678910111213141516171819//exampleconst promise = new Promise(function (resolve,reject) &#123; //... do something $.get(url,function (data) &#123; if (data) &#123; resolve(data) &#125; &#125;).fail(function(err)&#123; reject(err) &#125;) &#125;);promise.then(function(data) &#123; console.log(data)&#125;,function(err)&#123; console.log(err)&#125;) 可见 Promise 接受一个callback 作为参数， callback有两个参数，都是函数 第一个 resolve 异步操作成功时调用，将成功的信息作为参数传递出去 第二个 rejcet 异步操作失败时调用，将失败的信息传递出去 then 方法生成实例后,可以使用 then 方法 接收成功状态和失败状态的回调,在当前脚本所有同步任务执行完才会执行 第一个参数是成功后的callback (必传) 第二个参数是失败后的callback (为可选参数) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108const promise = (time) =&gt; &#123; return new Promise((resolve,reject) =&gt; &#123; console.log("promise") setTimeout(resolve,time,'Owen') &#125;)&#125;promise(1000).then((val) =&gt; console.log(val)) //"promise" 1s后 "Owen"//加载图片function loadImage (url) &#123; return new Promise((resolve,reject) =&gt; &#123; const image = new Image(); image.onload = () =&gt; resolve(image); image.onerror = () =&gt; reject(new Error(`not lad image at: $&#123;url&#125;`)) image.src = url; &#125;)&#125;//实现原生ajax(get)const getJSON = function (url) &#123; return new Promise((resolve, reject) =&gt; &#123; const handler = function () &#123; if ( this.readySate !== 4 ) return; if (this.status === 200 ) &#123; resolve(this.response) &#125;else &#123; reject( new Error(this.statusText) ) &#125; &#125;; const client = new XMLHttpRequest(); client.open("GET",url); client.onreadystatechange = handler; client.setRequestHeader("Accept", "application/json"); client.send() &#125;);&#125;getJSON('url').then((res) =&gt; &#123;console.log(res)&#125;,err =&gt; console.error(err));//---console.log(1)const p1 = new Promise(function (resolve, reject) &#123;console.log(2) resolve();&#125;); console.log(3)const p2 = new Promise(function (resolve, reject) &#123; console.log(4) resolve(p1);&#125;)setTimeout( function () &#123; console.log(5)&#125;,0)window.requestAnimationFrame(function(v)&#123; // 回调函数执行次数通常是每秒60次 // 当requestAnimationFrame() 运行在后台标签页或者隐藏的&lt;iframe&gt; 里时， // requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。 //回调函数会被传入DOMHighResTimeStamp参数 （排队的回调开始触发的时间戳） console.log(8,v) //cancel​Animation​Frame(requestId) 取消 window.requestAnimationFrame&#125;)p2.then(function()&#123; console.log(7)&#125;)p1.then(function()&#123; console.log(6)&#125;)//p1的状态决定了p2的状态//1//2//3//4// 6// 7//&#123;&lt;resolved&gt;: undefined&#125;// 8// 5//向另一个 promise 传递 promise 执行状态问题const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123;reject(new Error('fail')); console.log(1)&#125;, 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt;&#123;console.log(2); resolve(p1) &#125;, 1000)&#125;)p2.then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error)) //error fail//传入的 promise 会改变 自己 promise 的状态，变成传入的promise的状态 catch 方法 指定发生错误时的回调函数。 12345678910111213141516171819202122232425262728293031323334p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err));//状态改变后不会再接收之后的状态const promise = new Promise(function(resolve, reject) &#123; resolve('ok'); reject( new Error('test'));&#125;);promise .then(function(value) &#123; console.log(value) &#125;) //ok .catch(function(error) &#123; console.log(error) &#125;);// promise 内部错误不会影响外部的代码，不会退出进程、终止脚本执行const promise = new Promise(function(resolve, reject) &#123; resolve(Owen); &#125;);promise.catch(function(error)&#123;console.log(error)&#125;).then(function(v)&#123;console.log('Owen:' + v)&#125;)console.log(18)//18//error//Owen:undefined //如果将 then 放到第一个将不会执行 //因为 then 接收的是 promise变量 的状态 //而放到末尾则接收的是 catch 返回的 Promise 函数的状态 finally不管 promise 的状态怎么变都会执行的方法 （ES2018) 12345678910111213141516//finally方法的回调函数不接受任何参数promise.finally(() =&gt; &#123; // 语句&#125;);// 等同于promise.then( result =&gt; &#123; // 语句 return result; &#125;, error =&gt; &#123; // 语句 throw error; &#125;); all 用于将多个 Promise 实例，包装成一个新 Promise 实例 参数是一个数组或者具有 Interator的接口（返回成员必须是promise)，如果成员不是 Promise 实例，会将其包装成一个porimse 实例 等待所以成员的状态都变成 resolved 状态， Promise.all 才变成 resolved 状态，并且成员返回值将以数组形式传递给 then 数组成员中只有又一位成员为rejectd 状态，Promise.all 就会变成 rejected , 并将第一个变为rejectd的成员返回值传递给 catch 如果成员自己定义了 then 或者 catch 对应成员的返回值不会传递到 all 的回调当中 123456789101112//exampleconst p1 = new Promise((resolve,reject) =&gt; setTimeout(resolve,1000,'Owen')) //.then(result =&gt;console.log(result)) // .catch(err =&gt;console.log(err));const p2 = new Promise(res =&gt; &#123; throw new Error('报错了');&#125;) .then(re =&gt; console.log(re)) .catch(err =&gt; console.log(err));//error const promise = Promise.all([p1,p2]) .then(res=&gt;console.log(res)) //1s 后 ["Owen",undefined] .catch(err =&gt; console.log(err)); race 和 all 方法一样 只是成员状态发生改变的情况不同 数组中只要有一个成员改变状态， race 就改变状态，并将返回值传递给 race方法 123456789101112//exampleconst p1 = new Promise((resolve,reject) =&gt; setTimeout(resolve,1000,'Owen')) //.then(result =&gt;console.log(result)) // .catch(err =&gt;console.log(err));const p2 = new Promise(res =&gt; &#123; throw new Error('报错了');&#125;) .then(re =&gt; console.log(re)) .catch(err =&gt; console.log(err));//error const promise = Promise.race([p1,p2]) .then(res=&gt;console.log(res)) //undefined .catch(err =&gt; console.log(err)); resolve 将对象转化为Promise对象123Promise.resolve('Owen')// 等同new Promise(resolve =&gt; resolve('Owen')) 传参情况 Promise实例 返回出入的实例 传入 thenable对象 具有 then方法的对象,将其转化为 Promise 对象 12345678910var obj = &#123; then: function(resolve,reject)&#123; resolve("Owen") &#125;&#125;var p = Promise.resolve(obj);p.then(function(res)&#123; console.log(res) //"Owen"&#125;) 不是对象或者没有 thenable方法 返回一个新的Promise，状态为 resolved1234const p = Promise.resolve(18);p.then(function(re)&#123; console.log(re) //18&#125;) reject 返回一个新的Promise，状态为 rejectd123456789101112131415const p = Promise.reject('出错了');// 等同 const p = new Promise((resolve, reject) =&gt; reject('出错了'))const thenable = &#123; then(resolve, reject) &#123; reject('出错了'); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable) //true&#125;) 结合 Generator 使用12345678910111213141516171819202122232425262728293031323334const g = function* () &#123; try &#123; const foo = yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function getFoo () &#123; return new Promise(function (resolve, reject)&#123; resolve('foo'); &#125;);&#125;function run (generator) &#123; const it = generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(g);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步操作原理（二）]]></title>
    <url>%2F2019%2F03%2F13%2FeventLoop%2F</url>
    <content type="text"><![CDATA[事件循环(eventLoop) 详解并行和并发： 并行性是指两个或多个事件在同一时刻发生；并发性是指两个或多个事件在同一时间段内发生。 任务队列 和 事件循环 JS 将变量存储在 堆 heap 和 栈 stack中堆中存放对象比如 ：数组，对象，函数栈中存放变量和对象的指针运行时同步任务会排好队，依次执行，而排队的地方就叫执行栈（先进后出） JS运行时，除了有一个主线程运行，引擎还提供任务队列 task queue , 里面是各种需要当前程序处理的异步任务。（不止一个任务队列） 异步任务通常是一个回调函数；如果一个异步任务没有回调函数，是不会放入异步任务队列中，同样也不会进入主线程中执行。 执行过程： 主线程会先执行完所有同步任务 同步任务结束，查看任务队列（先进先出的数据结构，排在前面的事件，优先被主线程读取。）里面的异步任务 查看所有满足执行条件的异步任务，放入主线程中变成同步任务，执行对应的回调函数。 执行完毕再将下一个满足执行条件的异步任务放入主线程中执行。 不断重复前三步操作 只要同步任务执行完毕，JS引擎会不停的监测检查任务队列中的异步任务，将满足执行条件且最先进入的任务加入到执行栈中去执行，如此往复。这种检查机制就叫事件循环 Event Loop 微任务与宏任务异步任务还会分两层： 微任务(micro task) 宏任务(macro task) 主线程会先查看微任务 micro task；如果没有满足条件的任务，再去宏任务中查找；如果有则将所有满足条件的微任务按顺序依次加入到主进程中；执行完毕后再去红任务队列中查找，往复循环。常见宏任务： 定时器 I/O（输入/输出）操作 微任务(jobs)： Promise async/awaitnodeJSnodeJS 中任务队列 加入了 process.nextTick 和 setImmediate。前者比后者先执行123456789101112131415161718192021process.nextTick(function A() &#123; console.log(1); process.nextTick(function B()&#123;console.log(2);&#125;);&#125;);setImmediate(function ()&#123; setImmediate(function A() &#123; console.log(3); setImmediate(function B()&#123;console.log(4);&#125;); &#125;); setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED'); &#125;, 0);&#125;);// 1// 2// 3// TIMEOUT FIRED// 4//这个结果是不确定的可能是 1234 TIMEOUT FIRED || 12 TIMEOUT FIRED 34 其二者的调用顺序取决于当前event loop的上下文，如果他们在异步i／o callback之外调用，其执行先后顺序是不确定的。123456789101112var fs = require('fs')fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout') &#125;, 0) setImmediate(() =&gt; &#123; console.log('immediate') &#125;)&#125;)//immediate//timeout 这是因为fs.readFile callback执行完后，程序设定了timer 和 setImmediate，因此poll阶段不会被阻塞进而进入check阶段先执行setImmediate，后进入timer阶段执行setTimeout。setTimeout和setImmediate的差异 process.nextTick在最新版nodejs中不被推荐使用，推荐使用setImmediate ，原因在于nextTick是在当前帧介绍后立即执行，会阻断I/O并且有最大数量限制；而setImmediate不会阻断I/O，更像是setTimeout(func, 0)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步操作原理(一)]]></title>
    <url>%2F2019%2F03%2F11%2Fasync%2F</url>
    <content type="text"><![CDATA[单线程 javascript 只再一个线程上运行，同时只能执行一个任务，一行一行执行。 javascript 运行在单线程上，并不代表 JavaScript引擎就是单线程的，其实它有多个线程，单个脚本只能在一个线程上运行（主线程），其他线程在后台配合运行。 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 这种模式好处在于， 实现起来简单，环境单纯。 但是 耗时较长，后面的任务必须等待前面的任务执行完毕。 同步和异步任务 同步未被引擎挂起、在主线程上排队执行的任务。需要前面的任务执行完后才能执行。 异步 被引擎挂起，暂不处理的任务,不进入主线程、而进入任务队列; 只有达到某个条件，异步任务才会进入主线程，不会堵塞异步任务后面的代码 （ajax 是最具代表性的异步任务） 异步操作模式回调函数 Callback 将函数传递进一个方法中，函数不会立即执行，等待出来结果之后在执行。回调函数是异步操作最基本的方法 容易出现回调地狱（Callback hell)比如多个 ajax 嵌套请求123456789ajax(url, () =&gt; &#123; // 处理逻辑 ajax(url1, () =&gt; &#123; // 处理逻辑 ajax(url2, () =&gt; &#123; // 处理逻辑 &#125;) &#125;)&#125;) 这种方式容易理解和简单，但是不利于维护和阅读；耦合度高，结构混乱，错误较难追踪，而且每个任务只能指定一个回调。 事件监听 采用事件驱动。W3C规范中定义3个事件阶段：捕获(Netscape)，目标，冒泡（IE）。事件冒泡：在目标元素上发生click事件的顺序 目标元素 -&gt; 父级元素 -&gt; body -&gt; html -&gt; document事件捕获： 与冒泡相反，document -&gt; html -&gt; body -&gt; 父级元素 -&gt; 目标元素 123456789101112131415161718// 原生事件委托 var parent = document.getElementById('parent'); parent.addEventListener('click',showColor,false); function showColor(e)&#123; var son = e.target; if(son.nodeName.toLowerCase() === 'li')&#123; console.log('The color is ' + son.innerHTML); &#125; &#125; //类似 jQuery写法 fn.on('click',function()&#123;&#125;); //等同于 function fn ()&#123; setTimeout(function()&#123; //do someing fn.trigger('done') &#125;,1000) &#125; 这种方法比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，可以去“耦合”(decoupling),便于实现模块化。 但是整个程序都会变成事件驱动，流程不清晰。 发布/订阅 消息的发送者（称为发布者） 不会将消息直接发送给特定的接收者（称为订阅者），而是将不消息分为不同的类别，不需要了解哪些订阅者；订阅者,只接收感兴趣的消息，不需要了解哪些发布者可以把事件理解成“信号”,如果存在一个“信号中心”； 某个任务执行完成，就向信号中心“发布” (publish) 一个信号，其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己开始执行 1234567891011121314var obj = $(&#123;&#125;);obj.on("aaa", function () &#123; console.log(111111111111); &#125;)obj.on("aaa", function () &#123; console.log(222222222222); &#125;)$(dom).click(function() &#123; obj.trigger("aaa"); &#125;); 当 foo 执行完毕后，想消息纵向发布 done信号，引发执行fn 消息过滤订阅者通常接收信号中心中(消息代理)的一个子集，选择接受和处理的消息过程叫过滤过滤形式 基于主题 消息被发布到主题或命名通道上；订阅者将受到所有信息，并且所有订阅同一主题的订阅者都将收到同样的信息；发布者赋值定义订阅者所订阅的消息类别 基于内容 订阅者定义感兴趣的条件，只有当消息的属性或内容满足订阅者的条件，消息才投递到该订阅者。订阅者负责堆消息分类。 拓扑发布者 发布消息到一个消息代理，订阅者向其注册订阅，由消息代理来过滤 优缺点： 松耦合，发布者和订阅者只需要关注主题内容，相互独立地运行。 扩展性强，通过并行操作，消息缓存，基于树或网路路由等技术，比传统客户端具有更好的扩展性。 缺点： 发布者解耦订阅者，问题难以跟踪，无法知道消息传送是成功的还是失败的 异步操作的流程控制（多个异步操作如何确定异步操作的执行顺序，如何保证这种顺序执行）串行执行 一个任务执行完毕后，再执行另一个 123456789101112131415161718 let arr = [1,2,3,4,5]; let results = [];const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res);const series = item =&gt;&#123; if(item)&#123; async(item,result=&gt;&#123; results.push(result); return serise(items.shift();) &#125;) &#125;else&#123; return final(results[results.length-1]); &#125;&#125;series(items.shift()); 上面代码 series 就是一个串行函数； 类似与同步任务 并行执行 所有异步任务同时执行，全部执行完毕，再执行 最终 (final) 函数 12345678910111213141516 let arr = [1,2,3,4,5]; let results = [];const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res); for (let item of items)&#123; async(item,(result) =&gt;&#123; results.push(result) &#125;) if(results.length == items.length)&#123; final(results[results.length-1]); &#125; &#125; 上面代码，for 循环会同时执行5异步任务，等他们执行完毕再执行 final 函数。 过个并行任务较多，容易耗尽系统资源，拖慢运行 并串结合 限制并行执行任务的数量，避免占用过多系统资源 1234567891011121314151617181920let items = [1,2,3,4,5];let results = [];let running = 0,limit = 2;const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res);const launcher = () =&gt; &#123; while (running &lt; limit &amp;&amp; items.length&gt;0)&#123; let item = items.shift()； async (item,(res)=&gt;&#123; results.push(result); running--; items.length? launcher(): final(results); &#125;) running++ &#125;&#125; 上面代码，最多只能运行两个异步任务，当前 running 记录运行的任务数量，低于门槛 limit 就会新增一个任务，直到任务执行完毕。 轮询12345678let hash = window.location.hash;const hashWatcher = () =&gt;&#123; if(window.location.hash != hash)&#123; updatePage() &#125;&#125;setInterval(hashWatcher,1000) setInterval 时间 间隔是” 开始执行 “ 之间的间隔,不会考虑每次执行的任务时间，所以两次执行间隔会小于指定时间。比如 指定 100ms 任务本身消耗 105 ms，那么第一次执行完毕后，第二次会立即执行。 如果要固定间隔，可以使用 setTimeout12345678let hash = window.location.hash;const hashWatcher = () =&gt;&#123; if(window.location.hash != hash)&#123; updatePage() &#125; setTimeout(hashWatcher,1000)&#125;setTimeout(hashWatcher,1000) 注意： HTML标准规定 setTimeout 最大间隔 4ms 由于定时器每执行一次,会返回一个整数，连续执行，返回值比上一次大1 123456789101112131415161718 (function() &#123; // 每轮事件循环检查一次 var gid = setInterval(clearAllTimeouts, 1000); function clearAllTimeouts() &#123; var id = setTimeout(function() &#123; console.log("g:"+gid) &#125;,0); while (id &gt; 0) &#123; if (id !== gid) &#123; clearTimeout(id); &#125; id--; &#125; &#125;&#125;)(); 防抖（debounce） 在某些场景下不希望事件执行太频繁，我们可以设置一个阀门临界值，再一段时间内只执行一次,或者一段时间过后执完所有任务 123456789101112131415161718192021222324252627282930//一段时间只执行一次let perform = (fn,time) =&gt; &#123; let flag = true; return function () &#123; let self = this,arg = arguments; if(flag)&#123; flag = false; fn.apply(self,arg); setTimeout(() =&gt; &#123; flag = true &#125;,time) &#125; &#125;&#125;let fn = () =&gt; console.log(1);setInterval(perform(fn,2000),500); // 经过一段时间再执行所有要执行的任务 let debounce = (fn,delay) =&gt;&#123; let timer = null; return function ()&#123; let self = this,arg = arguments; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(self,arg) &#125;,delay) &#125; &#125;setInterval(perform(fn,2500),500); 参考原文链接： http://wangdoc.com]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发(二)]]></title>
    <url>%2F2019%2F03%2F07%2Fmodularization%2F</url>
    <content type="text"><![CDATA[什么是模块化 将一组模块（及其依赖项）以正确的顺序拼接到一个文件（或一组文件）中的过程。 ES6 详解 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。 顶层的this指向undefined，即不应该在顶层代码使用this。 严格模式主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface）上面这些限制，模块都必须遵守。 export命令 export除了输出变量，还可以输出函数或类（class）,还可以通过 as 更改输出名。 12345678let age = 18;let obj =&#123;name: "Owen"&#125;;let multiply = (x, y) =&gt; x * y;export &#123; age, obj as monicker, //改变量名 multiply&#125; 导出的对象必须是对外的接口 1234let num =2;export num ; //error 因为实际输出的是一个值，须放在对象中 &#123;num&#125;exprot 2 //error 输出的是值 而不是一个对外接口 =&gt; 须改成 export let num =2； 不能放到局部作用域中导出， 因为导出的对象是动态绑定的12let foo = (r) =&gt; r++;let fn = () =&gt; export default foo; //error export default 全局只能有一个 export default export default 后面不能有 变量声明的关键字 使用 export default ，import 就不需要使用 {},只需要自定义一个变量即可 123456export default var a=1; //errorexport default obj =&#123;name:'Owen'&#125;;//orlet num = 1;let obj1 = &#123;name:"Owen"&#125;;export default &#123;num, obj1&#125; import 配合 from 导入模块, 通过 as 修改导入接口, 接口不能重新赋值，但对象可以修改内部属性或方法。 12345import &#123;age, monicker as obj, multiply&#125; from './preson.js'; age = 0 ; //error obj.feature = "handsome Owen"; console.log(age, obj。name, multiply(1,2)) import * as preson from "./preson.js" //引入所有接口 import 具有提升的效果，会提升到作用域顶部执行，同一个模块多次引入只执行一次，并且不能再局部作用域中引入。 12345678multiply(2,2); //4import &#123;age, monicker as obj, multiply&#125; from './preson.js';if (true)&#123;import &#123;age, monicker as obj, multiply&#125; from './preson.js'; //error&#125; import() 因为require是运行时加载模块，import命令无法取代require的动态加载功能。因此，有一个提案，引入import()函数，完成动态加载。 import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。 和 require类似，不同之处在于 import()是同步加载 require()是异步加载 1const path =import('path'); 我们可以利用 import() 进行按需加载,动态加载，按条件加载: 12345678910import('./a.js') .then(r =&gt; &#123; r.fn(); &#125;) .catch(error =&gt; &#123; /* Error handling */ &#125;)if( x == 1)&#123; const path =import('path');&#125; 如果想同时加载多个模块，可以采用下面的写法 123456789 Promise.all([ import('./a.js'), import('./b.js'), import('./c.js'),]) .then(([a,b,c]) =&gt; &#123; // ... &#125;).catch(error =&gt; &#123; /* Error handling */ &#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>moduleDevelop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 升级 webpack4 配置]]></title>
    <url>%2F2019%2F03%2F07%2Fwebpack%2F</url>
    <content type="text"><![CDATA[升级webpack4 先删除之前的webpack1npm i -D webpack webpack-cli webpack-dev-server build/base.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119const os = require('os') //node OS模块 可查看主机系统相关信息const path = require('path') //node path模块 c处理文件路径const utils = require('./utils') //vue-cli封装的公用模块const webpack = require('webpack')const config = require('../config')//vue-cli封装的配置const HappyPack = require("happypack")//开启多个子进程去并发执行const HtmlWebpackPlugin = require('html-webpack-plugin')//webpack主要插件，可以简化HTML文件的创建const CleanWebpackPlugin = require('clean-webpack-plugin');//清空打包好的文件const ProgressBarPlugin = require('progress-bar-webpack-plugin')//查看进度const vueLoaderConfig = require('./vue-loader.conf')// 处理less,sass等样式配置文件 const VueLoaderPlugin = require('vue-loader/lib/plugin');const argv = require("yargs-parser")(process.argv.slice(2))//获取运行 scripts 里面的指令 --mode 后面参数 const isPro = argv.mode == "production"const resolve = dir =&gt; path.resolve(__dirname, "..", dir)module.exports = &#123; context: path.resolve(__dirname, '../'), entry: &#123; app: "./src/main.js" &#125;, output: &#123; path: config.build.assetsRoot, filename: '[name].js', publicPath: isPro ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue': 'vue/dist/vue.esm.js', 'src': path.resolve(__dirname, '../src/common'), '@': resolve('src'), '~': resolve('src/components/common'), 'static': path.resolve(__dirname, '../static'), &#125; &#125;, module: &#123; rules: [&#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loaders: 'happypack/loader?id=babel',//配合 happypack插件使用 exclude: /(node_modules|bower_components)/, include: [resolve('src'), resolve('test')] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;, node: &#123; setImmediate: false, dgram: 'empty', fs: 'empty', net: 'empty', tls: 'empty', child_process: 'empty' &#125;, plugins: [ new ProgressBarPlugin(), new CleanWebpackPlugin(), new HappyPack(&#123; id: 'babel', loaders: [&#123; loader: 'babel-loader', options: &#123; babelrc: true, cacheDirectory: true, &#125;, publicPath: "/" &#125;], //共享进程池 threadPool: HappyPack.ThreadPool(&#123; size: os.cpus().length //cpu nunbers &#125;), //允许 HappyPack 输出日志 verbose: true, &#125;), new webpack.DefinePlugin(&#123; 'process.env': &#123; 'NODE_ENV': JSON.stringify(argv.mode) &#125; &#125;), new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true, favicon: './src/assets/img/favicon.ico' &#125;), new webpack.ProvidePlugin(&#123;//引入全局变量 $: 'jquery', jQuery: 'jquery', // 加上这个 &#125;), new VueLoaderPlugin() ]&#125; build/dev.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566'use strict'const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')//可以合并 base.conf 配置文件const baseWebpackConfig = require('./webpack.base.conf')const HtmlWebpackPlugin = require('html-webpack-plugin')const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')//让日志更加友好const portfinder = require('portfinder') //查找开放端口或域接字的简单工具 const HOST = process.env.HOSTconst PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)const devWebpackConfig = merge(baseWebpackConfig, &#123; mode:'development', module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, devtool: config.dev.devtool, devServer: &#123; clientLogLevel: 'warning', historyApiFallback: true, hot: true, compress: true, host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll, &#125;, disableHostCheck: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125;)module.exports = new Promise((resolve, reject) =&gt; &#123; portfinder.basePort = process.env.PORT || config.dev.port portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; process.env.PORT = port devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`], &#125;, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) pluguin1npm i -D happypack html-webpack-plugin clean-webpack-plugin progress-bar-webpack-plugin yargs-parser friendly-errors-webpack-plugin portfinder webpack-merge extract-text-webpack-plugin@next optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin chalk rimraf babel-loader1npm i babel-loader @babel/cli @babel/core @babel/ @babel/preset-env plugin-proposal-class-properties @babel/ plugin-proposal-decorators @babel/ plugin-syntax-dynamic-import @babel/plugin-transform-classes @babel/plugin-transform-runtime -D 1npm i --save @babel/runtime @babel/runtime-corejs2 .babelrc123456789101112131415161718&#123; "presets": [ ["@babel/preset-env", &#123; "useBuiltIns": "usage" &#125;] ], "plugins": [ ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;], "@babel/proposal-class-properties", ["@babel/plugin-transform-runtime", &#123; "corejs": 2 &#125;], "@babel/plugin-syntax-dynamic-import", "@babel/plugin-transform-classes" ]&#125; build/prod.conf.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394'use strict'const path = require('path')const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const CopyWebpackPlugin = require('copy-webpack-plugin')//复制文件和目录const HtmlWebpackPlugin = require('html-webpack-plugin')const ExtractTextPlugin = require('extract-text-webpack-plugin')//提取样式文件，只有extract-text-webpack-plugin@^4.0.0-beta.0 才支持webpack4 //或者使用 mini-css-extract-plugin 用法详见 ![GitHub](https://github.com/search?q=mini-css-extract-plugin)const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin') //用于优化\最小化 CSSconst UglifyJsPlugin = require('uglifyjs-webpack-plugin') // 压缩JS资源const webpackConfig = merge(baseWebpackConfig, &#123; mode: 'production', module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true, usePostCSS: true &#125;) &#125;, devtool: config.build.productionSourceMap ? config.build.devtool : false, output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[chunkhash].js'), chunkFilename: utils.assetsPath('js/[id].[chunkhash].js') &#125;, optimization: &#123; splitChunks: &#123; chunks: 'all', // initial、async和all minSize: 30000, // 形成一个新代码块最小的体积 maxAsyncRequests: 5, // 按需加载时候最大的并行请求数 maxInitialRequests: 3, // 最大初始化请求数 automaticNameDelimiter: '~', // 打包分割符 name: true &#125;, minimizer: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true &#125;), // extract css into its own file new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[hash].css'), allChunks: true, &#125;), new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), new HtmlWebpackPlugin(&#123; filename: config.build.index, template: 'index.html', inject: true, favicon: './src/assets/img/favicon.ico', minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, chunksSortMode: 'dependency' &#125;), new webpack.optimize.ModuleConcatenationPlugin(), new CopyWebpackPlugin([&#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125;]) ] &#125;&#125;)module.exports = webpackConfig build.js123456789101112131415161718192021222324252627282930313233343536'use strict'require('./check-versions')()process.env.NODE_ENV = 'production'const rm = require('rimraf')//删除文件const path = require('path')const chalk = require('chalk')//终端字符串样式const webpack = require('webpack')const config = require('../config')const webpackConfig = require('./webpack.prod.conf')rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; if (err) throw err webpack(webpackConfig, (err, stats) =&gt; &#123; if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, chunks: false, chunkModules: false &#125;) + '\n\n') if (stats.hasErrors()) &#123; console.log(chalk.red(' 构建失败，错误.\n')) process.exit(1) &#125; console.log(chalk.cyan(' Build success.\n')) console.log(chalk.yellow( ' 打包文件应该通过HTTP服务器启用.\n' )) &#125;)&#125;)]]></content>
      <categories>
        <category>package</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发(一)]]></title>
    <url>%2F2019%2F03%2F07%2Fmodule%2F</url>
    <content type="text"><![CDATA[传统的模块化做法。 模块是实现特定功能的一组属性和方法的封装。 将模块写成一个对象，所有的模块成员都放到这个对象里面。1234567var module1 = new Object(&#123; _count:0, f1:function()&#123;&#125;, f2:function()&#123;&#125;&#125;)module1.f1()module1.f2() 上面的对象可以改变里面的属性和方法，不安全 123456789var module1 = （function()&#123; var count=0; return &#123; f1:function()&#123;&#125;, f2:function()&#123;&#125;&#125;&#125;());module1.f1()module1.f2()module1.count //undefined 使用立即执行函数 将相应的方法和属性封装在函数中,这样就不会暴露私有成员 利用构造函数封装对象12345678910111213function Father ()&#123; var arr =[]; this.add = function (val)&#123; arr.push(val) &#125; this.toString = function()&#123; return arr.join(''); &#125;&#125;var a = new Father();a.add(1);//[1]a.toString();//"1"a.arr // undefined 上面的函数将 arr 变成私有变量，在函数外部无法访问，但是形成了闭包，非常耗费内存；违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。12345678910111213function ToString() &#123; this._buffer = [];&#125;ToString.prototype = &#123; constructor: ToString, add: function (str) &#123; this._buffer.push(str); &#125;, toString: function () &#123; return this._buffer.join(''); &#125;&#125;; 虽然上面的构造函数未生成闭包，但是外部可以修改方法和属性，不安全 放大模式如果一个模块很大或者一个模块需要继承另一个模块可以利用立即执行函数的特效来封装123456var module1 = (function(m1)&#123;mod1.col=function()&#123; console.log(this)&#125;;return mod1;&#125;(window.modlue2 ||&#123;&#125;)) //有些模块可能是null 确保函数正常执行 采用兼容模式 window.modlue2 ||&#123;&#125; 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。123var module1 = (function ($, Swiper) &#123; //...&#125;(jQuery, Swiper)); 上面的 module1 引入 jQuery 和 Swiper 当做两个参数传入模块中，保证了模块的独立性，还使得模块之间的依赖关系变得明显。 立即执行函数还可以起到命名空间的作用。123456789101112131415161718192021(function($, window, document) &#123; function go(num) &#123; &#125; function handleEvents() &#123; &#125; function initialize() &#123; &#125; function dieCarouselDie() &#123; &#125; //attach to the global scope window.finalCarousel = &#123; init : initialize, destroy : dieCarouselDie &#125;&#125;( jQuery, window, document )); 以上都有一个共同点:使用单个全局变量箭头代码包装在函数中，使用闭包建立私有空间但是都有缺点： 不知道模块(库) 的加载顺序 还是有可能引起命名冲突，比如两个库都有相同的名称，或者使用哪个版本有几种良好实施的方法：CommonJS、AMD和CMD。可以解决以上的缺陷 CommonJS CommonJS 是一种思想, 本质上是可复用的JavaScript,它导出特定的对象，提供其它程序使用。 由于 JavaScript 没有模块系统、标准库较少、缺乏包管理工具,因此CommonJS是为它的表现来制定规范。 每个JavaScript 文件 都将模块存储在自己独有的作用域中。 需要使用 module.exports 和 exports.obj 来导出对象，并在需要它的程序中使用 require(&#39;module&#39;) 加载 1234567891011121314151617181920 //文件1 function myModule() &#123; this.hello = function() &#123; return 'hello!'; &#125; this.goodbye = function() &#123; return 'goodbye!'; &#125;&#125;module.exports = myModule; //文件2 var myModule = require('myModule');var myModuleInstance = new myModule();myModuleInstance.hello(); // 'hello!'myModuleInstance.goodbye(); // 'goodbye!' 实现原理 123456789101112var module1 = &#123; export1:&#123;&#125;&#125;;(function (module,exports)&#123; exports.add = functon(val)&#123; return val *10 &#125;&#125;(module1,module1.export1));var fn = module1.export1.add;fn(2)//20 利用立即执行函数 接受两个参数 module 和 exports， 模块就通过立即执行函数赋值，然后导出模块，即可实现模块的加载这种方法的好处： 避免全局污染 明确依赖项目 语法清晰缺点： 由于 CommonJS 采用服务器优先方法并且同步加载模块，因此在浏览器中使用它会阻止浏览器运行其他内容，直到加载完成。 我们可以使用 AMD 来异步加载 AMD(Asynchromous Module Definition) 定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。 AMD模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 定义了一个函数 define，通过 define 方法定义模块。 1234 define(['myModule', 'myOtherModule'], function(myModule, myOtherModule) &#123; console.log(myModule.hello());&#125;); 上面的 define 函数将每个模块的依赖项，以数组的形式作为参数。 这些依赖项会在后台异步加载，一旦加载完成，define 函数就调用模块给出的回调函数myModule 可能像下面一样定义： 1234567891011 define([], function() &#123; return &#123; hello: function() &#123; console.log('hello'); &#125;, goodbye: function() &#123; console.log('goodbye'); &#125; &#125;;&#125;); CMD(Common Module Definition) CMD由玉伯大佬提出并用于SeaJS CMD 和 AMD 很相似，都有 define 函数， 通过 require 加载 CMD和AMD 不同点： 对于依赖的模块 CMD 延迟执行， AMD 提前执行(requireJS 高版本也开始延迟执行) CMD使用依赖就近原则（按需加载）： 12345678910111213141516 define(function(require, exports, module) &#123; var near = require('./a') near.doSomething() // 此处略去 100 行 var nearOne = require('./b') // 依赖可以就近书写 nearOne.doSomething() // ... &#125;) ``` - AMD使用依赖前置原则（必须先加载完依赖）： ```javascript define(['./a', './b'], function(nearTow, nearThree) &#123; // 必须一开始加载 nearTow.doSomething() // 此处略去 100 行 nearThree.doSomething() ... &#125;) CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。 AMD 和 CommonJS 不同点：AMD： 采用浏览器优先的方法，异步加载，主要用于浏览器 先加载依赖项 依赖项可以说 对象、函数、构造函数、字符串等等其他JS类型 CommonJS: 采用服务器优先的方法，同步加载，主要用于服务器 支持对象作为模块共同点： 先加载依赖项 通用模块定义 UMD 同时支持 AMD和 CommonJS本质 创建了一种方法来使用两者的任何一种，同时支持全局变量定义，(JS兼容性的常用思想)所以 UMD 可以在客户端和服务器上工作1234567891011121314151617181920(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['myModule', 'myOtherModule'], factory); &#125; else if (typeof exports === 'object') &#123; // CommonJS module.exports = factory(require('myModule'), require('myOtherModule')); &#125; else &#123; root.returnExports = factory(root.myModule, root.myOtherModule); &#125;&#125;(this, function (myModule, myOtherModule) &#123; function notHelloOrGoodbye()&#123;&#125;; function hello()&#123;&#125;; function goodbye()&#123;&#125;; return &#123; hello: hello, goodbye: goodbye &#125;&#125;)); ES6模块（即 ES2015/ECMAScript 6、ES6） 使用 import 关键字引入模块，通过 export 关键字导出模块 ES6目前无法在浏览器中执行,只能通过babel将不被支持的import编译为当前受到广泛支持的 require。 12345678910111213141516171819//a.jsexport let cun =1; export function add() &#123; cun++;&#125;//----------------import &#123; cun, add &#125; from './a.js';console.log(cun); // 1incCounter();console.log(cun); // 2export var fo ='a';setTimeout(() =&gt; fo ='b',500);import &#123;fo&#125; from './a.js';console.log(fo);//'a'setTimeout(()=&gt; console.log(fo),500)//'b'//ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。fo = 's' //error ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。CommonJS、AMD和CMD相比: ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 ES6 对外接口只是一种静态定义，在代码静态解析阶段就会生成。 ES6 module编译时输出接口(加载)，输出的是值的引用。(静态编译) CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。 CommonJS 模块运行时加载，输出的是一个值的拷贝。(动态编译)一旦输出一个值，模块内部的变化就影响不到这个值。12345678910111213141516171819202122232425// lib/counter.jsvar counter = 1;function increment() &#123; counter++;&#125;function decrement() &#123; counter--;&#125;module.exports = &#123; counter: counter, increment: increment, decrement: decrement&#125;;// src/main.jsvar counter = require('../../lib/counter');counter.increment();console.log(counter.counter); // 1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>moduleDevelop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(三)]]></title>
    <url>%2F2019%2F03%2F05%2Foop3%2F</url>
    <content type="text"><![CDATA[对象继承A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。 JavaScript 语言的继承不通过 class，而是通过“原型对象”prototype实现 传统原型链式继承 过多的继承属性 比如一个函数用不到某个原型方法或属性，那么方法或属性就过剩了123456789101112function Grand()&#123;&#125;;Grand.prototype.name="grand";let grand = new Grand();Father.prototype=grand;function Father()&#123;&#125;let father = new Father();Son.prototype=father;function Son()&#123;&#125;let son = new Son(); 借用构造函数 使用call/appply 不是真正继承，因为不能调用原型上的方法，而且每调用一次都会调用多次函数，实际上步骤没有变少 工业级推荐使用 缺点无法添加私有原型 123456789101112 function Father() &#123; &#125;function Son() &#123; Father.call(this); // 调用父类构造函数&#125;Son.prototype.print = function() &#123; Father.prototype.print.call(this);//只使用单个方法&#125;// 子类继承父类的原型Son.prototype = Object.create(Father.prototype);Son.prototype.constructor = Son; 共有原型1234567891011Father.prototype =&#123; name:"common"&#125;function Father()&#123;&#125;Son.prototype = Object.create(Father.prototype)function Son()&#123;&#125;function inherit (Target,Origin)&#123;//继承源 Target.prototype = Origin.prototype;&#125; 圣杯模式 隐式附加的东西就私有化，可以公共定义的东西提取出来公有化1234567891011let inherit =(function()&#123; let Interim =function Interim() &#123;&#125;; return function (Target,Origin)&#123;//继承源 Interim.prototype =Object.create(Origin); Target.prototype = Interim.prototype; //现在 可以 制定自己的私有属性，但是 constuctor 不是 原函数所一手动赋值回来，如果想要知道函数真正继承那个原型需要保存它 Target.prototype.constuctor = Target; Target.prototype.yliluokka =Origin; &#125; &#125;()) 多重继承JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过Object.assign，实现这个功能。这种模式称之为 Mixin (混入)123456789101112function Fn1()&#123; &#125;function Fn2()&#123; &#125;function Son()&#123; F1.call(this); F2.call(this); &#125;//继承F1Son.prototype =Object.create(Fn1.prototype);//继承F2Object.assign(Son.prototype,Fn2.prototype);Son.prototype.constructor =Son;let a =new Son(); call，apply and bind 都可改变函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 call and apply1234567function test() &#123;&#125; //test() == test.call()let obj =&#123;&#125;;Object.prototype.toString.call(obj) //"[object Object]"//因为call 和 apply 会将函数中的this指向第一个参数//相当于 obj.toString() call and apply 二者区别在于传参： call 第二个参数开始单个单个参数传 apply 第二个参数为数组或类数组123456//返回数组中最大的数let a = [1, 2, 4, 1, 15];Math.max.apply(null, a) // 15//将数组的空元素变为undefinedArray.apply(null [1,,3,,4)//[1,undefined,3,undefined,4]; 空元素与undefined的差别 forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 转换类似数组的对象 12let obj=&#123;0: 1, length: 2&#125;Array.protetype.slice.apply(obj);//[1,undefined] 被处理的对象必须有length属性，以及相对应的数字键。 参数为空、null和undefined，则默认传入全局对象。 bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 1234567891011121314151617181920212223let counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;let func = counter.inc.bind(counter);func();counter.count // 1let add = function (x, y) &#123; return x * this.m + y * this.n;&#125;let obj = &#123; m: 2, n: 2&#125;;let newAdd = add.bind(obj, 5); //将x 绑定为 5 newAdd(5) // 20newAdd(1,5)//12 第一个参数是null或undefined，等于将this绑定到全局对象 bind方法使用注意点 bind方法每运行一次，就返回一个新函数 需要一个变量接收 结合回调函数使用 1234567891011121314let counter = &#123; count: 0, inc: function () &#123; 'use strict'; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 结合call方法使用 1234567891011121314151617181920[1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1]//将Array.prototype.slice变成Function.prototype.call方法所在的对象//调用时就变成了Array.prototype.slice.call。let slice = Function.prototype.call.bind(Array.prototype.slice);Function.prototype.slice.call([1, 2, 3], 0, 1) // [1]//slice([1, 2, 3], 0, 1) let push = Function.prototype.call.bind(Array.prototype.push);let pop = Function.prototype.call.bind(Array.prototype.pop);let a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 将Function.prototype.bind方法变成Function.prototype.call的方法，就意味着bind的调用形式也可以被改写 1234567function f() &#123; console.log(this.v);&#125;let o = &#123; v: 123 &#125;;let bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123 Object 系统默认方法 getPrototypeOf 获取对象原型,只有一个参数 12345678910function Foo ()&#123;&#125;let obj = new Foo ();Object.getPrototypeOf(obj) // Foo.prototype//空对象原型 Object.getPrototypeOf(&#123;&#125;) // Object.prototype// Object.prototype 原型 Object.getPrototypeOf(Object.prototype) //null// FooObject.getPrototypeOf(Foo) // Function.prototype setPrototypeOf 设置对象原型有两个参数： 现有对象 继承的原型对象12345let now = &#123;&#125;;let pro = &#123;name:"Owen"&#125;;Object.setPrototypeOf(now,pro);now.name //"Owen" Object.create() 生成实例对象的常用方法 参数必须为对象 或 null 参数为 null 会生成一个不会继承任何属性和方法的对象12345678910111213141516171819202122232425262728293031let obj = Object.create(null);obj.toString()// Error //会继承第二个参数的属性和方法let obj = Object.create(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true, configurable: true, writable: true, &#125;, p2: &#123; value: 'Owen', enumerable: true, configurable: true, writable: true, &#125; &#125;);// 等同于let obj = Object.create(&#123;&#125;);obj.p1 = 123;obj.p2 = 'Owen';//生成的对象会继承它的原型对象的构造函数。function Foo() &#123;&#125;let f = new Foo();let b = Object.create(f);b.constructor === Foo // trueb instanceof Foo // true object.isPrototypeOf 判断对象是否再参数对象的原型链上 123function F()&#123;&#125;let f = new F()F.prototype.isPrototypeOf(f) //true 获取原型的三种方法 obj.__proto__ obj.constructor.prototype Object.getPrototypeOf(obj) 前两种不可靠，都个一手动修改， 而且 __proto__ 只有浏览器才需要部署 getOwnPropertyNames 和 keys 以数组形式返回参数对象所有属性名(不包含继承属性) 1234//不管可不可遍历都会返回出来Object.getOwnPropertyNames(Date);//["length", "name", "prototype", "now", "parse", "UTC"]//返回可遍历属性Object.keys(Date)// [] hasOwnProperty 判断参数是否是自身的属性，唯一一个不会遍历原型链的方法1Array.hasOwnProperty('length')//true 拷贝对象拷贝对象需要确保两件事情： 与原对象具有同样的原型。 与原对象具有同样的实例属性。 1234567891011121314151617function copyOwn (target,origin)&#123; Object.getOwnPropertyNames(origin).forEach((key)=&gt;&#123; let desc =Object.getOwnPropertyDescriptor(origin,key); Object.defineProperty(target,origin,desc); &#125;) return target&#125;function copy(origin)&#123; let clone = Object.create (Object.getPrototypeOf(origin)); copyOwn(clone,origin) return clone&#125;//es8const copyTwo = origin =&gt;Object.create( Object.getPropertyOf(origin),Object.getOwnPropertyDescriptor(origin) );]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(二)]]></title>
    <url>%2F2019%2F03%2F05%2Fopp2%2F</url>
    <content type="text"><![CDATA[原型对象 prototype 原型对象的所有属性和方法,都能被实例对象共享 JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。123456789function Cat (name, color) &#123; this.name = name; this.color = color;&#125;var cat1 = new Cat('小明', '白色');cat1.name // '小明'cat1.color // '白色' 构造函数缺点： 一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。 解决方法，就是 JavaScript 的原型对象 prototype，因为原型对象的所有属性和方法，都能被实例对象共享。 123456789function Cat (name, color) &#123; this.name = name;&#125;Cat.prototype.color ="白色";&#125;var cat1 = new Cat('巧克力');var cat2 = new Cat('布丁');cat1.color //白色cat2.color//白色 JavaScript规定，每个函数都有一个prototype属性，指向一个对象。 对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。 实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。 12function f() &#123;&#125;typeof f.prototype // "object" 每个 JS 对象都有 __proto__ 属性，这个属性可以访问到 原型（[[prototype]]） 内部属性。这个属性在现在来说已经不推荐直接去使用它了。 原型链 任何对象，都可以充当其他对象的原型；原型对象也有自己的原型。对象到原型，再到原型的原型，一层层向上找到Object.prototype。 可以说 基本上所有对象都继承了Object.prototype的属性；而 Object.prototype 的原型是 null通过 getPrototypeOf 方法返回参数对象原型1Object.getPrototypeOf(Object.prototype) //null 读取对象属性时，引擎会先在自身属性上查找，没有就查找原型，一级级向上查找，如果到Object.prototype还是没有，则返回undefined。 一级级向上，对性能有影响，寻找的层级越多，性能影响越大 原型链： 实例 F1 通过__proto__ 访问对应构造函数的原型 -&gt; FOO.prototype 函数原型再通过__proto__ 访问Object的原型 -&gt; Object.prototype Object的原型的__proto__ 指向 null 构造函数 Foo.prototype 通过constructor访问构造函数本身 Object.constructo 指向 Function Function.constructo 指向 本身 Function.__proto__ 指向一个匿名函数 每个构造函数通过 prototype 访问原型 只有函数才拥有prototype属性,基本上所有函数都有这个属性 1let fun = Function.prototype.bind() 当声明一个函数时自动创建 prototype 属性，这个属性的值是一个对象（也就是原型），且只有一个属性 constructor constructor prototype 有一个属性 constructor，默认指向原型所在的构造函数 12345678function Fn ()&#123;&#125;var f = new Fn ();f.constructor == Fn //truef.constructor == Function //false//可以从实例对象新建另一个实例var b =new f.constructor();b.constructor == Fn //true constructor是一个公有且不可枚举的属性。一旦我们改变了函数的 prototype ，那么新对象就没有这个属性了,如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。 1234function A()&#123;&#125;console.log(A.prototype) // &#123;constructor: ƒ&#125;constructor: ƒ A()__proto__: ObjectA.prototype="a"console.log(A.prototype) //"a" constructor作用： 让实例对象知道是什么函数构造了它 可以得知某个实例对象，是哪一个构造函数产生的。 如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 xx.constructor.method 来扩展 __proto__基本上每个对象都有的隐式原型属性，指向创建该对象的构造函数的原型，实际指向[[prototype]]， 内部属性，我们并不能访问到，所以使用 proto 来访问。12console.log(&#123;&#125;)//__proto__: Objectconstructor: ƒ Object()hasOwnProperty: .... 当我们使用 new 操作符时，生成的实例对象拥有了 __proto__属性。1234567function Foo() &#123;&#125;// 这个函数是 Function 的实例对象// function 就是一个语法糖// 内部调用了 new Function(...)const a =1;const fn = new Function("console.log(a)") // Function 的this始终指向 全局对象，除非手动改变this指向fn()//1 所有对象都可以通过原型链最终找到 Object.prototype ，虽然 Object.prototype 也是一个对象，但是这个对象却不是 Object 创造的，而是引擎自己创建了 Object.prototype 。可以这样说，所有实例都是对象，但是对象不一定都是实例。 -首先引擎创建了 Object.prototype ，然后创建了 Function.prototype ，并且通过proto 将两者联系了起来。 Function.prototype 以后才有了 function Function() ，然后其他的构造函数都是 function Function() 生成的。 函数通过 new Function() 生成, 不是所有函数都是 new Function()产生的。 Object 是所有对象的爸爸，所有对象都可以通过proto 找到它 Function 是所有函数的爸爸，所有函数都可以通过proto 找到它 Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎来创建 除了以上两个特殊对象，其他对象都是通过构造器 new 出来的 函数的 prototype 是一个对象，也就是原型对象的proto 指向原型，proto将对象和原型连接起来组成了原型链]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(一)]]></title>
    <url>%2F2019%2F03%2F04%2Fopp1%2F</url>
    <content type="text"><![CDATA[什么是对象对象是单个实物的抽象，通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。 面向对象编程的第一步，就是要生成对象。 对象是一个容器，封装了属性（property）和方法（method），属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。 JavaScript 语言的对象体系，不是基于“类”的，而是基于构造数constructor和原型链prototype；所以JS 专门使用构造函数作为对象模板；一个构造函数，可生成多个实列对象，它们有相同的结构 构造函数与普通函数区别 构造函数就是一个普通的函数，但是有自己的特征和用法。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。123456789101112//constructor var Bird = function () &#123; this.name = 'lai fu';&#125;;var bird1 = new Bird(); // 也可以使用 new Bird; 推荐使用前者console.log(bird1.name) // "lai fu"//ordinaryvar a =Bird();console.log(a) // undefinedconsole.log(a.name) // typeErrorname // 'laifu' 防止把构造函数constructor当普通函数使用1234567891011121314151617 //使用 严格模式function Fubar(foo, bar)&#123; 'use strict'; this._foo = foo; this._bar = bar;&#125;Fubar()// TypeError//判断 this 不是构造函数（constructor）的实列对象 那么手动返回自身constructorfunction Far(a)&#123; if (!(this instanceof Far)) return new Far(a); this._a=a;&#125;Far(1)._a new命令的原理 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 12345678910111213141516171819202122/***新生成一个空对象*链接到原型*绑定 this*返回新对象**/function _new(constuctor,param) &#123; // 获得构造函数 let Con = [].shift.call(arguments); // 链接到原型 let obj = Object.create(Con.prototype); // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return (typeof(result) === 'object' &amp;&amp; result != null) ? result : obj&#125; var fn = _new( function Person (name,age)&#123; this.name = name; this.age = age &#125;, 'Owen', 28);fn.name // 'Owen' new.target12345678910111213141516function f() &#123; console.log(new.target === f);&#125;f() // falsenew f() // true //可利用 它来判断是否使用 new 命令function f() &#123; if (!new.target) &#123; throw new Error('请使用 new 命令调用！'); &#125; // ...&#125;f() // Uncaught Error: 请使用 new 命令调用！ this实质 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。 1var obj = &#123; a: 1 &#125;; JavaScript 存储变量实际上是以下面的形式保存的。 12345678&#123; a: &#123; [[value]]: 1 //函数的地址 [[writable]]: true //是否可赋值 [[enumerable]]: true//是否可枚举 [[configurable]]: true//是否可配置 &#125;&#125; 属性的值保存在属性描述对象的value属性里面。 如果 a 属性的值是引用值 那么属性将以下面的形式保存的：1234567891011var obj = &#123; fn: function () &#123;&#125; &#125;;/*&#123; fn: &#123; [[value]]: [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125;*/ 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f n= function () &#123;&#125;;var obj = &#123; f: fn &#125;;// 单独执行 fn()// obj 环境执行obj.f() JavaScript 允许在函数体内部，引用当前环境的其他变量。 由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 下面这几种用法，都会改变this的指向。1234567891011121314151617181920(obj.fn = obj.fn)() // window// 等同于(function () &#123; console.log(this);&#125;)()(false || obj.fn)() // window// 等同于(false || function () &#123; console.log(this);&#125;)()(4, obj.fn)() // window// 等同于(4, function () &#123; console.log(this);&#125;)() 数组调用forEach 方法时函数内部this 指向window ，将父级上下文传递给forEach 改变this指向1234567891011var o = &#123; v: 'hello', p: [ 'Owen', 18 ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + '-' + item); &#125;, this); //将外层的this传递给forEach方法 &#125;&#125;o.f() // hello-Owen hello-18 end]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
</search>
