<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebRTC信令控制与STUN/TURN服务器搭建 学习]]></title>
    <url>%2F2020%2F04%2F02%2FwebRTCsignalingControl%2F</url>
    <content type="text"><![CDATA[信令服务器用于交换三种类型的信息： 会话控制消息：初始化/关闭，各种业务逻辑消息以及错误报告。 网络相关：外部可识别的IP地址和端口。 媒体能力：客户端能控制的编解码器、分辩率，以及它想与谁通讯。 会话控制消息 房间的创建与销毁、加入房间、离开房间、开启音频/关闭音频、开启视频/关闭、获取房间人数、静音/取消静音、切换主讲人、视频轮询、白板中的画笔、各种图型等等这些都是会话控制消息。 相对来说都是一引起比较简单的消息。 网络信息消息网络信息消息用于两个客户端之间交换网络信息。由于它是基于点对点连接的，自然而然需要NAT （Network Address Translator 网络地址转换）穿越的技术，否则消息将无法传递。 在WebRTC中使用 ICE 机制建立网络连接。 ICE(交互式连接创建) 交互式连接创建是由 IETF 的MMUSIC工作组开发出来的一种framework，可集成各种NAT穿透技术，如STUN、TURN（Traversal Using Relay NAT，中继NAT实现的穿透）、RSIP（Realm Specific IP，特定域IP）等。该framework可以让SIP的客户端利用各种NAT穿透方式打穿远程的防火墙。 网络地址转换（NAT 又称网络掩蔽、IP掩蔽） 在计算机网络中是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问互联网的私有网络中。它是一个方便且得到了广泛应用的技术。当然，NAT也让主机之间的通信变得复杂，导致了通信效率的降低。 我们上网很可能会处在一个 NAT 设备（无线路由器之类）之后。NAT设备会在IP封包通过设备时修改源/目的IP地址. 对于家用路由器来说, 使用的是网络地址端口转换(NAPT), 它不仅改IP, 还修改TCP和UDP协议的端口号, 这样就能让内网中的设备共用同一个外网IP 国内移动无线网络运营商在链路上一段时间内没有数据通讯后, 会淘汰NAT表中的对应项, 造成链路中断，出现NAT超时。 国内的运营商一般NAT超时的时间为5分钟，所以通常我们TCP长连接的心跳设置的时间间隔为3-5分钟 STUN]]></content>
      <categories>
        <category>webRTC</category>
      </categories>
      <tags>
        <tag>signaling control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webRTC 搭建信令服务器学习]]></title>
    <url>%2F2020%2F04%2F02%2FwebRTC_signaling%2F</url>
    <content type="text"><![CDATA[信令，指为使通信网中各种设备协调运作，在设备之间传递的有关控制信息。用来说明各自的运行情况，提出相关设备的接续要求。 通过NodeJs 搭建服务Node 基于V8引擎，是一个 JavaScript 运行环境，可以让JavaScript开发后端程序，打破了JavaScript 只能在浏览器中运行的居局面，同时开发周期短、开发成本低、学习成本低。 V8 JavaScript引擎是由Google公司使用C++语言开发的一种高性能JavaScript引擎 Node 具有超高并发能力在Java、PHP或者.NET等服务器语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。NodeJs仅使用一个线程，当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。 Nodejs 的生态链非常的完整，有各种各样的功能库。可以根据自己的需要通过安装工具 NPM 快速安装 使用socket.io 实现信令服务器环境搭建 官网下载 node (https://nodejs.org/en/) 安装 socket.io12npm install socket.ionpm install node-static socket.io特别适合用来开发WebRTC的信令服务器，通过它来构建信令服务器特别的简单，这主要是因为它内置了房间 的概念。 socket.io 分为服务端和客户端两部分。服务端由 Nodejs加载后侦听某个服务端口，客户端要想与服务端相连，首先要加载 socket.io 的客户端库，然后调用 io.connect();就与服务端连上了。 socket.io API12345678910111213141516171819202122232425//给本次连接发消息socket.emit()//给某个房间内所有人发消息io.in(room).emit()//除本连接外，给某个房间内所有人发消息socket.to(room).emit()//除本连接外，给所以人发消息socket.broadcast.emit()//发送 command 命令 socket.emit('cmd’);// 接收 cmd socket.on('cmd',function()&#123;...&#125;);//送了一个 command 命令，带 data 数据 socket.emit('action', data); socket.on('action',function(data)&#123;...&#125;);// 发送了command命令，还有两个数据 socket.emit(action,arg1,arg2); socket.on('action',function(arg1,arg2)&#123;...&#125;); 客户端 demo 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;WebRTC client&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;&lt;script type="module" src="./socketIo.js"&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// socketIo.js/*用户写入要加入的房间,然后，通过 io.connect() 建立与服务端的连接，根据socket返回的消息做不同的处理 */ window.onload = initfunction init ()&#123; let room = prompt('输入房间名') if(!room) &#123; alert('房间名不能为空') return false &#125; var socket = io.connect() console.log('Joining room: '+ room ) socket.emit('create or join',room) socket.on('join',function(room)&#123; // 监听 服务器返回的消息 console.log('Making request to join room '+ room + ' is empty', 'You are the initiator') &#125;) socket.on('created',function(room)&#123; console.log('created '+ room ) &#125;) socket.on('joined',function(room)&#123; console.log('joined '+ room ) &#125;) socket.on('full',function(room)&#123; console.log('Room '+ room + ' is full') &#125;) socket.on('empty',function(room)&#123; console.log('Room '+ room + ' is empty') &#125;) socket.on('log',function(array)&#123; console.log.apply(console,array) &#125;)&#125; 服务端 demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* socke.io 信令服务器引入 node-static 库，发布静态文件客户端（向服务端发起请求时，服务器通过该模块获得客户端运行的代码最后通过 运行 node server.js 启动node服务*/const static = require('node-static')const http = require('http')const file = new (static.Server)()const app = http.createServer((req,res)=&gt;&#123; file.serve(req,res)&#125;).listen(9800)const Io = require('socket.io').listen(app) // 侦听 9800 端口Io.sockets.on('connection',socket =&gt;&#123; const log = (...arg)=&gt;&#123; const array = ['&gt;&gt;&gt; Message from server: '] for ( let v of arg)&#123; array.push(v) &#125; socket.emit('log',array) &#125; socket.on('message',(message)=&gt;&#123; log('Got message: ',message) socket.broadcast.emit('message',message) // 给所有房间发送信息 &#125;) socket.on('message',(message)=&gt;&#123; log('Got message: ',message) &#125;) socket.on('create or join',room =&gt;&#123; let clientsInRoom = Io.sockets.adapter.rooms[room] let numClients = clientsInRoom?Object.keys(clientsInroom.sockets).length:0 // 房间人数 log(`Room $&#123;room&#125; has $&#123;numClients&#125; client(s) -- `,`Request to create or join room $&#123;room&#125;`) switch(true)&#123; case numClients === 0: socket.join(room) socket.emit('created',room) break; case numClients === 1: Io.sockets.in(room).emit('join',room) // 向对应的房间推送消息 socket.join(room) // 加入房间 scoket.emit('joined',room) // 向客户端推送消息 break; default: // 最多两人 socket.emit('full', room); //发送 "full" 消息 &#125; console.log('created or join end') let message = `emit(): client $&#123;socket.id&#125; joind room $&#123;room&#125;` socket.emit(message) socket.broadcast.emit(message) &#125;)&#125;) 参考WebRTC 入门教程（一）| 搭建WebRTC信令服务器]]></content>
      <categories>
        <category>webRTC</category>
      </categories>
      <tags>
        <tag>signaling serve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uniapp中使用vue的问题]]></title>
    <url>%2F2019%2F12%2F26%2FusingVueInUniapp%2F</url>
    <content type="text"><![CDATA[uniapp完全支持vue的生命钩子函数、模板语法、计算属性、条件渲染、列表渲染 组件uni-app只支持vue单文件组件（.vue 组件）render，和&lt;script type=&quot;text/x-template&quot;&gt;字符串模版等 非H5端都不支持uni-app 支持配置全局组件，需在 main.js 里进行全局注册，注册后就可在所有页面里使用该组件。 表单控件推荐使用原生或uniapp生态库中的组件非H5不支持v-html 跨端的富文本处理方案详情非H5端不支持列表： Slot（scoped 暂时还没做支持） 动态组件 异步组件 inline-template X-Templates keep-alive transition （可使用 animation 或 CSS 动画替代） 老的非自定义组件编译模式不支持在组件引用时，在组件上定义 click 等原生事件、v-show（可用 v-if 代替）和 class style 等样式属性(例： 样式是不会生效的)。建议更新为自定义组件模式 老的非自定义组件编译模式组件里使用 slot 嵌套的其他组件时不支持 v-for。建议更新为自定义组件模式 保留关键字标准的 HTML 及 SVG 标签名不能作为组件名。123456789101112131415161718192021222324252627282930313233343536373839404142434445acanvascellcontentcountdowndatepickerdivelementembedheaderimageimgindicatorinputlinklistloading-indicatorloadingmarqueemetarefreshrichtextscriptscrollablescrollerselectslider-neighborsliderslotspanspinnerstylesvgswitchtabbartabheadertemplatetexttextareatimepickertrisition-grouptrisitionvideoviewweb 组件属性设置不生效解决办法当重复设置某些属性为相同的值时，不会同步到view层。每次将scroll-view组件的scroll-top属性值设置为0，只有第一次能顺利返回顶部。 这和props的单向数据流特性有关，组件内部scroll-top的实际值改动后，其绑定的属性并不会一同变化。解决方法： 监听scroll事件，记录组件内部变化的值，在设置新值之前先设置为记录的当前值 （推荐使用） 123456789101112131415161718192021222324&lt;scroll-view :scroll-top="scrollTop" scroll-y="true" @scroll="scroll"&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; scrollTop: 0, old: &#123; scrollTop: 0 &#125; &#125; &#125;, methods: &#123; scroll: function(e) &#123; this.old.scrollTop = e.detail.scrollTop &#125;, goTop: function(e) &#123; this.scrollTop = this.old.scrollTop this.$nextTick(function() &#123; this.scrollTop = 0 &#125;); &#125; &#125;&#125;&lt;/script&gt; 监听scroll事件，获取组件内部变化的值，实时更新其绑定值 123456789101112131415export default &#123; data() &#123; return &#123; scrollTop: 0, &#125; &#125;, methods: &#123; scroll: function(e) &#123; this.scrollTop = e.detail.scrollTop &#125;, goTop: function(e) &#123; this.scrollTop = 0 &#125; &#125;&#125; 获取上页传递的数据可在onLoad 里得到，onLoad 的参数是其他页面打开当前页面所传递的数据。uni-app 内置了 vuex ，在app里的使用，可参考hello-uniapp store/index.js。 各个平台使用v-for的差异 在H5中，v-for=&quot;(item, index) in 10&quot; item 是从 1开始，其它平台从0开始 非H5中，不支持第三个参数 v-for=&quot;(value, name, index) in object&quot; index 是不支持的 Class和Styleclass支持的语法12345&lt;view :class="&#123; active: isActive &#125;"&gt;111&lt;/view&gt;&lt;view class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;222&lt;/view&gt;&lt;view class="static" :class="[activeClass, errorClass]"&gt;333&lt;/view&gt;&lt;view class="static" v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;444&lt;/view&gt;&lt;view class="static" v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;555&lt;/view&gt; style支持的语法以 :style=””方式设置的px单位是不会被编译器转换12&lt;view v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;666&lt;/view&gt;&lt;view v-bind:style="[&#123; color: activeColor, fontSize: fontSize + 'px' &#125;]"&gt;777&lt;/view&gt; 非H5端不支持 classObject 和styleObject语法，同时不支持在自定义组件上使用class和style的绑定123456789101112131415161718192021222324&lt;!-- 不支持的写法如下 --&gt;&lt;template&gt; &lt;view :class="[activeClass]" :style="[baseStyles,overridingStyles]"&gt;&lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; activeClass: &#123; 'active': true, 'text-danger': false &#125;, baseStyles: &#123; color: 'green', fontSize: '30px' &#125;, overridingStyles: &#123; 'font-weight': 'bold' &#125; &#125; &#125; &#125;&lt;/script&gt; 事件处理器vue与uniapp对应的事件名称： 1234567891011121314151617181920212223// 事件映射表，左侧为 WEB 事件，右侧为 ``uni-app`` 对应事件&#123; click: 'tap', touchstart: 'touchstart', touchmove: 'touchmove', touchcancel: 'touchcancel', touchend: 'touchend', tap: 'tap', longtap: 'longtap', input: 'input', change: 'change', submit: 'submit', blur: 'blur', focus: 'focus', reset: 'reset', confirm: 'confirm', columnchange: 'columnchange', linechange: 'linechange', error: 'error', scrolltoupper: 'scrolltoupper', scrolltolower: 'scrolltolower', scroll: 'scroll'&#125; 事件修饰符 .stop各平台全支持 .prevent仅H5 .self仅H5 .once仅H5 .capture仅H5 .passive仅H5 禁止蒙版下的页面滚动可使用 @touchmove.stop.prevent=”handle” 无按键修饰符]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Notes using Vue in uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uniapp manifest 应用的配置文件]]></title>
    <url>%2F2019%2F12%2F26%2FuniappManifest%2F</url>
    <content type="text"><![CDATA[manifest.json 是应用的配置文件，用于指定应用的名称、图标、权限等 属性 值类型 默认值 描述 兼容 name String 应用名称 appid String 新建项目时，DCloud云端分配详情 勿自行修改 应用标识 description String 应用描述 versionName String 版本名称 versionCode String 版本号 transformPx Boolean true 是否转化项目的px,true转化为rpx networkTimeout Object 网络超时 见 debug Boolean false 是否开启debug模式 app-plus Object 5+App特有配置 h5 Object H5特有配置 quickapp Object 快应用特有配置，即将支持 mp-weixin Object 微信特有配置 mp-alipay Object 支付宝特有配置 mp-baidu Object 百度特有配置 mp-toutiao Object 头条特有配置 1.6.0 mp-qq Object QQ特有配置 2.1.0 versionName在云打包App和生成wgt应用资源时会使用。如需升级App版本，先修改此处再云打包。导出wgt资源用于离线打包和热更新时也会以此版本为依据。 在本地打包时和热更新时，App版本和wgt应用资源版本将不再保持一致。此时通过plus.runtime.version可获取App版本，通过plus.runtime.getProperty获取wgt资源版本。 networkTimeout各类网络请求的超时时间，默认值均为6000毫秒 属性 值类型 描述 request Number uni.request的超时时间 connectSocket Number uni.connectSocket的超时时间 uploadFile Number uni.uploadFile的超时时间 downloadFile Number uni.downloadFile的超时时间 App Splashscreensplash是App必然存在，不可取消的 属性 值类型 默认值 描述 alwaysShowBeforRender Boolean true 首页白屏时不关闭启动界面，支持最低1.6.0版本 autoclose Boolean true 是否自动关闭程序启动界面。如须手动关闭，那么 alwaysShowBeforeRender及autoclose均须设置为false waiting Boolean true 是否在程序启动界面显示等待圈或雪花 delay Number 0 启动界面在应用的首页加载完毕后延迟关闭的时间 如果不配置自己的splash图，APP端会默认将App的Icon放到splash中 splash只能是标准png 相关改动，云打包生效，真机运行不生效。本地打包须自行在原生工程中配置 App启动图中IOS的MAX等大屏设备的splash图若不匹配，会导致IOS认为App未为MAX优化，将无法全屏 Android的splash 详见 完整 manifest.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311&#123; "appid": "__UNI__XXXXXX，创建应用时云端分配的，不要修改。", "name": "应用名称，如uni-app", "description": "应用描述", "versionName": "1.0.0", "versionCode": "100", // app-plus 节点是 5+App 特有配置，推荐在 HBuilderX 的 manifest.json 可视化界面操作完成配置。 "app-plus": &#123; // HBuilderX-&gt;manifest.json-&gt;模块权限配置 "modules": &#123; "Contacts": &#123;&#125;, "Fingerprint": &#123;&#125;, "Maps": &#123;&#125;, "Messaging": &#123;&#125;, "OAuth": &#123;&#125;, "Payment": &#123;&#125;, "Push": &#123;&#125;, "Share": &#123;&#125;, "Speech": &#123;&#125;, "Statistic": &#123;&#125;, "VideoPlayer": &#123;&#125;, "LivePusher": &#123;&#125; &#125;, "distribute": &#123; // Android 与 iOS 证书相关信息均在打包时完成配置 "android": &#123; "packagename": "Android应用包名，如io.dcloud.uniapp", "keystore": "Android应用打包使用的密钥库文件", "password": "Android应用打包使用密钥库中证书的密码", "aliasname": "Android应用打包使用密钥库中证书的别名", "schemes": [ "应用支持的scheme，大小写相关，推荐使用小写" ], "theme": "程序使用的主题", "android:name": "自定义程序入口类名", "custompermissions": "Boolean类型，是否自定义android权限，true表示自定义权限，只使用permissions下指定的android权限，不根据用户使用的5+模块自动添加android权限，false表示自动根据用户使用的5+模块自动添加android权限", "permissions": [ "要添加的额外的android权限，如&lt;uses-permission android:name=\"com.android.launcher.permission.INSTALL_SHORTCUT\" /&gt;", "&lt;uses-permission android:name=\"com.android.launcher.permission.UNINSTALL_SHORTCUT\" /&gt;" ], "minSdkVersion": "apk支持的最低版本，默认值为14", "targetSdkVersion": "apk的目标版本，默认值为21" &#125;, "ios": &#123; "appid": "iOS应用标识，苹果开发网站申请的appid，如io.dcloud.uniapp", "mobileprovision": "iOS应用打包配置文件", "password": "iOS应用打包个人证书导入密码", "p12": "iOS应用打包个人证书，打包配置文件关联的个人证书", "devices": "iOS应用支持的设备类型，可取值iphone/ipad/universal", "urltypes": [&#123; "urlschemes": [ "hbuilder", "必选，程序所支持的自定义协议名称" ], "id": "可选，自定义协议的标识", "icon": "可选，打开程序时显示的图标" &#125;, &#123; "urlschemes": [ "http", "https", "必选，程序所支持的自定义协议名称，大小写无关，推荐使用小写" ], "id": "可选，自定义协议的标识", "icon": "可选，打开程序时显示的图标" &#125; ], "frameworks": ["使用native.js调用API要引用的库文件名称，如CoreLocation.framework", "QuartzCore.framework"], "idfa": "true|false，是否使用广告标识符，默认值为false", "plistcmds": [ "Set :权限 使用权限的原因", "Set :NSCameraUsageDescription 说明使用用户相机的原因" ] &#125;, // HBuilderX-&gt;manifest.json-&gt;SDK配置 "sdkConfigs": &#123; "maps": &#123; // 地图只能选一个，这里选的是百度。 "baidu": &#123; "appkey_ios": "", "appkey_android": "" &#125; &#125;, "oauth": &#123; // 微信登录 "weixin": &#123; "appid": "", "appsecret": "" &#125;, // QQ登录 "qq": &#123; "appid": "" &#125;, // 新浪微博登录 "sina": &#123; "appkey": "", "appsecret": "", "redirect_uri": "" &#125;, // 小米登录 "xiaomi": &#123; "appid_ios": "", "appsecret_ios": "", "redirect_uri_ios": "", "appid_android": "", "appsecret_android": "", "redirect_uri_android": "" &#125; &#125;, "payment": &#123; // Apple应用内支付 "appleiap": &#123;&#125;, // 支付宝支付 "alipay": &#123; "scheme": "" &#125;, // 微信支付 "weixin": &#123; "appid": "" &#125; &#125;, "push": &#123; // 推送只能选择一个，这里选的是个推。 "igexin": &#123; "appid": "", "appkey": "", "appsecret": "" &#125; &#125;, "share": &#123; // 微信分享 "weixin": &#123; "appid": "" &#125;, // 新浪微博分享 "sina": &#123; "appkey": "", "appsecret": "", "redirect_uri": "" &#125;, // 分享到QQ "qq": &#123; "appid": "" &#125; &#125;, "statics": &#123; // 友盟统计 "umeng": &#123; "appkey_ios": "", "channelid_ios": "", "appkey_android": "", "channelid_android": "" &#125; &#125; &#125;, // 屏幕方向 需要云打包/本地打包/自定义基座生效 "orientation": [ "portrait-primary", "landscape-primary", "portrait-secondary", "landscape-secondary" ], // HBuilderX-&gt;manifest.json-&gt;图标配置 "icons": &#123; "ios": &#123; "appstore": "必选, 1024x1024, 提交app sotre使用的图标", "iphone": &#123; "app@2x": "可选，120x120，iOS7-11程序图标（iPhone4S/5/6/7/8）", "app@3x": "可选，180x180，iOS7-11程序图标（iPhone6plus/7plus/8plus/X）", "spotlight@2x": "可选，80x80，iOS7-11 Spotlight搜索图标（iPhone5/6/7/8）", "spotlight@3x": "可选，120x120，iOS7-11 Spotlight搜索图标（iPhone6plus/7plus/8plus/X）", "settings@2x": "可选，58x58，iOS5-11 Settings设置图标（iPhone5/6/7/8）", "settings@3x": "可选，87x87，iOS5-11 Settings设置图标（iPhone6plus/7plus/8plus/X）", "notification@2x": "可选，40x40，iOS7-11 通知栏图标（iPhone5/6/7/8）", "notification@3x": "可选，60x60，iOS7-11 通知栏图标（iPhone6plus/7plus/8plus/X）" &#125;, "ipad": &#123; "app": "可选，76x76，iOS7-11程序图标", "app@2x": "可选，152x152，iOS7-11程序图标（高分屏）", "proapp@2x": "可选，167x167，iOS9-11程序图标（iPad Pro）", "spotlight": "可选，40x40，iOS7-11 Spotlight搜索图标", "spotlight@2x": "可选，80x80，iOS7-11 Spotlight搜索图标（高分屏）", "settings": "可选，29x29，iOS5-11 设置图标", "settings@2x": "可选，58x58，iOS5-11 设置图标（高分屏）", "notification": "可选，20x20，iOS7-11 通知栏图标", "notification@2x": "可选，40x40，iOS7-11 通知栏图标（高分屏）" &#125; &#125;, "android": &#123; "mdpi": "必选，48x48，普通屏程序图标", "ldpi": "必选，48x48，大屏程序图标", "hdpi": "必选，72x72，高分屏程序图标", "xhdpi": "必选，96x96，720P高分屏程序图标", "xxhdpi": "必选，144x144，1080P高分屏程序图标", "xxxhdpi": "可选，192x192" &#125; &#125;, // HBuilderX-&gt;manifest.json-&gt;启动图配置 "splashscreen": &#123; "ios": &#123; "iphone": &#123; "retina35": "可选，640x960，3.5英寸设备(iPhone4)启动图片", "retina40": "可选，640x1136，4.0英寸设备(iPhone5)启动图片", "retina40l": "可选，1136x640，4.0英寸设备(iPhone5)横屏启动图片", "retina47": "可选，750x1334，4.7英寸设备（iPhone6）启动图片", "retina47l": "可选，1334x750，4.7英寸设备（iPhone6）横屏启动图片", "retina55": "可选，1242x2208，5.5英寸设备（iPhone6Plus）启动图片", "retina55l": "可选，2208x1242，5.5英寸设备（iPhone6Plus）横屏启动图片", "iphonex": "可选，1125x2436，iPhoneX启动图片", "iphonexl": "可选，2436x1125，iPhoneX横屏启动图片" &#125;, "ipad": &#123; "portrait": "可选，768x1004，需支持iPad时必选，iPad竖屏启动图片", "portrait-retina": "可选，1536x2008，需支持iPad时必选，iPad高分屏竖屏图片", "landscape": "可选，1024x748，需支持iPad时必选，iPad横屏启动图片", "landscape-retina": "可选，2048x1496，需支持iPad时必选，iPad高分屏横屏启动图片", "portrait7": "可选，768x1024，需支持iPad iOS7时必选，iPad竖屏启动图片", "portrait-retina7": "可选，1536x2048，需支持iPad iOS7时必选，iPad高分屏竖屏图片", "landscape7": "可选，1024x768，需支持iPad iOS7时必选，iPad横屏启动图片", "landscape-retina7": "可选，2048x1536，需支持iPad iOS7时必选，iPad高分屏横屏启动图片" &#125; &#125;, "android": &#123; "mdpi": "必选，240x282，普通屏启动图片", "ldpi": "必选，320x442，大屏启动图片", "hdpi": "必选，480x762，高分屏启动图片", "xhdpi": "必选，720x1242，720P高分屏启动图片", "xxhdpi": "必选，1080x1882，1080P高分屏启动图片" &#125; &#125; &#125;, // HBuilderX-&gt;manifest.json-&gt;启动图配置-&gt;启动界面选项 "splashscreen": &#123; "waiting": true, "autoclose": true, "delay": 0 &#125;, "error": &#123; "url": "页面加载错误时打开的页面地址，可以是网络地址，也可以是本地地址" &#125;, "useragent": &#123; "value": "自定义ua字符串", "concatenate": "是否为追加模式" &#125;, "useragent_ios": &#123; "value": "与useragent的value一致，仅在iOS平台生效，当useragent和useragent_ios同时存在时优先级useragent_ios&gt;useragent", "concatenate": "与useragent的concatenate一致，仅iOS平台生效" &#125;, "useragent_android": &#123; "value": "与useragent的value一致，仅在Android平台生效，当useragent和useragent_android同时存在时优先级useragent_android&gt;useragent", "concatenate": "与useragent的concatenate一致，仅Android平台生效" &#125;, "ssl": "accept|refuse|warning，访问https网络时对非受信证书的处理逻辑", "runmode": "normal", "appWhitelist": [ "Android平台下载apk地址白名单列表", "iOS平台跳转appstore地址白名单列表" ], "schemeWhitelist": [ "URL Scheme白名单列表，如：mqq" //iOS要求预先指定要打开的App名单，不能随意调用任何App ], "channel": "渠道标记，可在DCloud开发者中心查看各渠道应用的统计数据", "adid": "广告联盟会员id，在DCloud开发者中心申请后填写", "safearea": &#123; //安全区域配置，仅iOS平台生效 "background": "#CCCCCC", //安全区域外的背景颜色，默认值为"#FFFFFF" "bottom": &#123; // 底部安全区域配置 "offset": "none|auto" // 底部安全区域偏移，"none"表示不空出安全区域，"auto"自动计算空出安全区域，默认值为"none" &#125;, "left": &#123; //左侧安全区域配置（横屏显示时有效） "offset": "none|auto" &#125;, "right": &#123; //右侧安全区域配置（横屏显示时有效） "offset": "none|auto" &#125; &#125;, "softinput": &#123; "navBar": "auto", //是否显示iOS软键盘上的“完成”导航条 "mode": "adjustResize|adjustPan" //软键盘弹出模式， &#125;, "popGesture": "none" //iOS上是否支持屏幕左边滑动关闭当前页面。默认是可关闭。设为none则不响应左滑动画。 &#125;, // 快应用特有配置 "quickapp": &#123;&#125;, // 微信小程序特有配置 "mp-weixin": &#123; "appid": "wx开头的微信小程序appid" &#125;, // 百度小程序特有配置 "mp-baidu": &#123; "appid": "百度小程序appid" &#125;, // 头条小程序特有配置 "mp-toutiao": &#123; "appid": "头条小程序appid" &#125;, "h5": &#123; "title": "演示", //页面标题，默认使用 manifest.json 的 name "template": "index.html", //index.html模板路径，相对于应用根目录，可定制生成的 html 代码 "router": &#123; "mode": "history", //路由跳转模式，支持 hash|history ,默认 hash "base": "/hello/" //应用基础路径，例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 "/app/" &#125;, "async": &#123; //页面js异步加载配置 "loading": "AsyncLoading", //页面js加载时使用的组件（需注册为全局组件） "error": "AsyncError", //页面js加载失败时使用的组件（需注册为全局组件） "delay": 200, //展示 loading 加载组件的延时时间（页面 js 若在 delay 时间内加载完成，则不会显示 loading 组件） "timeout": 3000 //页面js加载超时时间（超时后展示 error 对应的组件） &#125; &#125;&#125;]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>uniappManifest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uniapp的路由配置]]></title>
    <url>%2F2019%2F12%2F25%2FuniappPagesConfigs%2F</url>
    <content type="text"><![CDATA[uniapp通过根目录中的pages.json文件决定页面文件的路径、窗口样式、原生导航栏、底部原生tarBar等 配置项列表 属性 值类型 是否必选 描述 兼容 globalStyle Object 否 设置默认页面的窗口表现,可设置应用的状态栏、导航条、标题、窗口背景色等。 pages Object,Array 是 设置页面的路径及窗口表现 easycom Object 否 组件自动引入规则 2.5.0+ tabBar Object 否 设置底部tab的表现 condition Object 否 启动模式配置 subPackages Object,Array 否 分包加载配置 preloadRule Object 否 分包预下载规则 微信小程序 workers Scring 否 Worker 代码放置目录 微信小程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&#123; "pages": [&#123; // pages节点的第一项为应用入口页（即首页）,应用中新增/减少页面，都需要对 pages 数组进行修改,文件名不需要写后缀，框架会自动寻找路径下的页面资源 "path": "pages/component/index", // 配置页面路径 "style": &#123; // 配置页面窗口表现,用于设置对应页面的状态栏、导航条、标题、窗口背景色等。 其配置项与 globalStyle 一致，此配置会覆盖 globalStyle "disableScroll": false,//禁用滚动 全局中无此设置 //仅支持微信小程序（iOS）、百度小程序（iOS） "navigationBarShadow":&#123; //导航栏阴影 "colorType":"grey" // 支持颜色：grey、blue、green、orange、red、yellow &#125;, &#125; &#125;, &#123; "path": "pages/API/index", "style": &#123; "navigationBarTitleText": "接口" &#125; &#125;, &#123; "path": "pages/component/view/index", "style": &#123; "navigationBarTitleText": "view" &#125; &#125;], "condition": &#123; //模式配置，仅开发期间生效 "current": 0, //当前激活的模式（list 的索引项） "list": [&#123; "name": "test", //模式名称 "path": "pages/component/view/index" //启动页面，必选 &#125;] &#125;, "globalStyle": &#123; "navigationBarTextStyle": "black", // 导航栏标题颜色及状态栏前景颜色，仅支持 black/white "navigationBarTitleText": "演示", // 导航栏标题文字内容 "navigationBarBackgroundColor": "#F8F8F8", // 导航栏背景色 "backgroundColor": "#F8F8F8", "navigationStyle":"default", // 导航栏样式，仅支持 default/custom。custom即取消默认的原生导航栏 //仅支持 微信小程序 7.0+、百度小程序、H5、App（2.0.3+） "backgroundColor":"#ffffff", //窗口背景色 //仅支持微信小程序 "backgroundTextStyle":"dark", // 下拉loading样式，仅支持dark/light //仅支持微信小程序 "enablePullDownRefresh":false,// 是否开启下拉刷新 "onReachBottomDistance":50,// 上拉触底事件触发时距离页面底部距离，单位仅支持px "backgroundColorTop":"#ffffff",// 顶部窗口的背景色（bounce回弹区域）//仅支持iOS "backgroundColorBottom":"#ffffff",// 底部部窗口的背景色（bounce回弹区域）//仅支持iOS "titleImage":"", // 导航栏图片地址（替换当前文字标题），支付宝小程序内必须使用https的图片链接地址 //仅支持支付宝小程序、H5、APP "transparentTitle":"none", // 导航栏透明设置。支持 always 一直透明 / auto 滑动自适应 / none 不透明//仅支持支付宝小程序、H5、APP "titlePenetrate":"NO",// 导航栏点击穿透 "pageOrientation":"portrait", // 横屏配置，屏幕旋转设置，仅支持 auto/portrait/landscape // 仅支持App 2.4.7+、微信小程序 "animationType":"pop-in", // 窗口显示的动画效果 // 仅支持App "animationDuration":300, // 窗口动画的持续时间 // 仅支持App "app-plus":&#123;//编译到APP 平台的特定样式 详情见uniapp官网 https://uniapp.dcloud.io/collocation/pages?id=app-plus // 仅支持App &#125;, "h5":&#123;//编译到h5 平台的特定样式 // 仅支持h5 &#125;, "mp-alipay":&#123;//编译到mp-alipay 平台的特定样式 // 仅支持mp-alipay 支付包 &#125;, "mp-weixin":&#123;//编译到mp-weixin平台的特定样式 // 仅支持微信小程序 &#125;, "mp-baidu":&#123;//编译到"mp-baidu 平台的特定样式 // 仅支持百度小程序 &#125;, "mp-toutiao":&#123;//编译到mp-toutiao 平台的特定样式 // 仅支持字节跳动小程序 &#125;, "mp-qq":&#123;//编译到mp-qq 平台的特定样式 // 仅支持QQ小程序 &#125;, "usingComponents":&#123; // 引用小程序组件 "collapse-tree-item":"/components/collapse-tree-item" &#125;, "pageOrientation": "portrait"//横屏配置，全局屏幕旋转设置(仅 APP/微信/QQ小程序)，支持 auto / portrait / landscape &#125;, "tabBar": &#123; "color": "#7A7E83", "selectedColor": "#3cc51f", "borderStyle": "black", "backgroundColor": "#ffffff", "height": "50px", "fontSize": "10px", "iconWidth": "24px", "spacing": "3px", "list": [&#123; "pagePath": "pages/component/index", "iconPath": "static/image/icon_component.png", "selectedIconPath": "static/image/icon_component_HL.png", "text": "组件" &#125;, &#123; "pagePath": "pages/API/index", "iconPath": "static/image/icon_API.png", "selectedIconPath": "static/image/icon_API_HL.png", "text": "接口" &#125;], "midButton": &#123; "width": "80px", "height": "50px", "text": "文字", "iconPath": "static/image/midButton_iconPath.png", "iconWidth": "24px", "backgroundImage": "static/image/midButton_backgroundImage.png" &#125; &#125;, "easycom": &#123; "uni-(.*)": "@/components/uni-$1/uni-$1.vue" &#125;&#125; 自定义导航栏使用注意事项当 navigationStyle&quot;:custom或titleNView:false时，原生导航栏不显示同时需注意： 非H5段，手机顶部状态栏区域会被页面内容覆盖。uniapp提供状态栏css变量，可使用view占用其位置 如果原生导航不满足要求，可使用自定义导航栏 NavBar 导航栏搭配原生下拉刷新问题：微信小程序ios端需要拉更长才能看到下来刷新，Android则从屏幕底部下拉，无法从状态栏下拉，如需，请前端模拟， 推荐插件 非H5段，前端导航盖不住原生组件，如页面有viedo,map等原生组件，滚动时会覆盖导航栏，小程序可使用cover-view来解决，APP可使用titleNView 或subNVue 前端组件渲染不如原生导航，原生导航可保证动画期间不白屏 页面禁用原生导航后想，改变状态栏前景字体，可设置navigationBarTextStyle,部分低端手机不支持 鉴于以上问题，原生导航等满足业务需求，使用原生导航，甚至可牺牲一些不重要的需求。更多详情 easycom 配置说明 通过正则匹配来自动引入组件 此方式引入的组件无需在页面内import,也无需在components中声明，即可在页面中使用 组件名完全一致的情况下，优先级低于手动 修改easycom 不会重新编译，须手动改动页面触发 123"easycom": &#123; "uni-(.*)": "@/components/uni-$1/uni-$1.vue"&#125; tabBar 配置说明 position为top时 不显示ICON, top值仅支持微信小程序 tabBar中list是数组最少配置2个，最多5个tab,按数组顺序排列 切换第一次加载时可能渲染不及时，可在每个Tabbar页面的onLoad生命周期中先弹出一个loading 页面出现过后，保存在内存中，切换tabbar,之后触发onShow,不在触发onLoad 属性 是否必选 值类型 默认值 描述 平台差异 color 是 HexColor tab字体默认颜色 selectedColor 是 HexColor 选中颜色 backgroundColor 是 HexColor 背景色 borderStyle 否 String black 边框颜色仅支持black/white App最新版支持其它颜色 list 是 Array tab列表最少2，最多5 position 否 String bottom 位置 bottom\top 仅微信支持top fontSize 否 String 10px 字体大小 App2.3.4+ iconWidth 否 String 24px icon默认宽度 App2.3.4+ spacing 否 String 3px 图标与文字间间距 App2.3.4+ height 否 String 50px 默认高度 App2.3.4+ mindButton 否 Object 中间按钮仅在list为偶数时生效 App2.3.4+ list 属性说明list数组中的子项都为对象，其属性为： 属性 值类型 是否必选 说明 pagePath String 是 页面路径，须在pages中选定义 text String 是 tab是按钮文字，H5、5+APP平台非必填 iconPath String 否 图片路径，大小40kB,尺寸81*81，只支持静态图片，不支持字体图 selectedIconPath String 否 选中时的图片 midButton 属性 值类型 是否必选 默认值 说明 width String 否 中间按钮的宽度，tabBar中其它项为减去此宽度后平分，默认值为与其它项平分 height String 否 中间按钮的高度 text String 否 中间按钮的文字 iconPath String 否 中间按钮的图片路径 iconWidth String 否 图片宽度 backgroundImage String 否 背景图 mindButton 没有pagePath,需监听点击事件，自行处理点击后的逻辑，监听事件：uni.onTabBarMidBottonTap详情，此事件仅支持 App tabBar常见问题 详情 tabBar在各个平台的默认高度不一，App在HBuilderX 2.3.4起从56px调整为50px, 通过JS API实现动态修改tabBar JS代码跳转至tabBar页面，API 只能使用uni.switchTab,不能使用uni.navigateTo、uni,rediretTo,使用 navigator组件跳转时须设置属性open-type=&quot;switchTab&quot; 原生tabBar有且只有一个在首页，二级页如需Tab,须自行实现 如需先登录，后进入tab页面，无须将登录页设为首页，可参考HBuilderX新建项目时的登录模板 1234567891011121314151617"tabBar": &#123; "color": "#7A7E83", "selectedColor": "#3cc51f", "borderStyle": "black", "backgroundColor": "#ffffff", "list": [&#123; "pagePath": "pages/component/index", "iconPath": "static/image/icon_component.png", "selectedIconPath": "static/image/icon_component_HL.png", "text": "组件" &#125;, &#123; "pagePath": "pages/API/index", "iconPath": "static/image/icon_API.png", "selectedIconPath": "static/image/icon_API_HL.png", "text": "接口" &#125;]&#125; condition启动模式配置，仅开放环境有效，模拟直达页面的场景，（如：小程序转发后，用户点击所打开的页面） 属性 值类型 是否必选 描述 current Number 是 当前激活的模式，list节点的索引值 list Array 是 启动模式列表 list 属性 值类型 是否必选 描述 name String 是 启动模式名 path String 是 启动页面路径 query String 否 启动参数，可在onLoad中获取 12345678910111213"condition": &#123; //模式配置，仅开发期间生效 "current": 0, //当前激活的模式（list 的索引项） "list": [&#123; "name": "swiper", //模式名称 "path": "pages/component/swiper/swiper", //启动页面，必选 "query": "interval=4000&amp;autoplay=false" //启动参数，在页面的onLoad函数里面得到。 &#125;, &#123; "name": "test", "path": "pages/component/switch/switch" &#125; ]&#125; subPackages分包加载配置此配置为小程序的分包加载机制 微信、百度每个分包大概2M，总共不能超过8M 支付宝每个分包大概2M，不能超过4M subPackages 的pages路径为 root下的相对路径 分包优化详情 对于vendor.js过大情况可使用运行是压缩代码：HBuilderX创建的项目勾选 运行-&gt;运行到小程序模拟器-&gt;运行时是否压缩代码；cli项目可在 packge.json中添加参数 --minimize 属性 值类型 是否必选 描述 root String 是 子包根目录 pages Array 是 子包由哪些页面组成参数同 pages 123456789101112131415161718192021222324252627282930313233343536&#123; "pages": [&#123; "path": "pages/index/index", "style": &#123; ...&#125; &#125;, &#123; "path": "pages/login/login", "style": &#123; ...&#125; &#125; ], "subPackages": [&#123; "root": "pagesA", "pages": [&#123; "path": "list/list", "style": &#123; ...&#125; &#125;] &#125;, &#123; "root": "pagesB", "pages": [&#123; "path": "detail/detail", "style": &#123; ...&#125; &#125;] &#125; ], "preloadRule": &#123; "pagesA/list/list": &#123; "network": "all", "packages": ["__APP__"] &#125;, "pagesB/detail/detail": &#123; "network": "all", "packages": ["pagesA"] &#125; &#125;&#125; preloadRule分包预加载配置。 属性 值类型 是否必选 描述 packages Array 是 进入页面后预下载分包的root或name network String 否 在指定网络下预下载，all(不限网络)、wifi(默认仅WiFi下预下载)]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>uniappPages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uniapp 开发文档]]></title>
    <url>%2F2019%2F12%2F24%2FuniappStudy%2F</url>
    <content type="text"><![CDATA[概叙uni-app是基于vueJS框架开发的微端应用框架，可一套代码跨ios\Android\H5\小程序等多个平台运行 可通过官方开发的HBuilderX IDE 创建uni-app项目，开箱即用，可快速上手。 开发规范 页面文件遵循Vue 单文件组件规范，数据绑定及数据处理支持vue规范 组件标签靠近小程序规范 接口API靠近微信小程序规范，将前缀wx改为uni 推荐使用Flex布局 目录结构┌─common uni-app公共资源目录│ └─com-a.js│ └─com-a.css┌─components uni-app组件目录│ └─comp-a.vue 可复用的a组件├─hybrid 存放本地网页的目录，详见├─platforms 存放各平台专用页面的目录，详见├─pages 业务页面文件存放的目录│ ├─index│ │ └─index.vue index页面│ └─list│ └─list.vue list页面├─static 存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此├─wxcomponents 存放小程序组件的目录，详见├─main.js Vue初始化入口文件├─App.vue 应用配置，用来配置App全局样式以及监听 应用生命周期 详见├─manifest.json 配置应用名称、appid、logo、版本等打包信息，详见└─pages.json 配置页面路由、导航条、选项卡等页面类信息，详见 static中的 js文件不会被编译，如果使用ES6将会报错css、less等资源放入公共资源目录中 生命周期应用生命周期应用生命周期仅只 App.vue中可监听 函数名 说明 onLaunch 初始化项目完成时触发（仅触发一次） onShow 启动项目或从后台进入前台显示时触发 onHide 从前台隐藏至后台时触发 onError 程序出错时触发 onuniViewMessage 对 nvue 页面发送数据进行监听 详情 页面生命周期 详情 函数名 说明 onLoad 监听页面加载，可接受上个页面传递的数据，param[Object], 详情 onShow 监听页面显示，每次出现在屏幕时触发 onReady 页面初次渲染完成时触发，可能会在页面进入动画完成前触发 onHide 从隐藏至后台时触发 onUnload 监听页面卸载 onResize 监听窗口变化 仅支持 5+App、微信小程序 onPullDownRefresh 监听用户下拉动作，详情 onReachBottom 监听页面上拉触底事件 onTabItemTap 点击Tab触发，param[Object]：( &nbsp;{index:String,pagePath:String,text:String} &nbsp;)。仅支持 微信小程序、百度小程序、H5、5+App（自定义组件模式） onShareAppMessage 用户点击右上角分享触发 仅支持 微信小程序、百度小程序、头条小程序、支付宝小程序 onPageScroll 监听页面滚动，param[Object]：（ &nbsp; {scrollTop:Number} 页面在垂直方向已滚动的距离（单位px） ） onNavigationBarButtonTap 监听原生标题栏按钮点击事件，param[Object]:(&nbsp; {index:Number} &nbsp;) 原生标题栏按钮数组的下标 仅支持 5+ App、H5 onBackPress 监听页面返回，event对象为 {from:backbutton,navigateBack},backbutton:来源于左上角按钮或android返回键，navigateBack:来源于uni.navigateBack。详情 仅支持 5+ App、H5 onNavigationBarSearchInputChanged 监听原生标题栏搜索输入框内容变化，param[Object] 仅支持 5+ App、H5 onNavigationBarSearchInputConfirmed 监听原生标题栏搜索输入框搜索事件，点击软键盘上的搜索按钮，param[Object] 仅支持 5+ App、H5 onNavigationBarSearchInputClicked 监听原生标题栏搜索输入框点击事件，param[Object] 仅支持 5+ App、H5 onTabItemTap 常用于点击当前tabItem,滚动或刷新当前页面。 路由uni-app 的路由全权由框架统一管理，通过pages.json配置每个路由页面路径及样式，不支持 vueRouter其路由有两种方式可跳转：使用 navigation 组件跳转、调用API跳转框架是以栈的形式管理所有页面，当路由切换时，页面栈的表现详见详情 运行环境的判断 判断开发生产环境（process.env.NODE_ENV）详情 判断平台通过编辑条件判断编译出包后的代码详情,通过API uni.getSystemInfoSync().platform 判断客户端环境 android/ios/devtools （小程序） 布局单位 详见uni-app支持通用单位px,rpxpx：固定的屏幕像素rpx：响应式像素，是相对于基准宽度的单位，可以根据屏幕宽度进行自适应，uni-app 规定屏幕基准宽度 750rpx。转化公式（750 * 元素在设计稿中的宽度 / 设计稿基准宽度） rpx和宽度相关，屏幕越框，实际像素越大，它不支持动态横竖屏切换计算，如果使用rpx建议锁定屏幕方向 设计师可用iphone6作为视稿标准 如果设计稿不是 750px，HBuilderX提供了工具自动换算，详见 H5单位 rem: 默认根字体大小为 屏幕宽度/20 (支持 微信小程序、头条小程序、App、H5) vh: 1vh等于视窗高度的1% vw: 1vw等于视窗宽度的1% nvue 不支持百分比，App端，在 pages.json仅支持px 内联样式静态样式统一写至class中，style只接受动态样式，这样可以避免性能的消耗 目前支持的选择器class,id,element,::before:/::after(仅微信小程序和5+APP生效) 无法使用*,page相当于bodyApp.vue 中的样式为全局样式，nvue不支持全局样式 css变量 变量 描述 –status-bar-height 系统状态栏高度，小程序为25px，H5为0 –window-top 内容区域距离顶部的距离，小程序为0 ，H5为NavigationBar高度 –window-bottom 内容区域距离底部部的距离，小程序为0 ，H5为TabBar高度 当设置 navigationStyle:&quot;custom&quot;取消原生导航栏，由于窗体沉浸式，占据了状态栏位置。此时可使用var(--status-bar-height)的view放在页面顶部，避免页面内容出现在状态栏。 由于H5端部存在原生导航栏和tabBar,因此由前端模拟 目前 nvue 不支持--status-bar-height,可在页面onLoad时通过uni.getSystemInfoSync().statusBarHeight获取状态栏高度，然后通过style绑定方式给占位view设定高度。 NavigationBar导航栏( 固定高度44px 不可修改),TabBar 底部选项卡( 固定高度50px 不可修改) 背景图注意点 支持base64、网络路径图 本地路径图小于40Kb,自动转化为base64,大于则须手动转化，或使用网络路径的方式引用。 推荐以~@的方式引用图片，而V3版本设定为不自动转化成base64 微信小程序不支持相对路径 123.test &#123; background-image: url('~@/static/logo.png');&#125; 字体图 网络路径必须加协议头 https 字体文件大于等于 40kb， 需开发者自己转换，否则使用将不生效；12345678 @font-face &#123; font-family: test1-icon; src: url('~@/static/iconfont.ttf'); &#125;@font-face &#123;font-family: 'iconfont';src: url('https://at.alicdn.com/t/font_865816_17gjspmmrkti.ttf') format('truetype');&#125; TypeScriptVue.js 对 TypeScript 支持详情 对应小程序自定义组件存放目录]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript_events]]></title>
    <url>%2F2019%2F12%2F18%2Fjavascript_events%2F</url>
    <content type="text"><![CDATA[事件事件是某事发生的信号，它可以被系统侦测到，从而触发某个函数或程序 DOM 事件标准描述了事件传播的 3 个阶段： 捕获阶段 —— 事件（从 Window）向下到达元素上。 目标阶段 —— 事件到达目标元素。 冒泡阶段 —— 事件从元素上开始冒泡。 事件首先通过祖先链向下传递到元素（捕获），然后到达目标，最后上升（冒泡），在途中调用处理器。 冒泡冒泡：当事件发生再元素上，它首先会运行元素本身的处理器，然后运行父级上同类型的处理器，之后运行其它祖级上同类型的处理器(大多数事件都是冒泡行为，forcus等例外)；可通过 event.stopPropagation()通过 JSon&lt;event&gt;属性、addEventListener(event,handler,false)或HTML属性添加的函数，发生在冒泡阶段和目标阶段 123456789101112&lt;style&gt; body * &#123; margin: 10px; border: 1px solid blue; &#125;&lt;/style&gt;&lt;div onclick="alert('forbear')"&gt;FORBEAR &lt;div onclick="alert('parent')"&gt;Parent &lt;p onclick="alert('son')"&gt;SON&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; JS中与鼠标相关事件：click左击、dblclick左双击、contextmenu右击、mouseover / mouseenter(不会冒泡)鼠标移入元素、mousemove / mouseleave(不会冒泡)鼠标移出元素、mousedown按下、mouseup松开]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>JS_events</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 的更新和查询]]></title>
    <url>%2F2019%2F10%2F16%2Fmysql_data_update_and_query%2F</url>
    <content type="text"><![CDATA[更新数据更新有三种操作：插入数据（INSERT）、修改表中的数据(UPDATE)、删除数据(DELETE) 插入数据INSERT … VALUES 插入多行或单行元组数据12INSERT [INTO] tbl_name [col_name,...] &#123;VALUES|VALUE&#125;(&#123;expr|DEFAULT&#125;,...),(...),... col_name :指定需要插入数据的列名列表。 如果向表中所有列插入数据，则全部列名可省略，这样做是不安全的，如果表结构发生变化，数据将会错乱。 向表的部分列插入数据，对于没被指定的列，其规则如下： 对于具有标识（IDENTITY）属性的列，系统会自动生成序号值类唯一标识该列 具有默认值的列，通过 INSERT 中指定关键字 DEFALUT 将其设为默认值 没默认值的列，若允许空值，则通过 INSERT 指定 NULL 设为空，否则执行语句报错 对于类型为 TIMESTAMP 的列，系统自动赋值 AUTO_INCREMENT 属性列的值在表中其它列被赋值之 后生成，因此对表中其他列做赋值操作时，该属性列的引用只会返回数字 0 VALUES 或 VALUE：包含各列需要插入数据的清单。 数据的顺序必须与列的顺序相对应，该子句的值可以是： ‘expr’: 一个常量、变量或表达式，也可以是NULL，其值的数据类型须与列的数据类型一致，否则报错 ‘DEFAULT’：指定默认该列值为该列的默认值，前提该列已经明确指定了默认值，否则报错 123mysql&gt; INSERT INTO mysql_test.customers -&gt; Values(901,'张三','F','北京市')Query OK, 1 row affected(0.09 sec) 123mysql&gt; INSERT INTO mysql_test.customers -&gt; Values(0,'李四',DEFAULT,'北京市')Query OK, 1 row affected(0.09 sec) 上述中未给出待插入表的列清单，这样的操作是不安全的须改成：123mysql&gt; INSERT INTO mysql_test.customers(cust_Id,cust_name,cust_sex,cust_address) -&gt; Values(0,'李四',DEFAULT,'北京市')Query OK, 1 row affected(0.09 sec) 当表的结构发生改变, INSERT 语句任能正确执行。 INSERT…SETINSERT...SET 可以直接给表中的某些列指定对应的列值12INSERT [INTO] tbl_name SET col_name1=&#123;expr|DEFAULT&#125;,col_name2=&#123;expr|DEFAULT&#125;,.... 对于未指定的列为默认值123mysql&gt; INSERT INTO mysql_test.customers -&gt; SET cust_address='武汉',cust_name="李四"，cust_sex=DEFAULTQuery OK, 1 row affected(0.09 sec) 删除数据使用DELETE FROM tbl_name 可删除行数据 1234DELETE FROM tbl_name [WHERE where_condition] [ORDER BY ...] [LIMIT row_count] -WHERE：限定删除条件，从而删除特定的行，如不指定条件则删除指定表的所有行数据 ORDER BY：各行按指定顺序进行删除 LIMIT：告知服务器在控制命令被返回到客户端前被删除行的最大值 123DELETE FROM mysql_test.customers WHERE cust_name='王五'Query OK, 1 row affected(0.09 sec) 修改数据使用UPDATE 更新表中的数据 12345UPDATE tbl_name SET col_name=&#123;expr|DEFAULT&#125;[,col_name=&#123;expr|DEFAULT&#125;]... [WHERE where_condition] [ORDER BY ...] [LIMIT row_count] -WHERE：限定修改条件，从而修改特定的行，如不指定条件则修改指定表的所有行数据 ORDER BY：各行按指定顺序进行修改 LIMIT：限定被修改的行数 1234UPDATE mysql_test.customers SET cust_address = '北京',cust_sex = NULL WHERE cust_name='王五'Query OK, 1 row affected(0.09 sec) 查询数据数据查询是SQL 语言的核心功能，是使用最多的操作 SELECTSELECT 可以从数据库中检索、统计或输出数据执行过程是从数据库中选取匹配的特定行和列，并组成一个结果集放到临时表中返回。1234567891011SELECT [ALL|DISTINCT|DISTINCTROW] select_expr[,select_expr ...] FROM table_references [WHERE where_condition] [GROUP BY &#123;col_name|expr|position&#125; [ASC|DESC],...[WITH ROLLUP]] [HAVING where_condition] [ORDER BY &#123;col_name|expr|position&#125; [ASC|DESC],...] [LIMIT &#123;[offset,]row_count|row_count OFFSET offset&#125;] SELECT 子句用于指定输出的字段； （必选）FROM 子句用于指定数据的来源； （从表选择数据时使用）WHERE 用于指数据的选择条件；GROUP BY 用于对检索到的记录进行分组；（在按组计算聚合时使用）HAVING 用于指定组的选择条件；ORDER BY 用于对查询结果的排序； 必须按照SELECT 语句的语法格式所罗列的顺序格式查找数据。 如 HAVING 语句必须位于BROUP BY之后 OREDR BY 之前。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Database definition syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的表索引定义]]></title>
    <url>%2F2019%2F10%2F15%2Fmysql_index_definition%2F</url>
    <content type="text"><![CDATA[概述索引是 DBMS 根据表中的一列或若干列按一定的顺序建立的列值与记录行之间的对应关系表，方便 DBA 管理 索引是以文件的形式存储，DBMS 将一张表的所有所有保存在同一个索引文件中，需要占用磁盘空间，如果有大量索引，可能比数据文件更快达到最大的文件尺寸。 索引提高查询速度的同时，会降低更新表的速度。更新表中索引列上的数据时，索引会被自动更新，确保索引树与表中的内容完全保持一致，因此索引越多，则更新时长更长。 根据用途，索引在逻辑上大体分为三类 普通索引（INDEX）: 最基本的索引类型，没有任何限制。通常使用关键字 INDEX 或 KEY 唯一性索引（UNIQUE）：索引中所有的值只能出现一次，必须唯一 通常使用关键字 UNIQUE 主键（PRIMARY KEY）：主键是一种唯一性索引。创建主键时，必须指定关键字 PRIMARY KEY，且不能有空值，一般在创建表的时候指定，也可通过修改表的方式添加，每张表只能有一个主键 创建索引分别有三种方式创建索引 CREATE INDEX12CREATE [UNIQUE] INDEX index_name NO tbl_name(index_col_name,...) UNIQUE：指定创建唯一性索引，一张表可以创建多个索引，每个索引在该表中名称唯一 tabl_name: 数据库的表名 index_col_name ：关于索引的描述。格式为col_name[(length)][ASC|DESC] 索引的描述三个语法要素 col_name：指定要创建索引的列名， lenght:指定使用列的前length 个字符创建索引，有利于减小索引文件的大小 ASC|DESC指定按升序（ASC）或降序（DESC）排列，默认 ASC 1234mysql&gt;CREATE INDEX index_customers -&gt; NO mysql_test.customers (cust_name(3)ASC)Query OK, 0 rows affected (0.20 sec)Records:0 Duplicates:0 Warning:0 CREATE TABLE [CONSTRAINT [symbol]] PRIMARY KEY (index_col_name,...)：创建新表的同时创建该表主键 {INDEX|KEY}[index_name](index_col_name,...) ：创建表的同时创建该表索引 [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] (index_col_name,...):用于创建表时创建唯一性索引 [CONSTRATIN [symbol]] FOREIGN KEY[index_name] (index_col_name,...):创建表的同时创建外键 KEY: 关键字 INDEX的同义词 CONSTRAINT：为主键、UNIQUE键、外键定义一个名字，使用 CREATE TABLE 定义列选项时，可以通过直接在某个列定义后面添加PRIMARY KEY 添加主键，主键由多列组成的多列索引时，不能使用此方法。 12345678910111213mysql&gt; USE mysql_testDatabase changedmysql&gt; CREATE TABLE seller -&gt;( -&gt; seller_id int NOT NULL AUTO_INCREMENT -&gt; seller_name char(50) NOT NLULL, -&gt; seller_address char(50) null, -&gt; product_type int(5) NULL -&gt; sales int NULL -&gt; PRIMARY KEY (seller_id,product_type) -&gt; INDEX index_seller(salse) -&gt;)Query OK, 0 rows affected (0.20 sec) ALTER TABLE ADD {INDEX|KEY} [index_name] (index_col_name,...): 新增表列的同时添加索引 ADD [CONTRAIN [smbol]] PRIMARY KEY [index_name] (index_col_name,...)：新增列的同时添加主键 ADD [CONTRAIN [smbol]] UNIQUE [INDEX|KEY] [index_name] (index_col_name,...): 新增列的同时添加唯一性索引 ADD [CONTRAIN [smbol]] FOREIGN KEY [index_name] (index_col_name,...): 新增列的同时添加外键1234mysql&gt; ALTER TABLE mysql_test.seller -&gt; ADD INDEX index_seller_name(seller_name)Query OK, 0 rows affected (0.20 sec) Records: 0 Duplicates: 0 Warning: 0 查看索引使用 SHOW INDEX 查看索引语法：1234SHOW &#123;INDEX|INDEXES|KEYS&#125; &#123;FROM|IN&#125; tbl_name [&#123;FROM|IN&#125;db_name] [WHERE expr] 删除索引使用 DROP INDEX 或 ALTER TABLE 删除索引 DROP INDEX 1DROP INDEX index_name ON tbl_name ALTER TABLE DROP PRIMARY KEY 删除表中主键 DROP INDEX 删除对应索引 DROP FOREIGN KEY 删除外键 12345mysql&gt; ALTER TABLE mysql_test.customers -&gt; DROP PRIMARY KEY -&gt; DROP INDEX index_custormesQuery OK, 0 rows affected (0.20 sec) Records: 0 Duplicates: 0 Warning: 0]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Database definition syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的数据库定义语法]]></title>
    <url>%2F2019%2F10%2F14%2Fmysql_database_definition_syntax%2F</url>
    <content type="text"><![CDATA[创建数据库在MySQL中，使用 CREATE DATABASE 或 CREATE SCHEMA 语句创建数据库语法结构：123CREATE &#123;DATABASE|SCHEMA&#125;[IF NOT EXISTS] db_name[DEFAULT]CHARACTER SET [=]charest_name|[DEFAULT]COLLATE [=]collation_name []: 表示为可选|: 用于分隔花括号中的选项，表示任选一项语法db_name: 标识具体的数据库命名，必须符合操作系统文件夹命名规则，在MySQL中不区分大小写DEFAULT: 默认值CHAREST SET: 指定数据库字符集COLLATE: 指定字符集校对规则IF NOT EXISTS：创建数据库前进行判断，只有该数据库不存在时才能创建数据库 Example：创建名称位 mysql_test 的数据库1CREATE DATABASE mysql_test; 在次输入同样的命令 将会报错 可添加 IF NOT EXISTS 避免报错 选择数据库 MySQL 中创建数据库之后，不会自动使用新创建的数据库，可使用 USE 语句从当前环境切换换至新创建的数据库或其它数据库Example：1USE mysql_test; 修改数据库MySQL 中使用 ALTER DATABASE 或使用 ALTER SCHEMA 语句，修改数据库的相关参数语法结构：1ALTER &#123;DATABASE|SCHEMA&#125;[db_name] Example：修改已有数据库默认字符集和校对规则1234mysql&gt; ALTER DATABASE mysqle_test-&gt; DEFAULT CHARACTER SET gb2312-&gt; DEFAULT COLLATE gb2312_chinese_ci;... 删除数据库MySQL 中使用 DROP DATABASE 或 DROP SCHEMA 来删除数据库,其数据永久删除语法结构：1DROP &#123;DATABASE|SCHEMA&#125;[IF EXISITS]db_name Example：12DROP DATABASE IF EXISITS mysqle_test... 查看数据库MySQL 中使用 SHOW DATABASE 或 SHOW SCHEMA 来看可用数据库列表，只会列从出权限范围内的数据库语法结构：1SHOW &#123;DATABASE|SCHEMA&#125;[LIKE'pattern'|WHERE expr] LIKE: 匹配指定数据库名称WHERE: 指定数据库名称查询范围 Example：1SHOW DATABASE]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Database definition syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的表定义语法]]></title>
    <url>%2F2019%2F10%2F14%2Fmysql_table_definition_syntax%2F</url>
    <content type="text"><![CDATA[表定义只有成功创建数据库后，才能创建数据表，数据表是字段的集合，在表中数据按行和列的格式存储 创建表MySQL 使用 CREATE TABLE 创建表。其中有多个选择，主要由表创建定义（create definition）、表选项定义（table options） 和区分选项（partition options）等内容构成。 表创建定义：由表列的名字、列的定义集可能的一个空值声明、一个完整性约束或表索引项组成，表索引项主要定义表的索引、主键、外键等。 语法结构：1234567CREATE[TEMPORARY]TABLE tbl_name( 字段名|数据类型[列级完整性约束条件][默认值] [,字段名2 数据类型[列级完整性约束条件][默认值]] [,....] [,表级完整性约束条件])[ENGINE=引擎类型] Example:新建一个客户信息123456789101112mysql&gt; USE mysql_testDatabase changedmysql&gt; CRATE TABLE customers -&gt;( -&gt; cust_id INT NOT NULL AUTO_INCREMENT, -&gt; cust_name CHAR(50) NOT NULL, -&gt; cust_sex CHAR(1) NOT NULL DEFAULT 0, -&gt; cust_address CHAR(50) NULL -&gt; cust_contact CHAR(50) NULL -&gt; PRIMARY KEY(CUST_ID) -&gt;)Query OK, 0 rows affected(0.11 sec) 临时表与持久表TEMPORARY：表示临时表，如果不选用则为持久表。持久表一直存在，多个用户或应用程序可同时使用持久表，如果只需临时存放数据可添加 TEMPORARY 关键字临时表只能对创建它的用户可见，断开数据库连接时，表会自动清除 数据类型数据类型指系统中所允许的数据的类型。每列都应有适当的数据类型，来限制或允许该列的数据。 建表时必须为每列指定正确的数据类型及数据长度 （CHAR(50)） MySQL 主要数据类型: 数值类型：整型 int、浮点 double、布尔 bool 日期和时间类型：日期型、时间戳 timestamp、时间型 time 字符串类型：定长字符类型char、可变长字符类型varchrar 空间数据类型:单个几何类型 GEOMETRY等 关键字 AUTO_INCREMENTAUTO_INCREMENT: 表中数据类型为整型的列设置自增属性 （++i）,从当前指或 1 开始，表中只能有一个 AUTO_INCREMENT。 当一个表列被指定为 AUTO_INCREMENT 后，其值可被覆盖，即可在表数据插入语句中为该列指定一个值（必须唯一），则该值将替换系统自动生成的值，后续增量基于该插入的值 指定默认值DEFAULT:用于指定MySQL在未给值的情况下默认的值（DEFAULT 0） 如果未指定默认值，则自动为其分配一个值，如若该列可取值NULL，则默认NULL，若定义 NOT NULL，则默认取决于该列的类型： 一个没有声明 AUTO_INCREMENT 列 为数字类型，默认 0 一个 AUTO_INCREMENT 列 默认为顺序中的下一个值 对于除 TIMESTAMP 以外的日期和时间类型，默认为该类型适当的’零’值、 对于表中第一个 TIMESTAMP 列，默认值为当前日期和时间 NULL值NULL：没有值或缺值，允许NULL的列，插入行时可以不给该列的值；不允许NULL值的列，则该列必须有数据NULL 和 &#39;&#39;是不对等的 NOT NULL 列中允许&#39;&#39; 不允许 NULL 主键PRIMARY KEY :指定主键，主键必须唯一且不能为NULL， 如果是单列，值必须唯一，如果是组合列，则其组合的值必须唯一 更新表通过使用 ALTER TABLE 来修改数据库 ADD[COLUMN]：新增表列，可增多列使用逗号分隔即可Example:1234mysql&gt; ALTER TABLE mysqle_test.customers -&gt; ADD COLUMN cust_city char(10) NOT NULL DEFAULT'ShenZhen' AFTER cust_sex;Query OK,0 rows affected(0.61 sec)Records:0 Duplicates:0 Warning:0 AFTER：将新增的列添加到cut_sexl 列之后FIRST：将新增的列添加到表的第一列 若使用上述关键字则将新增的列添加至表最后 类似的 可以使用 ADDPRIMARY KEY 、ADDFOREIGN KEY 、ADD INDEX 添加对应的 主键、外键、索引 CHANGE[COLUMN]: 修改表中列的名称或数据类型，可修改多列使用逗号分隔即可 1234mysql&gt; ALTER TABLE mysqle_test.customers -&gt; CHANGE COLUMN cust_sex sex char(1) NULL DEFAULT 'M'Query OK,0 rows affected(0.66 sec)Records:0 Duplicates:0 Warning:0 如果将数据类型更换，可能会丢失该列原有的数据，如果视图改变的数据类型于原有的数据类型不兼容，则SQL命令不会执行，且抛出错误。再兼容的情况下，该列的数据可能会被截断，如：一列的数据类型为 varchart(10),改为char(1),则该列中的数据’ShenZhen’会变为’S’ ALTER [COLUMN]: 修改或删除指定列的默认值 1234mysql&gt; ALTER TABLE mysqle_test.customers -&gt; ALTER COLUMN cust_city SET DEFAULT 'ShangHai'Query OK,0 rows affected(0.36 sec)Records:0 Duplicates:0 Warning:0 MODIFY [COLUMN]: 修改指定列的数据类型，通过 ‘FIRST’ 或 ‘AFTER’ 修改列的位置 1234mysql&gt; ALTER TABLE mysqle_test.customers -&gt; MODIFY COLUMN cust_name char(30) FIRSTQuery OK,0 rows affected(0.20 sec)Records:0 Duplicates:0 Warning:0 DROP [COLUMN]: 删除列，该列所有数据一并删除 1234mysql&gt; ALTER TABLE mysqle_test.customers -&gt; DROP COLUMN cust_cityQuery OK,0 rows affected(0.42 sec)Records:0 Duplicates:0 Warning:0 同样 可使用 DROP PRIMARY KEY 、DROP FOREIGN KEY、DROP INDEX 删除对应的主键、外键、索引 RENAME[TO]:表重命名123mysql&gt; ALTER TABLE mysqle_test.customers -&gt; RENAME TOQuery OK,0 rows affected(0.42 sec) 重命名表除了 ALTER TABLE 中的 RENAME TO 修改表名，还可通过 RENAME TABLE 来修改单张和多张表（以逗号分隔）1mysql&gt; RENAME TABLE mysql_test.back.customers TO mysqle_test.customers 删除表DROP[TEMPORARY]TABLE[IF EXISTS]删除一个已存在的表,可以删除多张表，前提操作人必须有权限，但是操作人在该张表上的权限不会被删除 查看表 SHOW [FULL] TABLES [{FROM|IN}db_name] [LIKE&#39;pattern&#39;|WHERE expr]： 显示指定数据库中所有表名 Example：123456mysql&gt; USE mysql_testDatabase changedmysql&gt; SHOW TABLES: Tables_in_mysql_test customers 1 row in set &lt;0.01 sec&gt; SHOW [FULL] COLUMNS {FROM|IN}tb_name[{FROM|IN}db_name] 或 {DESCRIBE|DESC} tbl_name[col_name|wild]: 显示指定数据库表结构。 MySQL 支持使用 DESCRIBE 代替 SHOW COLUMNS FROM 来查看表结构 Example:1234567mysql&gt; DESC mysql_test.custormesField Type Null key Default Extracust_id int&lt;11&gt; NO PRI NULL auto_incrementcust_name char&lt;50&gt; NO Nullcust_sex int&lt;1&gt; NO 03 row in set &lt;1.56 sec&gt;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Table definiton syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL和MySQL 基础]]></title>
    <url>%2F2019%2F10%2F09%2FSQL_basic_operations%2F</url>
    <content type="text"><![CDATA[SQL概述Struture Query Langue （结构化查询语言，SQL），于1974年 Boyce 和 Chamberlin 提出。其已成为关系数据库的标准语言，是一种数据库查询和程序设计语言，用于存取数据及查询、更新和管理关系数据库系统，具有数据库定义、数据操作和数据控制等功能 特点 SQL不是特点的数据库专有语言，几乎所有重要的关系数据库管理系统都支持 SQL。 SQL简单易学，SQL语句不区分大小写。 组成SQL集数据查询（Data Query）、数据定义（Data Definition）、数据操纵（Data Manipulation）和数据控制（Data Control）四大功能于一体 数据定义语言（DDL）主要用于对数据库及数据库中的各种对象进行创建、修改、删除等操作。数据库对象主要为 表、默认约束、规则、视图、触发器、存储过程等 关键字： CREATE: 创建数据库或数据库对象 ALTER：修改数据库或数据库对象 DORP： 删除数据库或数据库对象 数据操作语言（DML）主要用于操作数据库中的各种对象，主要是检索和修改数据 关键字： SELECT：从表或视图中检索数据，使用最为频繁 INSERT：将数据插入到表或视图中 UPDATE：修改表或视图中的数据，可修改单行，也可修改多行 DELETE：删除表或视图中的数据，可跟据条件删除指定数据 数据控制语言（DCL）用于安全管理（权限） GRANT：授予权限 REVOKE：回收权限 MySQL概述MySQL是一个关系数据库管理系统（RDBMS),具有客户/服务器体系结构，由瑞典MySQL AB公司开发。 具有体积小、速度快、开源、遵循GPL（GNU通用公共许可证）等特点 MySQL在SQL标准的基础上增加了部分扩展的语言要素包括常量、变量、运算符、表达式、函数、流程控制语句和注解等。 运算符 算术运算符 位运算符 比较运算符 逻辑运算符 + &amp;（位与） = NOT 或 ! （逻辑非） - l（位或） &gt; AND 或 &amp;&amp;（逻辑与） * ^（位异或） &lt; OR 或 ll（逻辑或） / ~（位取反） &gt;= XOR（逻辑异或） % &gt;&gt;（位右移） &lt;= &lt;&lt;（位左移） &lt;&gt;（不等于）或 !=（不等于） &lt;=&gt;（相等或都等于空） 内置函数 数学函数，如ABS()、SORT() 聚合函数，如COUNT() 字符串函数，如ASCII()、CHAR() 日期和时间函数，NOW()、YEAR() 加密函数，ENCODE()、ENCRYPT() 控制流程函数，IF()、IFNULL() 格式化函数，FORMAT() 类型转换函数，CAST() 系统信息函数，USER(),VERSION() 数据定义SQL 的数据定义功能包括数据库模式、表、索引和视图的定义SQL 标准不提供修改数库模式定义和修改视图定义的操作，如需修改对象，可先删除再创建，或通过RDBMS提供的扩展语句实现SQL 标准不提供索引相关的语句 数据库模式定义对数据库的增、删、改、查、选择等操作]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL basis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系数据库设计方法]]></title>
    <url>%2F2019%2F10%2F08%2Frelational_database_design_method%2F</url>
    <content type="text"><![CDATA[概念结构设计方法（概念模式）概念模式通常采取自顶向下法（实体分析法），通过两个步骤完成概念设计： 1.建立局部信息结构2.将局部信息合并为全局信息结构并优化，使用 E-R 模型作为概念模型的描述工具 E-R 图的表示方法概念结构设计是将需求分析得到的用户需求抽象为信息结构（概念模型）的过程，通常使用E-R图作为建模工具具体由三部分组成： 实体型：用矩形表示，矩形内写明实体名称 属性：用椭圆表示，用无向边将其与响应实体连接起来 联系：用菱形表示，菱形内写明联系的名称，并用无向边分别和有关实体连接，同时无向边旁备注联系类型，如果联系也有属性，则同样使用无向边连接。 实体间的联系实体间的联系通常指不同实体型的实体集之间的联系一般有三种情形 两个实体型之间的联系设两个实体集 A、B，两个实体型间的联系可分为 一对一、一对多、多对多 1&gt; 一对一（1:1） 对于 A 中每一天实体， B 中最多有一个与之联系，反之亦然，则 A与B 记为 1:1 2&gt; 一对多（1:N）对于 A 中每一个实体，B 中有N个实体与之联系，反之，B的每一个实体，A中至多有一个实体与之对应，则记为 1:N 3&gt; 多对多（M:N） 对于 A 中每个实体，B 中有N个实体与之联系，反之 B 中每个实体，A 中有M个实体与之联系，记为 （M:N） example： graph TB A[系] --1--> B{隶属} B --1--> C[系主任] a[班级] --1--> b{包含} b --N--> c[学生] q[学生] --M--> w{选课} w --N--> e[课程] 两个实体以上的实体型之间的联系同两个实体之间的联系一样存在以上三种联系 example： graph TB A[课程] --1--> B{讲授} B --M--> C[教师] B --N--> D[参考书] a[供应商] --M--> b{供应} b --N--> c[项目] b --P--> d[零件] 单个实体型内的联系同一个实体集内的各实体间也可以存在以上三种联系 example： graph LR A[职工] --1--> B{领导} B --N--> A 局部信息结构设计局部信息结构设计：根据需求分析报告中标明的不同用户视图范围所建立的满足该范围内用户需求的信息结构。通常为五个步骤 确定局部范围主要依据需求分析报告中标明的用户视图范围来确定局部范围；基本准则：部门和功能相对独立，同其他局部范围相互影响较小，且实体个数适量。 选择实体在确定的局部范围内选择一些合适的信息单位作为局部信息结构的基本实体 选择实体的关键字属性实体的存在依赖于关键字的存在。关键字属性确定后，实体的非关键字就易于确定了。 确定实体间联系数据间的联系必须在概念设计时确定。分析实体间是否存在联系的方法：将局部范围内的实体逐一取出与该范围内的其他实体试行匹配，能否找到与两个参加试匹配的实体都有关的问题或同一任务同时使用到参与试匹配的两个实体，存在则它们之间存在联系。 确定实体属性属性分为标识属性和说明属性两类。标识属性作用实体的关键字，说明属性作用描述实体的一般特征 确定说明属性的基本原则: 说明属性的存在和使用依赖于标识属性。值为单值，不允许嵌套属性和重复组的现象出现在实体中。 全局信息结构设计将所有局部信息结构合并为一个全局信息结构。其必须是所有局部信息结构的全面准确的映像，形成的全局信息结构仍能实现各局部信息结构能实现的需求 合并是在假设各局部信息结构都说完全一致的前提下进行，即各局部信息结构能满足对于的需求，其内部不存在需要合并的成分。 由于局部信息结构仅以满足局部应用需求为目标，各个局部信息结构对同一数据对象因各自应用特征不同而可能采取不同处理，及每个开发人员对数据语义理解的差别等待，合并中会出现各种各样的冲突，需要合理的解决冲突才能进行合理的合并产出一个合理的全局信息结构。因此合并是一个不断发现和解决冲突的过程。 冲突的种类属性冲突属性值域的冲突，如属性值的类型、取值范围、取值集合的不同属性取值单位冲突，如某个属性有的值用 M 为度量单位，有的用 CM 为度量单位 命名冲突同名异义：不同意义的实体类型或联系类型名在不同的局部应用中具有相同的名字异名同义: 相同意义的实体类型或联系类型名在不同局部应用中具有不同的名字 结构冲突同一对象在一个局部E-R图中作为实体，在另一个局部E-R途中作为属性同一实体在不同E-R图中属性个数和类型不同实体之间的联系在不同的E-R图中是不同的类型 解决方法对于属性、命名冲突，通常采用讨论、协商等行政手段解决对于结构冲突，须通过认真分析，采用技术手段加以解决 一个好的全局E-R模型除能反映用户功能需求之外，实体类型个数尽可能少，实体类型所含属性尽可能少，实体间联系无冗余。 全局E-R模型的优化可通过上述三个条件来完成 逻辑结构设计方法逻辑结构设计是将概念模型转换为具体的 DBMS 所支持的逻辑数据模型，即将E-R图转换为关系模型、对关系数据模型进行优化、设计面向用户的外模式。 E-R图转换为关系模型转换原则 一个实体型转换为一个关系模式。实体的属性转换为关系的属性，实体码作为关系码 一个一对一（1:1）联系转换为一个独立的关系模式，可与任意一端对应的关系模式合并。该联系相连的各实体码及联系本身的属性转换为关系的属性，每个实体码为关系候选码 一个一对多（1:N）联系转换为一个独立关系模式，可与N端对应的关系模式合并。同样相连的各实体码及联系本身属性均转换为关系的属性，关系的码为N端实体的码 一个多对多（M:N）联系转换为一个关系模式，与该联系相连的各实体码及联系本身的实现转换为关系属性，关系的码为各个实体码的组合 三个及三个以上实体间的一个多元联系转换为一个关系模式。与该多元联系相连的实体码及联系本身的属性转换为关系的属性，关系码为各个实体的组合 相同码的关系模式可合并 数据模型的优化关系数据模型的优化通常参考关系规范化理论 优化方法 确定各属性间的函数依赖关系 对于各关系模式之间的数据依赖进行极小化处理，消除冗余的联系。 判断每个关系模式的范式，根据实际需要确定最合适的范式 按需求分析阶段得到的处理要求，分析模式对于应用环境是否合适，去掉是否要对某些模式进行合并或分解 设计用户子模式将概念模型转换为全局逻辑模型后，可根据局部应用需求，利用视图设计更符合局部用户需要的用户外模式定义数据库全局模式主要从系统时间效率、空间效率、以为会角度出发，用户外模式与模式是相对独立的，因此外模式可注重考虑用户的习惯于方便。 可通过视图机制在设计用户视图时，重新定义某些属性的别名 可对不同级别的用户定义不同的视图，保证系统安全性 简化用户对系统的使用。 物理设计方法 建立索引，通过 DBMS 提供的有关命令实现（有静态（频率高才用）和动态两种方式） 建立聚集，将相关数据集中存放的物理存储技术]]></content>
      <categories>
        <category>Database basis</category>
      </categories>
      <tags>
        <tag>database design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计]]></title>
    <url>%2F2019%2F09%2F22%2Fdatabase_design%2F</url>
    <content type="text"><![CDATA[概叙 针对具体的应用场景，使用现有的 DBMS 构建适合的数据库模式，建立数据库及其应用系统，使之能有效的收集、存储、操作和管理数据，满足实际业务中各类用户的应用需求、信息需求和处理需求，这个过程称为数据库设计。 1.数据库生命周期，从演变过程的角度分为两个阶段：分析与设计阶段 和 实现与操作阶段 1.1 分析与设计阶段细分为四个环节：需求方分析、概念设计、逻辑结构设计和物理结构设计。1.2 实现与操作阶段细分为3个环节：数据库的实现、操作与监督和修改与调整。 数据库设计主要以满足应用的功能需求和良好的数据库性能为目标。 数据库设计是从用户对数据的需求出发，研究并构造数据库的过程，包括两个方面：数据库结构设计（概念、逻辑和物理结构设计）和行为设计（对数据库的操作） 数据库设计的优劣，会直接影响当前的应用、数据库应用过程中的维护和生命周期，为使数据库设计更加合理，需要一个有效的指导原则（方法），大体分为三类：直观设计法、规范设计法和计算机辅助设计法。 4.1 直观设计法：利用设计者的经验和技巧来设计数据库模式。此方法缺乏科学理论指导，质量很难保证。4.2 规范设计法：又细分为 新奥尔良设计法、基于 E-R 模型的数据库设计法和基于第三范式的设计方法。4.2.1 新奥尔良设计法：将数据库设计为四个阶段（需求分析、概念结构设计、逻辑结构设计和物理结构设计，注重结构设计）4.2.2 E-R模型数据设计法：在需求分析的基础上用E-R图像构造一个反应现实世界实体之间联系的企业模式，然后将模式转换成某一特定 DBMS 下的概念模式。4.2.3 基于第三范式的设计方法：在需求分析的基础上先确定数据库的模式，属性及属性间的依赖概念性，进行模式分解，规范成若干个第三范式关系模式的集合。 计算机辅助设计方法：以领域专家的知识或经验为主导，模拟某一规范化设计的方法，通常通过人机交互的方式来完成设计的某些过程。 数据库设计的过程六大阶段：需求分析 -&gt; 结构设计（概念、逻辑和物理结构设计）∪ 行为设计（功能、事务和程序设计） -&gt; 数据库实施（加载数据库数据和调试运行应用程序） -&gt; 数据库运行和维护 graph LR A(需求分析) --> B(结构设计) A --> C(行为设计) B --> D(数据库实施) C --> D(数据库实施) D --> E(数据库运行与维护) 数据库设计过程实际是一个反复修改、反复设计的迭代过程。 数据库设计的基本步骤需求分析 需求分析是数据库设计的起点，直接影响后续阶段的设计和数据库系统能否被合理使用。分四个步骤：确定数据库范围、分析数据应用过程、收集与分析数据和编写需求分析报告。需求分析的目标是了解与分析用户的信息及应用处理的要求，并将结果按一定格式整理形成需求分析报告。 数据库设计人员进行需求分析基本方法：听取数据库应用部们人员的报告，并沟通。同时需求分析人员提交一份需求调查表，该表内容主要包括调查的内容和要求提供资料的格式，应用部门的业务人员可根据该表进行准备和提交材料；此外数据库设计人员还需查阅原始资料，及跟班作业等 确定数据库范围范围指数据库应支持哪些应用功能。该范围应尽可能的考虑较为广泛的应用部门或领域，充分满足用户的应用功能要求，有效地利用计算机设备及数据库系统的潜在能力。同时还应尽可能考虑将来的应用需求，提高数据库应变能力，避免以后频繁修改。 满足上述要求的数据库是复杂而庞大的，由于诸多因素的影响，设计人员当首先考虑支持用户工作需要所必须的应用要求。 应用过程分析此过程分析指了解并分析数据与数据处理间的关系。在确定数据库范围后，设计人员应逐次地了解分析每一部门或功能要用到哪些数据、数据的使用顺序、对数据作何处理和处理的策略及处理结果等 过程分析的结果是数据库结构设计的重要依据。 收集与分析数据 数据收集与分析是指了解并分析数据的组成格式及操作特征，每个数据元素的语义及关系等，并将它们收集起来整理归档。 可从三个方面展开工作：静态结构、动态结构及数据约束。 静态结构静态结构指不施加应用操作于其上时数据的原始状况。通过数据分类表和数据元素表来说明 1）数据分类表用于数据的总体描述。对于每一客观存在的具有独立意义的单类数据单位应给出其名称、用途、编制者及使用者等说明： 数据ID 数据名 用途 主人 用户 来源 去向 存档时间 数据量 2）数据元素表数据元素表指通常意义下的数据项或属性。数据分类表中的每一类数据的所有数据元素名称、类型、长度、意义及算法等都应在数据元素表中进行详尽说明。格式如下： 数据ID 数据元素ID 元素名 意义 类型 长度 算法 备注 类型：描述元素的数据特征（字符串、整数型、实数型） 动态结构动态结构指将应用操作施加于数据之上的数据状况，可通过任务分类表和数据操作特征表进行说明 1）任务分类表根据对数据流程图的分析，可将业务处理过程划分不同任务。 一个任务指为完成某一特定处理功能的相对独立的操作序列。格式如下： 任务ID 名称 功能 类型 主人 用户 执行日期 频率 操作过程 备注 类型：输入、查询、制表、统计、修改、删除等 2）数据操作特征表数据操作特征表用来描述任务和数据之间的关系，包括不同任务对数据执行不同操作的频率。一条任务或数据分类表须建立对应的操作特征表。格式如下： 任务ID 数据ID 建立 查询 插入 修改 删除 数据量 数据约束数据约束指使用数据时的特殊要求。主要有四个方面： 数据的安全保密性，针对不同类型数据的操作权限。 数据完整性，指数据正确性的约束和验证准则，及一致性保护的要求 响应时间，主要指某些特点应用要求的数据存取时间限制 数据恢复，主要指转储及恢复的时机与范围等 编写需求分析报告需求分析报告要求包括6个方面（数据库的应用功能目标（明确数据库应用范围及应达到的应用处理功能）、标明不同用户视图范围）、应用处理过程需求说明、数据字典、数据量、数据约束： 需求说明 要求有数据流程图，反映应用部门原始业务处理的工作流程 任务分类表，标明不同任务的功能及使用状况 数据库特征表，标明任务和数据间的联系及不同数据的不同澳洲特征与执行频率 操作过程说明书，根据流程图、任务分类表及数据特征表等，标明各个任务的主要逻辑执行步骤 数据字典数据字典是DBS中存储三级结构定义的数据库，通常指数据库系统中各类数据详细描述的集合。功能是存储和检索各种数据描述（元数据），提供对各类数据的集中管理，是一种数据分析、系统设计和管理的有力工具。 数据字典包括数据分类表、数据元素表和各类原始资料（所有单据、报表、文件及设计所需的原始资料，并根据数据分类表的数据ID统一分类编号）。 概念结构设计概念设计结构是在需求分析中产生的需求分析报告基础上按照特定的方法设计满足应用需求的用户信息结构，通常称为概念模型 概念模型独立于任何软件硬件，主要目标是最大限度的满足应用需求，完全不顾忌软件硬件的限制，尤其是DBMS 的限制，它是一个符合用户要求的趋于理想化的信息结构，常用方法有实体分析法（自顶向下）和属性综合法（自顶向上） 逻辑结构设计逻辑模型是将概念模型转换为等价的、并为特定 DBMS 所支持数据模型的结构。主要有层次、网状、关系模型 逻辑模型的输入与输出信息逻辑模型是在需求分析与概念模型的基础上进行的，主要提供如下输入信息： 独立于特定 DBMS 的概念模型。 有关响应时间、安全保密性、数据完整性及恢复方面的要求说明，包括数据的一致性的规则说明。 数据量及使用频率 特定 DBMS 特性，包括其支持的数据模型及数据定义语言的说明。 输出信息： 一个特定 DBMS 支持的模式（概念模式） 一个或多个外部视图（子模式） 物理设计说明，主要有存入数据库中的数据量、使用频率及响应时间要求 程序设计说明，在需求分析的基础上，根据逻辑模型，编制各程序名、执行逻辑步、存取数据的名、顺序及操作特征（读、写、改、删）的说明。 逻辑结构设计的步骤graph LR A(概念设计) --> B(模型转换) B --> C(子模型设计) B --> D(应用程序设计说明) C --> E(设计评价) D --> E E --> F(物理设计) 模型转换：将概念模型等价转换为特定 DBMS 支持的关系、层次或网站模型 子模式设计的目标是抽取或导出模式的子集，以构造不同用户使用的局部数据逻辑结构 应用程序说明是为可实际运行的应用程序设计提供依据与指导，作为设计评价的基础 设计评价任务是分析并检验模式及子模式的正确性与合理性。 物理设计物理设计指对于一个给定的数据库逻辑结构，研究并构造物理结构的过程，主要是确定数据库在存储设备上的存储结构及存储方法， 因 DBMS 不同可能包括建立索引和聚集等待。 数据库实施本阶段需要完成 加载数据、应用程序设计和数据库试的运行工作 加载数据：将符合要求的初始数据装载到数据库中，包括数据的收集、分类、整理校验和输入等过程 数据库运行和维护经过试运行后，确认系统无故障或暂未发现故障时，系统才可投入生成实际中运行，随着应用的深入和拓展，可能会暴露原未发现的问题，也有可能对数据的不断增、删、改使系统的物理结构变坏或存取效率下降，或者需要拓展应用功能，这些都需要开发人员做好维护工作。]]></content>
      <categories>
        <category>Database basis</category>
      </categories>
      <tags>
        <tag>database design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系数据库的规范化理论]]></title>
    <url>%2F2019%2F09%2F19%2Fnormalization_theory%2F</url>
    <content type="text"><![CDATA[概叙规范化理论研究的是关系模式中各属性间的依赖关系及对其概念性模式性能的影响，它提供了判断关系模式优劣的理论标准，能帮助数据库设计人员预测可能出现的问题。 规范化理论主要应用于数据库设计中的概念设计阶段。 关系模式中可能存在的冗余或异常问题关系模式可能存在如下问题： 数据冗余 数据冗余指同一数据被反复存储的情况。如在一个供应商关系模式中，一个供应商每供应一种货物，其地址就存储一次，如果供应成千上万种货物，地址就会反复成千上完成。 更新异常数据冗余将导致存储空间的浪费和潜 在数据不一致性及修改麻烦问题。如供应1000种货物的供应商的地址信息发生变化，那么需要对这些供应商的地址进行逐一修改，这样就有可能在一个元组中修改了地址，而没修改该另一个元组中同一供应商的地址，从而导致与实际情况不相符 插入异常插入异常指应该插入到数据库中的数据不能只需插入操作的情形。 删除异常数据的删除操作异常指不应该删除的数据被删除的情形。 产生上述问题的原因，及消除这些问题的方法，都与数据库依赖的概念密切相关。数据依赖是可以作为关系模式的取值的任何一个关系所必须满足的一种约束条件，是通过一个关系中各个元组的某些属性值之间的相等与否体现出来的相互关系。 函数依赖与关键字函数依赖指关系中属性间的对应关系 定义设R 为任一给定关系，如果对于 R 中属性 X 的每个值，R 中的属性 Y 只有唯一值与之对应，则称 X 函数决定 Y （Y 函数依赖于 X） 记作 $X\to Y$。 X称为决定因素example:表 T1 学号（SNO） 姓名（SNAME） 性别(SSEX) 宿舍(SROOM) 0001 张三 男 N101 0002 王二 男 N101 0003 李梅 女 C101 T1中存在如下函数依赖：$SNO\to SName$$SNO\to SSEX$$SNO\to SROOM$ T1 中的函数依赖关系仅当SNO作为决定因素时存在 函数依赖是针对关系的所有元组，只要有一个元组的属性值不满足函数依赖的定义，则相对应的依赖就不成立。 完全函数依赖设 R 为任一给定定关系，X、Y 为其属性集， 若$X\to Y$,且 X 中的任一真子集 $X^{‘}$都有 Y 函数不依赖于 $X^{‘}$，则 Y 完全依赖于 X Example： 表 T2 学号（SNO） 课程编号（CNO） 课程名（CTITLE） 授课老师（INAME） 成绩（GRADE） 0001 201 语 张三 80 0002 202 数 李四 90 0003 203 英 王五 60 T2 中，函数依赖：$（SNO,CNO）\to GRADE$ ，它为完全函数依赖。因为其中单个属性 SNO/CNO 都不能单独决定GRADE 部分函数依赖设 R 为任一给定关系， X、Y 为其属性集合，若$X\to Y$,且 X 中存在某个真子集 $X^{‘}$满足 $X^{‘}\to Y$ ，则 Y 部分函数依赖于 X。 T1 中 函数依赖$（SNO,SNAME）\to SSEX$,而其中$SNO\to SSEX$ ,那么 SSEX部分函数依赖于（SNO,SNAME） 传递函数依赖设 R 为任一给定关系， X、Y、Z为不同属性子集，若$X\to Y$,X函数不依赖于Y，$Y\to Z$,则 $X\to Z$,即 Z传递函数依赖于X。 Example： 有一个关系模式 T2（BNO(书号),PNAME（出版社名）,PADDRESS（出版社地址））,一种书对应一个唯一的书号，且只能为某一出版社出版；一个出版社只有唯一名称和地址，但一个出版社可出版多种书。那么该关系中存在函数依赖：$BNO \to PNAME$, $PNAME\to PADDRESS$, PNAME函数不依赖于BNO，所以$BNO\to PADDRESS$ 严格的关键字定义设 R 为任一给定关系，U 为所有属性集合， X 为 U 的子集，若 U 完全依赖于 X，则 X 为 R 的候选关键字。 范式与关系规范化过程关系数据库中的关系需要满足一定的要求，不同程度的要求称为不同的范式（Normal Form,NF）。 第一范式 1FN设 R 为任一给定关系， R 中每个列和行的交点处的取值都是不可再分的基本元素，则 R 为 1FN。 1FN是范式的最低要求,是一个不含重复组的关系，不存在嵌套结构。 表 T3 学生选课信息表 SNO CNO CTITLE INAME IPLACE GRADE 1027 C01 操作系统 王五 东01 100 1028 C02 数据库 刘备 东02 91 1029 C01 操作系统 王五 东01 88 C03 人工智能 曹操 东03 100 1030 C04 C语言 刘备 东02 97 T3关系是一个非归范式关系，因为 SNO属性中 1029出现重复的组，可将T3转化为 1FN T4 1FN SNO CNO CTITLE INAME IPLACE GRADE 1027 C01 操作系统 王五 东01 100 1028 C02 数据库 刘备 东02 91 1029 C01 操作系统 王五 东01 88 1029 C03 人工智能 曹操 东03 100 1030 C04 C语言 刘备 东02 97 第二范式 2FN设 R 为任一给定关系，如果 R 为 1FN，且所有非主属性都完全函数依赖于候选关键字，则 R为 2FN。 Example： T4 中存在着冗余度高、插入和删除操作异常等问题，CTITLE 中都某一课程被多人选修，那么对应的授课老师和地址将反复存储（数据冗余）；若新增一门课程，而没人任何同学选修，则这们课程将无法存储（插入异常）；如果将最后一元组删除，同时会删除C语言这门课程及相关老师和地址等信息（删除异常）； 存在这些问题的原因在于仅有非主属性 GEEADE 完全 依赖于（SNO,CNO）,其他非主属性都只依赖于 CNO ，对于主键（SNO,CNO）为部分依赖 通过分解 T4 将部分函数依赖分解成完全函数依赖，得到 2FNT4.1 SNO CNO GRADE 1027 C01 100 1028 C02 91 1029 C01 88 1029 C03 100 1030 C04 97 T4.2 CNO CTITLE INAME IPLACE C01 操作系统 王五 东01 C02 数据库 刘备 东02 C03 人工智能 曹操 东03 C04 C语言 刘备 东02 此时的 T4.2依然存在插入、删除操作及修改麻烦等异常问题。如:将一位新老师插入 T4.2表中，但这位老师暂无任何教学工作，因缺关键字 CNO的值而不能执行插入操作。 原因在于：T4.2 关系中存在非主属性对主属性的传递函数依赖，须进一步分解。 第三范式 3FN设 R 未任一给定关系， 如 R 未 2FN，且每一个非主属性都不传递依赖于候选关键字，则 R 为3FN。 Example： 通过分解 T4.2 将传递函数依赖分解成完全函数依赖，得到 3FN T4.2.1 CNO CTITLE INAME C01 操作系统 王五 C02 数据库 刘备 C03 人工智能 曹操 C04 C语言 刘备 T4.2.2 INAME IPLACE 王五 东01 刘备 东02 曹操 东03 BCNF通常 3FN 大多数能解决插入和删除操作异常的问题，数据冗余也能得到有效控制。为解决3FN有时出现的操作问题，R.F.Boyce和E.F.Codd 提出 改进范式 BCNF 设 R 为任一给定关系，X、Y 为属性集，F为其函数依赖集， 若 R 为 3NF，且 F 中所有函数依赖 $X\to Y$ (Y 不属于 X)中 X 必须包含候选关键字，则 R 为 BCNF。 即 R中每一函数依赖的决定因素X（可为单一属性或组合属性） 都包含 候选关键字，则 R 为 BCNF。 当所有属性集合为候选关键字时依然会存在操作异常和数据冗余等问题Example： 表 T5 SNO CTITLE TNAME S01 操作系统 王五 S02 人工智能 曹操 S02 数据库 刘备 S03 数据库 孙权 T5中新增一门课程和一位老师的数据时，须至少有一位学生选修该课且指导老师已被分配才能插入T5中。 此时可通过公共的函数依赖将 T5分解位为 T5.1 和 T5.2 T5.1 SNO TNAME S01 王五 S02 曹操 S02 刘备 S03 孙权 T5.2 TNAME CTITLE 王五 操作系统 曹操 数据库 刘备 人工智能 孙权 C语言]]></content>
      <categories>
        <category>Database basis</category>
      </categories>
      <tags>
        <tag>normalization theroy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系数据模型要素三 关系完整性约束]]></title>
    <url>%2F2019%2F09%2F19%2Fintegrity_constraint_of_relational%2F</url>
    <content type="text"><![CDATA[概述 数据完整性指数据库中数据的正确性、相容性和一致性。包括现实世界中的应用需求的完整性。数据的完整性由完整性规则来定义。 关系模型的完整性规则是对关系的某种约束，提供一种手段来保证用户对数据库的修改时不会破坏数据库中数据的完整性。保证数据是有意义的。 关系模型分三类约束：实体完整性约束、参照完整性约束和用户自定义完整性约束。 前两者是必须满足的条件，称作关系的两个不变性。由DBMS自动支持 实体完整性约束（Entity Integrity Constraint）此约束指关系的主属性，主码不能为空，在关系数据库系统中，一个关系对应一张表，实体完整性指在数据存储数据的表中，主键/码不能取控值 NULL 参照完整性约束 （Referential Integrity Constraint）现实世界中实体之间往往存在某种联系，在关系模型中这种联系通过关系来描述 参照完整性约束就说定义外码和主码之间的引用规则，是对关系间引用数据的一种限制。若属性（属性组）X 是基本关系 R 的外码，它与基本关系 S 的主码 Y 对应，那么 R 中每个元组在 F 上的值要么取 NULL，要么等于 S中对应元组的主码值。 R 和 S 可以是不同的关系，也可以是同一关系。 如：12教师（职工号，姓名，性别，系编号）系（系编号，系名，办公地点） 上述两个关系之间存在属性的引用，系编码既是 系 关系的主码又是教师关系的外部码。那么教师 关系中系编码属性的取值需要参照 系关系中系编码的值或为 NULL。 用户定义完整性约束 （User-defined Integrity constraint）此约束针对某一应用环境的完整性约束条件，反映了某一具体应用所涉及的数据应满足的要求。关系模型提供定义和检验的机制，此类规则一般在建立数据库表的同时进行定义，如果某些条件未建立在库表一级，则应在各个模块的具体编程中通过程序进行检查和控制。 关系模型完整性约束检验 重点在对数据库进行修改时须检验是否满足对上述三类完整性约束 插入操作首先检查实体完整性约束，检查插入行在主码属性上的值是否已存在，不存在，可以执行插入，否则不可插入。再检查参照完整性约束，如果是向被参照关系插入，则不需要考虑此约束；如果向参照关系插入，则检查插入行在外码属性上的值是否已在相应被参照关系的主码属性中存在，存在，可插入，否则不可插入，或者将插入行的外码属性的值改为NULL，再插入，最后检查自定义完整性约束，包括数据的类性、精度、取值范围、是否允许空值、是否有默认值等，满足即可执行插入操作，否则给出错误信息。 删除操作一般只需对被参照关系检查参照完整性约束。如果主键被引用则不可删，或将参照关系中对应行的外码属性改为为NULL，再删除 更新操作结合删除 和 插入操作，先删除再插入。]]></content>
      <categories>
        <category>Database basis</category>
      </categories>
      <tags>
        <tag>integrity constraint of relational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系数据模型要素二 （关系操作集合）]]></title>
    <url>%2F2019%2F09%2F18%2Frelational_operation%2F</url>
    <content type="text"><![CDATA[基本的关系操作增（插入 Insert）、删(Delete)、改(Update)、查（Query）。关系的查询表达能力是关系操作最主要的部分。查又可分为选择、投影、连接、除、并、差、交、笛卡尔积。集合操作方式（操作的对象和结果都是集合）。又称为一次一集合（set-at-a-time） 关系数据语言的分类通过关系语言实现关系操作。它高度非过程化用户不必请求DBM为其建立特殊的存取路径，由 DBMS 的优化机制来完成。 代数方式：主要有关系代数，通过对关系的操作来表达查询要求 逻辑方式：主要有关系演算，是用谓词来表达查询要求，关系演算又按谓词变元的基本对象（元组变量或域变量），分为元组关系演算和域关系演算。 介于前两者之间的结构化查询语言（Structured Query Language,SQL）：SQL具有丰富的查询功能、数据定义和数据控制功能。集查询、数据定义语言（DDL）、数据操作语言（DML）和数据控制语言（Data Control Language, DCL）于一体；是关系数据库的标准语言。 关系代数关系代数是关系操作语言中的传统表示方式，以集合代数为基础发展而来。任何一种操作都是将一定的操作符作用域一定的操作对象上，得到预期的操作结果。 操作包含三大要素：操作对象、操作符、操作结果。而对象和结果均为关系。关系代数直接应用关系的运算来表达操作的目的，运算符包括集合运算符和专门的关系运算符。 关系代数的运算符 运算符 含义 集合运算符 ∪ 并 − 差 ∩ 交 × 笛卡尔积 专门的关系运算符 σ 选择 π 投影 ⋈ 连接 ÷ 除 比较操作符 > 大于 ≥ 大于等于 < 小于 ≤ 小于等于 ＝ 等于 ≠ 不等于 比较操作符 ¬ 非 ∧ 与 ∨ 或 关系代数操作经过有限次复合的式子称为关系代数操作表达式（关系代数表达式），可使用表达式表示所需要执行的各种数据查询和修改处理，所有关系代数是一种抽象的查询语言，通过对关系的操作来表达查询。 按运算符分类，关系代数操作可分为：传统的集合运算和专门的关系运算 集合运算传统集合运算是二目运算，将关系看成元组集合，运算从行的角度来进行，具有 并、差、交、迪卡尔积四种运算。 Example： 表 T1 学号（SNO） 姓名（SNAME） 性别(SSEX) 宿舍(SROOM) 0001 张三 男 N101 0002 王二 男 N101 0003 李梅 女 C101 表 T2 学号（SNO） 姓名（SNAME） 性别(SSEX) 宿舍(SROOM) 0004 刘八 男 D101 0005 赵二 男 B201 0003 李梅 女 C101 并（UNION）表T1 和 表T2 使用并运算产生一个新表T3，（T3 = T1 ∪ T2）它是由T1和T2所有不同元组所组成，且 T1和T2属性个数、值域相同。下表为 T1 ∪ T2的结果表 T3 学号（SNO） 姓名（SNAME） 性别(SSEX) 宿舍(SROOM) 0001 张三 男 N101 0002 王二 男 N101 0003 李梅 女 C101 0004 刘八 男 D101 0005 赵二 男 B201 差（DIFFERENCE）表T1 和 表T2 使用差运算产生一个新表T4，（T4 = T1 - T2）它有T1的所有元组但不包含T2的元组，且 T1和T2属性个数、值域必须相同。下表为 T1 - T2的结果 表 T4 学号（SNO） 姓名（SNAME） 性别(SSEX) 宿舍(SROOM) 0001 张三 男 N101 0002 王二 男 N101 交（INTERSECTION）表T1 和 表T2 使用交运算产生一个新表T5，（T5 = T1 ∩ T2）它同时包含T1和T2相同的所有元组，且 T1和T2属性个数、值域必须相同，交运算可由差运算表示（T1∩T2 = T1-(T1-T2)）。下表为 T1 ∩ T2的结果 表 T5 学号（SNO） 姓名（SNAME） 性别(SSEX) 宿舍(SROOM) 0003 李梅 女 C101 笛卡尔积（CARTESIAN PRODUCT）表T6 和 表T7 使用笛卡尔积运算产生一个新表T8，（T8 = T6 × T7）它是T6和T7的所有元组连接而成，即将两张表的元关系合并，且T6的每一元组都对应T7所有的元组下表为 T6 × T7的结果 表 T6 学号（SNO） 姓名（SNAME） 0001 张三 0002 王二 表 T7 课程号（CNO） 课程名（CNAME） 教室(SSEX) 1 数据库 C-101 2 操作系统 C-102 表 T8 学号（SNO） 姓名（SNAME） 课程号（CNO） 课程名（CNAME） 教室(SSEX) 0001 张三 1 数据库 C-101 0001 张三 2 操作系统 C-102 0002 王二 1 数据库 C-101 0002 王二 2 操作系统 C-102 专门的关系运算此运算即涉及行，又涉及列，分为一元专门关系操作和二元专门关系操作 一元关系操作：对单个关系进行垂直分解的投影运算和进行水平分解选择运算 二元关系操作：对两个关系进行操作，包括连运算和除运算 选择（SELECT）选择运算( $σ_F(R)$ )，F为条件表达式，R为指定的被运算关系名。 从指定关系中选取满足条件的若干元组组成一个新关系1SELECT 关系名 WHERE 条件语句（表达式） 条件语句：由常数、属性名或列名、比较操作符及逻辑操作符组成 Example：1SELECT T8 WHERE 姓名 = "张三" 表 T9 学号（SNO） 姓名（SNAME） 课程号（CNO） 课程名（CNAME） 教室(SSEX) 0001 张三 1 数据库 C-101 0001 张三 2 操作系统 C-102 投影（PROJECTION）投影运算( $π_A(R)$ ), R为被运算关系，A为属性序列，从指定关系中选取指定的若干属性值组成新关系1PROJECTION 关系名 ( 属性名1, 属性名2 ,... ) 组成的新关系自动去重 Example：1PROJECTION T8 (课程号,课程名) 表 T10 课程号（CNO） 课程名（CNAME） 1 数据库 2 操作系统 θ连接（JOIN）连接运算（$R\cfrac{⋈}{xθy}S$）,其中，R和S 代表两个不同的关系；x 和 y 分别表示R中的第x列和S中的第y列属性；θ表示比较运算符（&gt;、≥、&lt;、≤、=、≠）从笛卡尔积 R × S 中选取R的第x列属性值与S的第y列属性值满足θ 的那些元组组成一个新关系。 1JOIN 关系1 AND 关系2 WHERE 条件语句 条件语句：由比较操作符和属性名或列名组成的表达式 等值连接：θ值为 “=”，从R和S的笛卡尔积中选取 x、y 属性值相等的元组 Example： 表 T11 A B C a b c d e f 表 T12 D E A g h a b c d 1JOIN T11 AND T12 WHERE C = E T11 × T12 T11.A B C D E T12.A a b c g h a a b c b c d d e f g h a d e f b c d 等值结果为： 表 T13 T11.A B C D E T12.A a b c b c d 自然连接：是一种特殊的等值连接，要求两个关系中比较的分量必须是 相同的属性组，且结果中去除重复的属性列 1JOIN T11 AND T12 WHERE A = A 表 T14 T11.A B C D E T12.A a b c g h a d e f b c d 表 T14.2 A B C D E a b c g h d e f b c 自然连接是构造新关系的有效方法，投影和选择是分解关系的有效方法，自然连接中如果两个关系没有公共属性则变成笛卡尔积 除（DIVISION）除运算（R÷S） R和S代表两个不同的关系。假如被除关系R 为 m 元关系，除关系S 为 n 元关系，则运算结果的新关系为 m-n元关系。 Example 1： 表 T15 A B C D E F G a b c d e f g h i j k l m n a b c d e c d a c e f b m n a b c d e b h a b c d e g h 表 T16 H F G b f g c m n b c d c b h T15 ÷ T16运算步骤： 被除关系R对除关系S不同的属性 X 进行投影 X 投影 A B C D E a b c d e h i j k l a b c d e a c e f b a b c d e a b c d e 123456789101112131415// 列出 x 集合中的值 和对应象集&#123; "a,b,c,d,e":&#123;(f,g),(c,d),(b,h),(g,h)&#125;, "h,i,j,k,l":&#123;(m,n)&#125;, "a,c,e,f,b":&#123;(m,n)&#125;&#125;// 列出 表 T16 中与 T15相同的列的投影&#123; (f,g),(c,d),(b,h)&#125; 通过对比发现 只有a,b,c,d,e值对应的象集包含关系T16的投影集，所以结果接 A B C D E a b c d e]]></content>
      <categories>
        <category>Database basis</category>
      </categories>
      <tags>
        <tag>relational operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系数据模型要素一 （关系数据结构）]]></title>
    <url>%2F2019%2F09%2F09%2Frelation_data_model%2F</url>
    <content type="text"><![CDATA[概叙关系数据库的基本特征是使用关系模型的组织数据，20世纪80年代以后，在商用DBMS中，关系模型逐步取代早期的网状模型和层次模型。 关系数据模型作为数据模型，关系模型包含三个组成要素：关系数据结构、关系操作集合和关系完整性约束。 关系数据结构 重点 结构只包含单一的数据结构（关系），现实世界的实体与实体间的各种联系均用关系来表示。关系模型是把数据库表示为关系的集合，并以二维表格的形式组织数据。 录入一张二维表格如： 学号 姓名 性别 籍贯 民族 … 001 张三 男 陕西 汉 … 002 李四 男 湘西 苗 … 003 王五 男 河北 汉 … 004 赵六 男 东北 汉 … … 基本术语 表(Table)：也称为关系，是二维数据结构，由表名、构成表的各列及若干行数据组成，每个表由唯一的表名，每一行数据描述一条具体的记录值。 关系（Relation）：一个关系逻辑上对应一张二维表，可以为每个关系取一个名称来标识。关系有三种类型：基本关系（基表，实际存在的表，是实际存储数据的逻辑表示）、查询表（查询结构对应的表）和视图表（由基本表或其他视图导出的表，不对应实际存储的数据）。 列（Column）：称为字段（Field）或属性（Attribute）。每一列有一个名称，表示实体属性，具有相同数据类型。在一个数据库中，表名，字段名必须唯一，不同的表可以有相同的字段名，且命名须有意义，简单。 属性（Attribute）：表列即属性，给属性起名即属性名。属性的个数称为关系的元或度。列值为属性值；取值范围为值域。 行（Row）：称为元组（Tuple）或记录（Record）。表中的数据按行存储，一行数据即一条记录或元组，每行又若干个字段值组成。 分量（Component）：元组的属性值为分量 码/键（key）：在一个关系中，有一个属性或属性组，能用来标识该关系的元组，则为该关系的码或键。 超码或超键（Super Key）：从码中去除某个属性，它仍然是对应关系的码，则为超码；每个关系至少有一个默认的超码（所有属性的集合）。 候选码或键（Candidate Key）：关系中的一个码或键中，不能去除任何一个属性，否则它就不是对应关系表的码或键，则此码为候选码（键），它是关系表中最小的超码或超键。 主键/码(Primary Key)：在一张关系表中的若干候选键中指定一个用来唯一标识该关系的元组，则该候选键为主键。 全键/码（All-Key）：一个关系中所有的属性集合是是这个关系是主键/码，则为全键/码。 主/非属性（Primary Attribute/Nonprimary Attribute）：关系中包含任何一个候选键/码的属性为主/码属性，不包含任何一个候选码的属性为非主/码属性。 外键/码（Foreign Key）：关系中的某个属性或属性组不是这个关系的主键或候选键，而是另一个关系的主键，则该属性（属性组）为关系的外键/码。 参照关系(Referencing Relation)/被参照关系（Referenced Relation）：参照关系也称从关系，被参照关系又称主关系，它们指以外码相关联的两个关系。而以外码为主码的关系为被参照关系；外码所在的关系为参照关系，这种联系通常是一对多关联。 域（Domain）：指属性取值范围。 数据类型（Data Type）：每列（元关系）都有相应的数据类型，用于限制该列中存储的数据。 关系模式（Relation Schema）：通数据模型一样，数据库也有型和值，在关系数据库中关系模式是型，关系是值，关系模式是对关系的描述。 中文字段名 数据类型 宽度 … 学号 字符类型 8 … 姓名 字符类型 10 … 身份证 字符类型 18 … … … … … 上表是学生基本星系登记表关系的结构定义，关系则是元组的集合，是关系模式在某一时刻的状态或内容 关系模式是静态的、稳定的，而关系是动态的、随时间不断变化，因为关系操作在不断地更新着数据库的数据实际工作中关系模式和关系统称为关系。 关系数据库（Relation Database）：以关系模型作为数据的逻辑模型，并采用关系作为数据组织方式的一类数据库，其数据库操作建立在关系代数的基础上。在给定的应用领域中，所以关系的集合构成一个关系数据库。 在实际的数据库应用系统中，一般使用英文作为表名、字段名等。因为在编写数据库应用程序时，表名、字段名会作为变量名，使用中文不方便标识，且有些DBMS不能很好的兼容中文。 重点因此上表应该变更为： 含义 字段名 数据类型 宽度 … 学号 studentNo 字符类型 8 … 姓名 sutdentName 字符类型 10 … 身份证 studentId 字符类型 18 … … … … … … 关系数据库对关系的限定： 每个属性都不可分解，是关系数据库对关系的最基本的限定，要求关系的每个分量必须是一个不可分的数据项，即不允许表中有表 一个关系对应一种关系模式，模式中的属性的数据类型及属性的个数是相对固定的 每个关系模式中的属性必须命名，在同一模式中，属性名必须是不同的 同一关系中不允许出现候选码或键值完全相同的元组 关系中的元组顺序是可任意交换 关系中的属性顺序可以任意交换]]></content>
      <categories>
        <category>Database basis</category>
      </categories>
      <tags>
        <tag>relationDataModel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础（Database Basis) (二)]]></title>
    <url>%2F2019%2F09%2F05%2Fdatabase_basis_2%2F</url>
    <content type="text"><![CDATA[数据库系统的结构 注：数据库（ DB ）数据库系统（DBS）数据库管理系统（DBMS） 数据库管理员（DBA）在一个DBS中有着不同类型的用户，每个用户都从不同的角度以各自的观点看待数据库，从而形成了DBS不同的视图结构。因此DBS的结构可以有多种不同的层次或不同的视角。 从数据库管理员（DBA）视角来看，DBS分为内部系统结构和外部体系结构，其中内部系统结构通常采用三级模式结构，外部体系结构通常表现为 集中式结构、分布式结构和并行结构等； 从数据库用户角度分为客户/服务器结构和浏览器/服务器结构，也就是DBS整体的运行与应用结构 三级模式结构（DBA视角）从DBA角度审视数据库系统，其内部基本遵循美国 ANSI/SPAPRC DBMS研究组提出的三体系结构（用户、概念级和物理级）。各个DBMS产品在体系结构上通常具有相同的特征（三级模式结构），并提供两层映像功能。DBS三模式结构是指 模式（Schema）、外模式（External Schema）和 内模式（Internal Schema）。 graph LR A(数据库) --> B(内模式) B --内模式/模式映像--> C(模式) C --> C1(外模式1) C --外模式/模式映像--> C2(外模式2) C --> C3(外模式3) C1 --> D1(应用1) C1 --> D2(应用2) C2 --> D3(应用3) C2 --> D4(应用4) C3 --> D5(应用5) C3 --> D6(应用6) 外模式的描述向客户提供数据，内模式的描述存储数据，模式是两者的中间层，机不涉及数据的物理存储和硬件环境，也与具体应用程序、开发工具及设计语言无关。 模式 模式也称为概念模式或逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图，即数据在逻辑上的视图（又称概念视图） DBA必须考虑整个数据库的全局概念视图，它不包含任何的数据库实现细节，如何种D是BMS、文件组织、存取方法及设备特征等；而是定义数据库的逻辑结构、数据之间的联系，及数据相关的安全性、完整性等要求（由DBMS提供模式描述语言（Schema DDL）），同时一个数据库只有有个模式，且相对稳定。 外模式 外模式也称为子模式（Subschema）或用户模式,是数据库用户能看见和使用的局部数据的逻辑结构和特征的描述，是与某一应用有关数据的逻辑表示。（DBMS提供子模式描述语言（Subschema DDL）来严格定义子模式）通常其用于满足不同数据库用户需求的数据视图（用户视图），是模式的子集，对数据库整体数据的局部重构。不同用户在看待数据的方式、应用需求、对数据保密的要求等方面存在差异，对应外模式描述就不同，且模式中同样的数据，在外模式中的结构、类型、长度、保密级别等都可以不同 外模式是保证数据库安全的重要措施，每个用户只能看见和访问所对应的外模式中的数据，简化了DBS的用户接口，便于用户使用，并有效支持数据独立性和共享性。 内模式内模式也称存储模式（Storage Schema）, 是对数据库中的物理结构和存储方式的描述，是数据在数据库内部的表现形式。是整个数据库的最底层表示，它不同于物理层，是DBA所见到的，特定的DBMS所处理的数据库的内部结构（内部视图或存储视图）。 和模式一样，内模式在一个数据库中只有一个，它不存储设备上的物理记录或物理快，也不涉及任何具体设备限制。 两层映像与数据独立性 重点总体而言，三个模式的对数据的三级抽象，其特点如下： 一个数据库的整理逻辑结构和特征的描述（概念模式）是独立于数据库其他层次结构（内/外模式）的描述，其是数据库的核心，也是数据库设计的关键。 一个数据库的内部存储模式依赖于概念模式，并且独立于外部模式和具体的存储设备。 用户逻辑结构（外模式）是在全局逻辑结构描述的基础上定义的，它面向具体的应用程序，独立于内部模式和存储设备。 应用程序是在外模式的逻辑结构上编写，依赖于特定的外模式，与数据库的模式和存储结构独立。 用户不必考虑数据的物理存储细节，将其交给DBMS负责管理，同时为有效支撑数据库的三级抽象及它们之前的联系和相互转换，DBMS通过提供两层映像来实现（外模式/模式 和 模式/内模式） 映像映像是指一种对应规则，指出映像双方如何进行转换。 外模式/模式映像：定义各个外模式与概念模式之间的映像关系，这些定义通常在各自的外模式中加以描述。DBS的模式如若发生改变（增加新的关系、属性、改变数据类型等)，DBA会对各个映像做出相应改变，使那些对用户可见的外模式保持不变，从而使程序员不必去修改那些依据数据的外模式所编写的程序，这样外模式就不受模式的影响，保证数据与程序的独立性。 模式/内模式：定义数据库全局逻辑结构与物理存储之间的关系，通常在模式中加以描述。而DB只有一个模式，所以此映像是唯一的。同样，DBS 的物理存储如若发生改变（选用另一个存储结构或更换存储位置），DBA会的此映像做出相应调整，使DBS 的模式保持不变，不必修改应用程序，保证的物理独立性 因此，两层映像保证了DBS中的数据具有较高的逻辑独立性和物理独立性，使数据的定义和描述可以从应用程序中分离，简化数据库应用程序的开发，减少维护工作量。 DBS 的运行与应用结构（用户视角）客户/服务器结构在DBMS中，DB的使用者（程序员，DBA等）可以使用命令行客户端、图形化界面管理工具、应用程序等连接DBMS，通过DBMS查询和处理存储在底层数据库中的各种数据。那些不与DBMS直接联系的工具和程序被称为客户端、前台或表示层，主要完成交互任务，而DBMS称为服务器、后台或数据层，主要负责数据管理。 这种工作模式就是客户/服务器结构(Client/Server,C/S). 浏览器/服务器结构此结构基于Web应用的客户/服务器结构，或者三层客户/服务器结构。在DBS中，它将与DBMS交互的客户端进一步细分为表示层和处理层。 表示层：指数据库使用者的操作和展示界面，通常由各种浏览器构成处理层（中间层）：负责处理数据库使用者的具体应用逻辑，与后台的DBMS共同组成功能丰富的胖服务器 。 这种工作模式就是浏览器/服务器结构（Browser/Server，B/S） 数据模型 模型是现实世界特征的模拟和抽象表达，帮助人们更好的认识和理解客观事物、对象和过程等感兴趣的内容（飞机航模、建筑图纸、军事沙盘等）。而数据模型是用来模拟和抽象现实世界中的数据特征，描述的是数据的共性内容。 数据特征与数据模型组成要素数据具有静态和动态两种特征。静态特征：数据的基本结构、数据间的联系及对数据取值范围的约束。动态特征：指对数据可以进行符合一定规则的操作。数据模型通常由数据结构、数据操作和数据约束三要素组成： 数据结构：是描述系统的静态特性，数据对象的类型、内容、属性及数据对象之间的联系。如层次结构、网状结构、关系结构的数据模型分别命名为层次模型、网站模型、关系模型及面向对象模型。 数据操作：描述的是系统动态特性，是对各种对象的实例允许执行的操作集合，包括操作及相关的操作规则。主要分为更新（增、删、改）和检索两大类。数据模型必须定义这些操作的确切含义、操作符号、操作规则（优先级等）及实现操作的语言。 数据约束：描述数据结构中国数据间的语法和语义关联，包括相互制约与依存关系及数据动态变化规则，保证数据正确性、有效性与相容性。约束包含数据完整性约束、数据安全性及并发控制约束；数据约束既刻画了数据静态特征，也表示了数据动态行为规则。 数据模型的分类数据模型应满足三个要求： 能比较真实的模拟现实世界 容易使人们理解 便于在计算机上实现 目前一种数据模型要完全满足三个要求，很困难，因此需针对不同对象和应用，采取逐步抽象的方法，在不同抽象层使用不同的数据模型。 概念层数据模型（数据的概念模型 （Conceptual Model）,信息模型）概念层是数据抽象级别的最高层，目的是按照用户的观点对世界建模。概念层模型用来描述现实世界的事物，是对信息世界建模，与具体的计算机系统无关，独立于任何DBMS，容易向DBMS所支持的逻辑数据库模型转换，此类模型主要用于数据库的设计阶段，表示现实世界的各个事物及其联系。 信息世界中的基本概念（类似于对象）重点概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具，是设计人员和用户之间交流的语言，因此概念模型具有较强的语义表达能力，能够方便、直接地表达应用中的各种语义知识，它简单、清晰、易于理解。 实体（Entity）：客观存在并可相互区别的事物，既可以是实体事物，也可以说抽象的概念或联系（学生、商品、部门、课程、比赛等都可以是实体） 属性（Attribute）：实体所具有的某种特性，一个实体可以由多个属性描述（性别，名称、日期，年龄等等） 码或键（Key）：可唯一标识实体的属性集。如学生的学号 域（Domain）：一个属性的取值范围。如学生实体中姓名的域 实体型（Entity Type）：具有相同属性的实体必然具有共同的特征和性质。用实体名于属性名集合抽象和刻画同类实体即实体型。（学号，姓名，性别） 实体集（Entity Set）：同实体的集合。（每个学生是一个实体，所以学生组成实体集） 联系（Relatinship）：现实世界中，事物内部及事物之间是有联系的，反应到信息世界中即实体（型）内部的联系和实体（型）之间的联系。实体内部的联系通常指各属性之间的联系。如确定学号，即知道对应的姓名，学号与姓名两个属性之间有联系。实体之间的联系指不同实体间的联系。如一个班有许多学生，一个学生只属于一个班级，这是学生与班级两个实体间的联系。 数据模型中有型【type】（某一类数据的结构和属性说明）和值【value】（对型的赋值）的概念 概念模型的表示方法概念模型的表示方法有很多种，最常用的是实体-联系方法（Entity-Relationship approach）也称E-R模型，它是抽象和描述现实世界的有力工具，它独立于具体的DBMS所支持的逻辑模型，是各种逻辑模型的共同基础。 逻辑层数据模型逻辑层是数据抽象的中间层，描述数据整体逻辑结构；这层的数据抽象被称为逻辑模型，是用户通过DBMS看到的现实世界，基于计算机系统的观点来对数据进行建模和表示。因此，它既要让用户易于理解，又要便于DBMS实现。主要的逻辑数据模型有 层次模型（Hierarchical）、网站模型（Network Model）、关系模型（Relational Model）和面向对象模型（Object Oriented Model）等 层次模型此模型是数据库最早的一种数据模型，它的数据结构是一颗“有向树”，数的每个结点对应一个记录集。特点：有且仅有一个结点没有父结点（根结点）；其他结点有且仅有一个父结点。 网状模型此模型以网状结构表示实体与实体之间的联系。是层次模型的扩展，允许结点又多个父结点，且可以有多个节点没有父结点。此模型可以方便的表示实体间各种类型的联系，但结构复杂，实现的算法难以规范化。 关系模型 重点此模型用二维表结构来表示实体及实体间联系的模型，并以二维表格的形式组织数据库中的数据。特点： 建立在严格的数学概念基础之上 概念单一，统一用关系表示实体及实体间的联系，对数据的检索与更新结果同样也用关系（即表）表示。 关系模型的存取路径对用户透明，这样就具有更高的数据独立性、更好的安全保密性，简化了程序员的开发工作。目前流行的商用数据库大多基于关系模型（关系数据库管理系统）。 面向对象模型此模型是面向对象方法与数据库相结合所构成的数据模型。它既是概念模型又是逻辑模型。用面向对象观点描述现实世界实体逻辑组织、对象间的联系。 物理层数据模型此模型又叫数据的物理模型，描述数据在存储介质上的组织结构，是逻辑模型的物理实现，每一种逻辑模型在实现时都有与其对应的物理模型。物理模型是数据库最底层的抽象，它确定数据的物理存储结构、数据存取路径及调整、优化数据库的性能。物理数据结构一般向用户屏蔽，用户不必了解其细节。]]></content>
      <categories>
        <category>Database basis</category>
      </categories>
      <tags>
        <tag>Database_basis_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础（Database Basis) (一)]]></title>
    <url>%2F2019%2F09%2F04%2Fdatabase_basis_1%2F</url>
    <content type="text"><![CDATA[概叙数据库技术是对数据进行管理的技术，能有科学地管理各类信息资源。数据、数据库、数据库管理系统和数据库系统是数据库常用的基本概念。 数据库基本概念数据（Data）数据是描述事物的符号记录，指用物理符号记录下来的、可鉴别的信息。 数据有多种表现类型： 文本数据：数字、字母、特殊字母、文字等组成 多媒体数据：图像、图形、动画、影像、声音、语言等组成 各种类型的数据经过数字化处理后存入计算机，便于进一步加工、处理、使用 人们通常只抽取感兴趣的事物特征或属性来描述事物。例如，人们关注客户的姓名、性别、年龄、籍贯、所在地区、联系方式等特征，（张三，男，26，北京，上海，1383838444；）这些具体的特征值就构成一组数据，就是一条记录 数据记录往往不能完全表达其内容的含义，还需经过解释才能表达明确含义;如： 张三，男，26岁，北京人，住在上海，联系电话是1383838444；而不了解数据含义的人难以从北京、上海的地名上理解所表达的意思因此数据及关于该数据的解释密切相关，数据的解释是对数据的含义说明，也称数据的语义，即数据所蕴含的信息，没有语义的数据是没有意义和不完整的。数据是信息存在的一直形式，只有通过解释或处理的数据才能成为有用的信息。 数据库（Database）数据库是存储数据的仓库，是有组织的、可共享的数据集合，且数据库中的数据按一定的数据模型组织、描述和永久存储，具有较小的冗余度、较高的数据独立性，系统易于扩展，并可以被多个用户共享 数据库管理系统（Database Management System，DBMS）是一套建立和管理数据库的软件，介于应用程序和操作系统之间。负责科学有效地组织和存储数据，并帮助使用者从大量的数据中快速地获取所需数据，提供必要的安全性和完整性等 主要功能： 数据定义功能：通过系统提供的数据定义语言（Data Definition Language, DDL），定义数据库中的数据对象，包括表、视图、存储过程、触发器等 数据操纵功能：通过系统提供的数据操作语言（Data Manipulation Language, DML），对数据库增、删、改、查等 数据库运行管理功能：由于数据库具有共享性，为保证数据的安全性、可靠性，系统提供了统一的控制和管理机制，实现数据在不被相互干扰的情况下并发使用，并且发生故障时能对数据库进行正确的恢复 数据库建立和维护功能：主要包括创建数据库及对数据库空间的维护、数据库的备份与回复功能、数据库的重组织功能和性能监视、分析等，一般通过系统提供的一些实用工具实现。 数据组织、存储和管理功能：为提高数据的存取效率，系统需对数据进行分类存储和管理，根据具体组织和存储方式提供多种数据存取方法，如索引查找、顺序查找等 其他功能：主要于其他软件的网络通信、不同数据库管理系统之间的数据传输及相互访问功能等。 数据库系统（Database System， DBS）指计算机中引入数据库技术之后的系统。通常一个完成的数据库系统包括 数据库、数据库管理系统及相关实用工具、应用程序、数据库管理员和用户。 数据库管理员（Database Administrator, DBA）不同于普通数据库用户，他们专门负责对数据库进行维护，并保证数据库正常、高效运行 用户则是数据库系统的服务对象，通常包括程序员和数据库终端用户，程序员通过高级程序设计语言（JAVA,PHP等）和数据库语言（SQL）编写数据库应用程序。 一般不引起混淆，常将数据库系统简称数据库。 数据库管理技术的发展数据库管理可从两方面理解： 针对组织业务管理：负责制定并执行整个组织中关于数据的定义、组织、保护与有效使用的策略、过程和计划 依靠技术：负责实现数据作为一种资源的集中控制管理 数据组织：以便于处理的某种方式收集数据，并将记录在纸介文件上的数据转换成计算机可处理的形式；然后将收集的数据进行适当的构造 数据组织分为两种： 逻辑组织：用户或应用程序所使用的数据结构形式 物理组织：数据在物理存储设备上的结构形式 检索：存储的数据能方便的被选择提取 数据管理的任务是进行数据的收集、组织、控制、存储、选取、维护，实现在适当的时候，以适当的形式，给适当的人提供适当的数据；是数据处理的中心问题 数据处理：指对各种数据进行收集、存储、加工、和传播的一系列活动的总和 管理技术的发展阶段人工管理阶段20世纪50年代中期以前，计算机主要用于科学计算，所涉及的数据处理工作基本上都是靠手工方式进行 主要特点： 数据不会保存：由于计算机软件和硬件发展刚刚起步，存储容量有限且价格昂贵，通常一组数据对应一个程序，数据随程序一起输入计算机，处理完毕后即将出结果，数据空间随着程序空间一起被释放 应用程序管理数据：当时没有专门的数据管理软件，应用程序的数据由程序自行负责，因而数据的组织方式必须由程序员自己设计、定义和管理。所有包括逻辑结构、物理结构、存取方法等数据库设计工作都由应用程序的编写人员来完成，程序员的工作负担十分繁重 数据面向应用：一组数据对应一个程序，多个应用程序涉及某些相同的数据时必须各自定义，不能共享，因此程序与程序之前存在大量冗余数据，数据独立性差 文件系统阶段20世纪50年代中期到60年代中期，计算机软、硬件发展到一定阶段。其中，硬件方面配置了磁盘、磁鼓等直接存储设备；软件则在操作系统中配备了专门的数据管理软件，即文件系统 文件系统是将数据的逻辑结构和物理结构分离，由“存放方法”实现逻辑结构与物理结构执行的映射。应用程序只涉及数据的逻辑结构，系统决定数据的物理结构，两者直接可以由差别，这样不会相互影响（数据的物理独立性），使得使用性提高，同时程序员不必关心数据的物理存储细节，生产效率大大提高 主要特点： 数据可长期保存和专门管理：磁盘、磁鼓等直接存储设备；软件则在操作系统中配备了专门的数据管理软件 物理数据独立性：应用程序与数据的具体物理存储结构分离 文件级数据共享：通过数据的抽取、排序、合并等为应用提供新的文件，不能实现数据项级的普通共享；文件的逻辑结构是根据它的应用而设计，数据的逻辑结构与应用程序之间相互依赖。不同应用程序必须构造各自的文件，数据项大部分相同时还是存在大量的数据冗余。 数据库系统阶段数据库技术是应数据管理任务的需要而产生。20世纪60年代末以来，计算机技术与工业迅速发展，计算机开始广泛应用于企业管理，并对计算机数据管理提出更高的要求： 数据作为企业组织的公共资源而集中管理控制，能为企业各类用户共享，须大量地消除数据冗余，节省存储空间； 当数据变更时，能节省对多个数据副本的多次变更操作，从而缩小计算机运算时间，不会遗漏某些副本的变更而使系统出现不一致的数据 数据要具有更高的独立性，不但具有物理独立性，而且具有逻辑独立性，当数据逻辑结构改变时，不影响那些不须改变的用户应用程序，节省开发和维护的代价 数据库系统的特点 数据集成：数据库管理系统的主要目的就说数据集成。在数据库中，通过相关联数据间定义的逻辑联系，数据被组成统一的逻辑结构，与数据的物理组织与定位分离，应用的修改、增加只与数据的逻辑结构发生关系。 数据共享性高：在数据库中，一个数据可为多个不同用户共同使用，各个用户可以为了不同的目的来存取相同的数据，他们从各种不同的角度来看待数据库，即一个数据库有多种不同的用户视图。这些用户视图简化了数据的共享，它们可以给每个用户提供执行其业务职能所要求的数据的准确视图，使用户无须知道数据库的全部复杂组成。共享不仅是同一数据被不同用户存取，还包含并发共享，不同用户可同时存取同一的数据 数据冗余小：将独立而又冗余的数据文件集成为单一的逻辑结构，每个数据项的值可以理想地只存储一次，从而节约空间，避免数据的重复存储。并非所有的冗余都可以被消除，有时业务或技术上的原因，如数据的合法性检验、数据存储效率等方法，同一数据可能在数据库种保持多个副本，因此数据库系统种，冗余是受控的，系统知道冗余，保留必要的冗余是系统预定的 数据一致性：通过消除或控制数据冗余，可在一定范围内避免数据的不一致性。 数据独立性高：数据定义与使用数据的应用程序分离，一方的修改不会影响另一方的修改。数据库提供了两层数据独立： 逻辑独立：不同的应用程序对同样的数据可以使用不同的视图，即应用程序一定范围内修改它的数据库视图，而不修改数据本身的定义；而数据定义的修改，在一定范围内不会引起应用的修改 物理独立：改变数据的存储结构或存取方法以响应变化的需求而无需修改现有的应用程序 实施统一管理与控制：主要包括数据的安全性、完整性、并发控制与故障恢复等（数据库包含） 数据安全性（Security）：指保护数据，防止非法使用造成数据泄密和破坏，每个用户只能按规定对某些数据以某些方式进行使用和处理，保证数据只有赋予权限的用户才能访问数据。 数据完整性（Integrity）：对数据的正确性、有效性和相容性的校验，即控制数据在一定范围内有效或要求数据之前满足一定的关系，保证输入到数据库中的数据满足相应的约束条件，确保数据有效、正确 并发控制（Concurrency）：多个用户的并发进程同时存储、修改数据库时，可能发生相互干扰，而得到错误结果，使得数据库的完整性糟到破坏，因此对多用户的并发操作加以控制和协调。如用户网上订购火车票，系统必须确保不会由于多个用户同时购买相同的车票而造成冲突。 故障恢复：计算机产生的硬件故障、操作员的失误以及人为的破坏都会影响数据库中数据的正确性，DBMS必须具有将数据库从错误状态恢复到某一已知的正确状态的功能。 减少应用程序开发与维护的工作量：由于数据库中的数据具有共享性、独立性，使得程序员不在需要承担基本数据文件的设计、建造与维护等繁重负担]]></content>
      <categories>
        <category>Database basis</category>
      </categories>
      <tags>
        <tag>Database_basis_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问媒体设备]]></title>
    <url>%2F2019%2F08%2F12%2FmediaDevices%2F</url>
    <content type="text"><![CDATA[概览 mediaDevices 是 Navigator 对象的只读属性，一个单列对象，可以连接访问相机和麦克风，屏幕共享等媒体输入设备 方法enumerateDevices 请求一个可用的媒体输入和输出设备列表，如麦克风、相机、耳机等。返回的 Promise完成状态中是一个带有 MediaDeviceInfo 的数组 123456789101112131415161718192021let mediaDevices = navigator.mediaDevicesif(!mediaDevices || !mediaDevices.enumerateDevices) return console.erorr('浏览器不支持enumerateDevices API')navigator.mediaDevices.enumerateDevices().then((devices)=&gt;&#123; for (let device of devices)&#123; console.log(device.kind + ': ' +device.lable + ' id = '+ device.deviceId ); &#125;&#125;).catch(err=&gt;&#123; console.error(err)&#125;)/*audioinput: undefined id = defaultaudioinput: undefined id = communicationsaudioinput: undefined id = ac67d348685a08c75e5017f9a449b3d85f08dcb774c88ab95de82bbf2c0fc820videoinput: undefined id = e41039bcfbc84d926a0b73cdc1d8b1daf3d67d36c62588202191d918fb076426audiooutput: undefined id = defaultaudiooutput: undefined id = communicationsaudiooutput: undefined id = 015d73652e57bffb21679b937675d32c4d4a43862aba3774aaf0b5f1e983151f*/ 兼容性 getSupportedConstraints 返回一个 MediaTrackSupportedConstraints 对象，其属性都是客户端所支持约束的属性,值为 Boolean 类型 12345678910111213141516171819202122232425262728293031323334353637let supportedConstraints = navigator.mediaDevices.getSupportedConstraints()for (let constraint of Object.keys(supportedConstraints))&#123; console.log(constraint)&#125;/*aspectRatioautoGainControlbrightnesschannelCountcolorTemperaturecontrastdeviceIdechoCancellationexposureCompensationexposureModeexposureTimefacingModefocusDistancefocusModeframeRategroupIdheightisolatencynoiseSuppressionpointsOfInterestresizeModesampleRatesampleSizesaturationsharpnesstorchvolumewhiteBalanceModewidthzoom*/ 兼容性 getDisplayMedia 提示用户选择和授予权限来捕获显示或部分的内容，(如分屏共享时分享哪一屏的内容)然后使用 medieaStream Recording API 记录生成的 stream，或作为 webRTC 会话的一部分进行传输。 可以传递一个MediaStreamConstraints 对象指定返回要求的 mediaStream。 12345678910async function startCapture(displayMediaOptions) &#123; let captureStream = null; try &#123; captureStream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions); &#125; catch(err) &#123; console.error("Error: " + err); &#125; return captureStream;&#125; 兼容性 getUserMedia 提示用户给予使用媒体输入的许可（如麦克风，摄像机）,当媒体输入时产生一个 mediaStream包含所请求的媒体类型的轨道。该流可以包括视频轨道（摄像机，视频记录设备，共屏等硬件或虚拟视频流源）、音频轨道（来自麦克风、A/D转换器等硬件或虚拟音频源），也可能是其它轨道类型 该方法返回一个Promise对象,成功时 resolve 回调函数带有mediaStream对象。如果用户拒绝授予使用权限，或是媒体源不可用，则返回 reject回调 Promise 可能既不会 resolve 也不会reject,因为用户不必做出选择，可能只是忽略请求 123456789101112// 想要获取一个最接近 1280x720 的相机分辨率let constraints = &#123; audio: true, video: &#123; width: 1280, height: 720 &#125; &#125;;navigator.mediaDevices.getUserMedia(constraints).then(function(mediaStream) &#123; let video = document.querySelector('video'); video.srcObject = mediaStream; video.onloadedmetadata = function(e) &#123; video.play(); &#125;;&#125;).catch(function(err) &#123; console.log(err.name + ": " + err.message); &#125;); 参数 constraints 一个mediaStreamConstraints对象指定请求的媒体类型和相对应参数，该对象包含 video 和 audio 两个属性，必须一个或两个同时被指定，如果无法找到指定的媒体类型或无法满足对于的参数要求，Promise将返回 rejected 参数配置11&#123;audio:true,video:true&#125; 属性设置为 Truthy 则生成的stream 必须具有该类型的轨道，否则调用 getUserMedia会抛出错误 21234&#123; audio: true, video: &#123; width: 1280, height: 720 &#125;&#125; 表示video的分辨率应为 1280x720 浏览器将试着满足这个请求参数，如果无法满足要求或选择覆盖，则可能返回其它的分辨率 31234567&#123; audio: true, video: &#123; width: &#123; min: 1280 &#125;, height: &#123; min: 720 &#125; &#125;&#125; 此配置要求了最低分辨率，如果达不到要求，promise 将返回 reject;还可配置 max、exact(min == max),而且用户将不会得到要求授权的提示 41234567&#123; audio: true, video: &#123; width: &#123; min: 1024, ideal: 1280, max: 1920 &#125;, height: &#123; min: 776, ideal: 720, max: 1080 &#125; &#125;&#125; 如果使用ideal,浏览器将尝试找到（如果相机有多个的话）最接近指定值的理想值的设备或相机意味着上方的第一个分辨率例子可简写为：1234567&#123; audio: true, video: &#123; width: &#123; ideal: 1280 &#125;, height: &#123; ideal: 720 &#125; &#125;&#125; 5并不是所有的 constraint 都说数字，如在移动设备上优先使用前置相机1&#123; audio: true, video: &#123; facingMode: "user" &#125; &#125; 强制使用后置相机12345&#123; audio: true, video: &#123; facingMode: &#123; exact: "environment" &#125; &#125;&#125; APP权限配置12345678"permissions": &#123; "audio-capture": &#123; "description": "Required to capture audio using getUserMedia()" &#125;, "video-capture": &#123; "description": "Required to capture video using getUserMedia()" &#125;&#125; 作为可能涉及重大隐私问题的API，getUserMedia()规范规定了浏览器有义务满足的各种隐私和安全要求。getUserMedia()是一个强大的功能，只能在安全的环境中使用; 在不安全的情境中，navigator.mediaDevices 是undefined，阻止访问getUserMedia()。简而言之，安全上下文是使用HTTPS或 file:///URL 方案加载的页面，或者是从中加载的页面localhost。 在旧的浏览器中使用新的API推荐使用处理了约束的 adapter.jspolyfill 来替代。12345678910111213141516171819202122232425262728293031323334353637383940414243// 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象let mediaDevices = navigator.mediaDevicesif (mediaDevices === undefined) &#123; mediaDevices = &#123;&#125;;&#125;// 一些浏览器部分支持 mediaDevices。我们不能直接给对象设置 getUserMedia// 因为这样可能会覆盖已有的属性。这里我们只会在没有getUserMedia属性的时候添加它。if (mediaDevices.getUserMedia === undefined) &#123; mediaDevices.getUserMedia = function(constraints) &#123; // 首先，如果有getUserMedia的话，就获得它 var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia; // 一些浏览器根本没实现它 - 那么就返回一个error到promise的reject来保持一个统一的接口 if (!getUserMedia) &#123; return Promise.reject(new Error('getUserMedia is not implemented in this browser')); &#125; // 否则，为老的navigator.getUserMedia方法包裹一个Promise return new Promise(function(resolve, reject) &#123; getUserMedia.call(navigator, constraints, resolve, reject); &#125;); &#125;&#125;mediaDevices.getUserMedia(&#123; audio: true, video: true &#125;).then(function(stream) &#123; var video = document.querySelector('video'); // 旧的浏览器可能没有srcObject if ("srcObject" in video) &#123; video.srcObject = stream; &#125; else &#123; // 防止在新的浏览器里使用它，应为它已经不再支持了 video.src = window.URL.createObjectURL(stream); &#125; video.onloadedmetadata = function(e) &#123; video.play(); &#125;;&#125;).catch(function(err) &#123; console.log(err.name + ": " + err.message);&#125;); 兼容性]]></content>
      <tags>
        <tag>mediaDevices</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux 学习]]></title>
    <url>%2F2019%2F08%2F04%2Fredux%2F</url>
    <content type="text"><![CDATA[概念 Redux 是一个可以预测的JavaScript 状态控制器，专注于状态管理，有store,state, action,reducer 等API（类似 vue 中的 vux） Redux 可编写构建行为状态一致的应用，可运行在客户端、服务的 和 原生应用 环境中，并且容易测试。 最重要的是，它提供很好的开发体验，编译后的代码可通过devtools实时预览调试。 Redux 可以和 React 一起使用，也可以和其他视图库（如 Vue）使用。它很小（2K大小 包含依赖 ），并且有一个庞大的插件生态系统。 安装使用 npm1npm install redux -S 使用 yarn 1yarn add redux -P 使用案例123456789101112131415161718192021222324252627282930313233// 引入 reduximport &#123;createStore&#125; from 'redux'const ADD_NUM = 1;const SUB_NUM = 2// 创建 redecerconst counter = (state = 6,action)=&gt;&#123; switch(action.type)&#123; case ADD_NUM: return ++state case SUB_NUM: return --state default: return state &#125;&#125;// 创建 storeconst store = createStore(counter)// 获取stateconst num = store.getState()// 发布信息更改statestore.dispatch(&#123;type:1&#125;)// 订阅 获取statestore.subscrible(lister) // 没执行一次dispatch （改变state) 就执行一次 lister 方法// 设置每次state变化 后的行为function lister()&#123; console.log(store.getState())&#125;store.dispatch(&#123;type:0&#125;) 核心概念 更新state中的数据，须通过action（就是一个普通对象） 来更改,这样可清晰的知道应用中发生了什么，数据为什么变动，怎样变动。而核心想法是如何根据这些 action 对象来更新 state。12&#123;type:1&#125;&#123;type:2&#125; 将state和action结合成函数，这就是reducer。它只接受 state和action 两个参数，并返回新的state函数。 12 console.log(store.getState())// 6&#125; 当然一个应用不单单只有一个reducer,我们可以通过redux来将它们合并。 Redux 三大原则单一数据源 （Single source of truth） 整个应用程序的 state 存储在一个单一 store 的对象树（object tree）中 这样更容易创建创建通用应用，来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。这样单一的 state 树更容易调试和检查。它还能在开发过程中保持应用程序的状态，从而加快开发周期。一些在传统上难以实现的功能（撤销/重做），将其state 存储在树中，从而变得更加简单。1234567store.dispatch(&#123; type: 1&#125;)store.dispatch(&#123; type: 2&#125;) State 是只读的 （State is read-only） 改变state的唯一方法是触发 action, action是描述发生什么事件的对象 这样确保视图和网络请求不会直接修改state，反而，它们明确表达想要修改的意图。因为所有的变化都被集中处理，且按照严格的顺序一个接一个执行。所以没有细微的竞争条件需要注意。 Action是一个普通对象，所以可以对它们进行打印、序列化、存储，然后后期调试和测试。1234567store.dispatch(&#123; type: 1&#125;)store.dispatch(&#123; type: 2&#125;) 使用纯函数进行更改 要如何通过 action改变指定的state tree ,需要编写 Reducers 函数 Reducer 只是一些纯函数，他接收 state 和 action 两个参数，并且返回新的state ,1234567891011121314151617181920212223242526import &#123; combineReducers, createStore &#125; from 'redux'// 创建 redecerconst counter = (state = 6,action)=&gt;&#123; switch(action.type)&#123; case ADD_NUM: return ++state case SUB_NUM: return --state default: return state &#125;&#125;const counter1 = (state = 6,action)=&gt;&#123; switch(action.type)&#123; case ADD_NUM: return ++state case SUB_NUM: return --state default: return state &#125;&#125;const reducers = combineReducers(&#123; counter, counter1 &#125;) // 通过 combineReducers 合并reducerconst store = createStore(reducers) 基础教程Action Actions 是将数据从应用程序发送到 store 的有效负载。它们是store 的唯一数据来源，通过 store.dispatch() 传递给 storeexample: 123456const ADD_TODO = 'ADD_TODO'&#123; type: ADD_TODO, text: 'Build my first Redux app'&#125; Actions 本质上是普通对象。并且该对象必须有一个type 属性来表示将要执行的动作，通常 type 被定义成字符串常量。当规模变大时，可以存放到单独的文件种管理。1import &#123; ADD_TODO, REMOVE_TODO &#125; from '../actionTypes' 注意：使用单独的模块或文件定义 常量type不是必须的，对于小应用来说，使用字符串type方便。而在大型项目种定义常量利大于弊。 出了type属性外其他属性可自行定义，对于规范参考Flux Standard Action 创建 Action 的生产函数 即生成action 的方法，函数返回一个 action 对象这样更容易被移植和测试123456function addTodo(text)&#123; return &#123; type:ADD_TODO, text &#125;&#125; 在传统的Flux实现中调用 action 实现方法时，一般会触发一个dispatch1234567function addTodo(text)&#123; const action= &#123; type:ADD_TODO, text &#125; dispatch(action)&#125; Redux 中只需把action 函数传递给dispatch()1234567function addTodo(text)&#123; return &#123; type:ADD_TODO, text &#125;&#125;store.dispatch(addTodo(text)) 异步 Action 当调用异步 API时，发送请求和响应（可能超时），都可能会更改 state；因此需要 同步地 dispatch 由reduce 处理的操作通常需要对应三种 action: 通知 reducer 请求开始的action：reducer 可能会切换state中的 flag,来更改UI状态。 通知 reducer 请求成功的action：reducer 可能会将接收到的数据合并到 state 中，并更改 flag,控制 UI。 通知 reducer 请求失败的action：reducer 可能会重置 flag,并将一些失败在UI中信息显示出来 至于flag如何定义完全取决于开发者，使用多个type会降低出错几率。123&#123; type: 'FETCH_POSTS_REQUEST' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', response: &#123; ... &#125; &#125; 注意：在实际应用中，网络请求失败时也需要 dispatch action。 待续。。。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactDOM API]]></title>
    <url>%2F2019%2F08%2F02%2FreactDomAPI%2F</url>
    <content type="text"><![CDATA[react-dom react-dom 的 package 提供了可在应用顶层使用的DOM方法，所有的顶层 API 都可调用 React 支持所有的现代浏览器，IE9及以上版本，但是需要引用相关 polyfills,那些在不兼容ES5语法的浏览器中奋斗的同志需要孤军奋战了。 APIrender()12import ReactDOM from 'react-dom'ReactDOM.render(element,container[, callback]) 在提供的container里渲染一个 React 元素，并返回该组件的引用, 对于 无状态组件返回 null。如果 React 元素 已经在 container中渲染过，那么将会更新里面的元素，并仅会在必要的时候改变DOM 映射新的 React 元素。callback将在组件被渲染或更新后执行 当首次调用时，container节点中所有DOM元素都会被替换，后续的调用则使用 React 的 DOM diff 算法 进行高效更新。rend()不会修改container节点，之后修改子节点，可以在不覆盖现有子节点的情况下，将组件插入已有的DOM节点中。对服务端渲染容器进行 hydrate操作的方式已被废弃，且会在 1rend()目前会返回对根组件 ReactComponent 实例的引用。但应该避免使用它，因为历史遗留下来的内容，在未来版本中，组件渲染某些情况下可能会是异步的。对服务端渲染容器进行 hydrate操作的方式已被废弃，且会在 1如果需要根组件 ReactComponent 实例的引用，推荐使用callback ref。使用rend()对服务端渲染容器进行 hydrate操作的方式已被废弃，且会在 17版中被 hydrate() hydrate()1ReactDOM.hydrate(element,container[, callback]) 此方法和 render()相同，区别在于 ReactDOMServer 渲染的容器中对HTML的内容进行 hydrate 操作。React 会尝试在已有的标记上绑定事件监听器。 unmountComponentAtNode()1ReactDOM.unmountComponentAtNode(container) 此方法将卸载 DOM 中的组件，会将事件处理器和 state 一并清除。如果指定的 container 中没有对应已挂在的组件，那么此方法什么也不会做，如果组件被移除将会返回 true，如果未移除将返回false findDOMNode()1ReactDOM.findDOMNode(component) 如果组件已被挂载到DOM上，此方法会返回浏览器中x相应的原生DOM，不能用于函数组件，对于在未挂载的组件中调用将发生异常。对于读取DOM中的值很有用，一般推荐使用 ref来获取DOM元素 此方法是访问底层DOM节点的应急方案，严格模式中被弃用 createPortal()1ReactDOM.createPortal(child,container) 创建portal，它提供一种将子节点渲染到DOM节点中的方式，该节点存在于DOM组件的乘此结构之外。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>ReactDOM API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React API]]></title>
    <url>%2F2019%2F07%2F31%2FreactAPI%2F</url>
    <content type="text"><![CDATA[createElement() 创基并返回指定类型的 React元素。其中类型参数既可以是DOM标签字符串，也可以是React组件类型,或是React fragment类型 1React.createElement(type,[props],[...children]) JSX 编写的代码将会被转换成使用 React.createElement() 的形式。 cloneElement() 以 element 元素为样板克隆并返回新的React元素，返回元素的props将新的props与原始的prosp浅合并。新的子元素取代现有的子元素，原始元素的 key 和 ref 将被保留 通过 ref 获取子节点时，将不会意外地从祖先节点上窃取它。相同的 ref 将添加到克隆后的新元素中。1React.cloneElement(element,[props],[...children]) isValidElement() 验证对象是否为React元素，返回值为 true or false React.children 提供用于处理 this.props.children 不透明数据结构的方用方法。 React.Children.map 在每个直接子节点上调用一个函数，并将 this(执行期上下文) 设置为 thisArg。 如果Children 是一个数值，它将被遍历并为数组中的每个子节点调用该函数。 如果子节点为null 或 undefined,则返回对应的 null 或 undefined。 12React.Children.map(children,function[(thisArg)]) 如果children 是一个Frgment对象，它将被视为单一子节点的情况处理，不被遍历 React.Children.forEach 和 React.Children.map 类似，但是不会返回数组12React.Children.forEach(children,function[(thisArg)] ) React.Children.count 返回 children 中组件总数12React.Children.count(children) React.Children.only 验证children是否只有一个React元素，有则返回它，无则抛出错误 12React.Children.only(children) **此方法不接受React.Children.map的返回值，因为它是一个数组 React.Children.toArray 将children 这个复杂的数据结构以数组的形式扁平展开并返回，且为每个子节点分配一个key.想要在渲染函数中操作子节点的集合时，非常实用12React.Children.toArray(children) 注意：此方法在拉平展开节点列表时，更改key值以保留嵌套数组的语言。即 toArray 会为返回数组中的每个key添加前缀，使每个元素key的范围都限定在此函数入参数组的对象内 React.Fragment React.Fragment 能在不额外创建DOM元素情况下，让 render方法返回多个元素 1234567891011121314151617181920render()&#123; return ( &lt;React.Fragment&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/React.Fragment&gt; )&#125;// 简写render()&#123; return ( &lt;&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/&gt; )&#125; 更多信息 React.createRef 创建一个能通过 ref 属性附加到 React元素的 ref 123456789101112class Example extends React.Componet &#123; constructor(props)&#123; this.inputRef = React.createRef(); &#125; reder()&#123; return &lt;input type="text" ref= &#123;this.inputRef&#125; /&gt;； &#125; componentDidMount()&#123; this.inputRef.current.focus() &#125;&#125; React.forwardRef React.forwardRef 会创建一个React组件，能将其接受的ref 属性转发到其组件树下的另一个组件中。 转发refs到DOM组件 在高阶组件中转发 refs React.forwardRef接受渲染函数作为参数。使用props和ref z作为参数调用此函数，返回 React节点 1234567const Example = React.forwardRef((props,ref)=&gt; ( &lt;button ref=&#123;ref&#125; className="FancyButton"&gt; &#123;props.children&#125; &lt;/button&gt;));// You can now get a ref directly to the DOM button:const ref = React.createRef();&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;; React.lazy React.lazy()允许你定义一个动态加载组件。有助于减少 bundle的体积，并提高首屏加载效率 此特性需要支持 promise1const component = React.lazy(()=&gt; import('./component')) // 动态加载 参考文章 React.Suspense React.Suspense 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。目前，懒加载组件是 &lt;React.Suspense&gt; 支持的唯一用例： 12345678910111213// 该组件是动态加载的const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));function MyComponent() &#123; return ( // 显示 &lt;Spinner&gt; 组件直至 OtherComponent 加载完成 &lt;React.Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt; &lt;div&gt; &lt;OtherComponent /&gt; &lt;/div&gt; &lt;/React.Suspense&gt; );&#125; 请注意，lazy 组件可以位于 Suspense 组件树的深处——它不必包装树中的每一个延迟加载组件。最佳实践是将 &lt;Suspense&gt; 置于你想展示加载指示器（loading indicator）的位置，而 lazy() 则可被放置于任何你想要做代码分割的地方。 虽然目前尚未支持其它特性，但未来我们计划让 Suspense 支持包括数据获取在内的更多场景。可以在roadmap 中了解相关信息。 React.lazy() 和 &lt;React.Suspense&gt; 尚未在 ReactDOMServer 中支持。这是已知问题，将会在未来解决。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 生命周期函数]]></title>
    <url>%2F2019%2F07%2F29%2FreactLifeCycle%2F</url>
    <content type="text"><![CDATA[组件生命周期函数 React 主动调用的方法，也可重写这些方法 生命周期图谱 当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：constructor(props) 如果不需要初始化 state 或 不进行方法绑定，则不需要使用该方法 在组件挂载之前会先调用该方法，在实现构造函数时必须先调用super(props)方法，否则会出现BUG通常，构造函数仅用于两种情况：1. 初始化 state 2. 为事件处理函数绑定实例在该方法中不要使用 setState() 方法,在其他方法中使用setState()改变 state为什么 props 复制给 state 会产生 bug123456789constructor(props) &#123; super(props); // 不要在这里调用 this.setState() this.state = &#123; counter: 0, name:props.name // 严禁这样赋值，props.name值更新时 state.name并不会更新 &#125;; this.handleClick = this.handleClick.bind(this);&#125; static getDerivedStateFromProps() （此方法不常用） 此方法会在 render 方法之前调用，并且初始化和数据更新时都会调用，它返回一个对象更新 state，如果返回null 则不更新任何内容。 此方法适用于 state 值在任何时候都取决于props 的情况。 render() render 是 class 组件必须实现的方法 当该方法被调用时，它会监测 props 和 state 的变化，并且返回以下类型之一： React 元素：通过JSX创建，渲染成对应的DOM节点或自定义组件 数组或fragments： 使render方法可以返回多个元素 frgments Portals：可以渲染子节点到不同的DOM子树汇中portals 字符串或数值类型： 在DOM中会被渲染为文本节点、 Boolean 或 null：什么都不渲染 render方法最好为纯函数，即在不修改组件 state情况下，每次调用时都返回相同的结果，并且不会直接与浏览器交互 如果要和浏览器交互，可以在其他生命周期函数中执行，注意：shoouldComponentUpdate方法中返回false,将不会调用render方法 12345678class Example extemds React.Component&#123;shouldComponentUpdate(nextProps, nextState)&#123; return false&#125;render()&#123; // 不会执行 &lt;div&gt;owen&lt;/div&gt; &#125;&#125; componentDIdMount() 此方法会在组件挂载后（插入DOM树中）调用，初始化的数据的好地方 组件的 props 或 state 发生变化会触发更新。组件更新的生命周期调用顺序如下：static getDerivedStateFromProps() （此方法不常用）(已解释)shouldComponentUpdate(nextProps, nextState) （此方法不常用） 当state 或 props 变化时该方法会在渲染执行前调用默认返回值为true,首次加载不会被调用 根据该方法的返回值判断组件输出是否受当前 state 或 props 更改的影响。默认为 state 每次更新重新渲染 此方法进仅做为性能优化的方式存在，不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。 render()(已解释)getSnapshotBeforeUpdate() （此方法不常用） 此方法在最近一次渲染输出（提交到DOM节点）之前调用。使组件能在发送更改前从DOM中捕获一些信息（如 位置）。此生命周期的返回值将作为参数传递给 componentDidUpdate()1234567891011121314151617181920212223242526272829303132class ScrollingList extends React.Component &#123; constructor(props) &#123; super(props); this.listRef = React.createRef(); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // 我们是否在 list 中添加新的 items ？ // 捕获滚动​​位置以便我们稍后调整滚动位置。 if (prevProps.list.length &lt; this.props.list.length) &#123; const list = this.listRef.current; return list.scrollHeight - list.scrollTop; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items， // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。 //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值） if (snapshot !== null) &#123; const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); &#125;&#125; 上述示例中，重点是从 getSnapshotBeforeUpdate 读取 scrollHeight 属性，因为 “render” 阶段生命周期（如 render）和 “commit” 阶段生命周期（如 getSnapshotBeforeUpdate 和 componentDidUpdate）之间可能存在延迟。 componentDidUpdate(prevProps, prevState, snapshot) 此方法会在数据更新后立即调用，首次加载不会被调用,在此方法中使用 setState必须将它放到条件语句中，否则会导致死循环。还会导致额外的重新渲染，影响性能 123456componentDidUpdate(prevProps) &#123; // 典型用法（不要忘记比较 props）： if (this.props.userID !== prevProps.userID) &#123; this.fetchData(this.props.userID); &#125;&#125; 注意：如果 shouldComponentUpdate() 返回值为 false，则不会调用 componentDidUpdate()。 当组件从 DOM 中移除时会调用如下方法：componentWillUnmount() 此方法会在组件卸载销毁前调用，可以执行必要的清理操作，如 定时器，取消网络请求，或清除componentDidMount() 中创建的订阅等。 当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：Error boundaries：捕获渲染期间及整个树的函数发送的错误，渲染降级 UI，但自身的错误无法捕获 React 16中的错误处理 static getDerivedStateFromError(error) （此方法不常用） 次生命周期会在后代组件抛出错误后调用，将错误作为参数，返回一个值更新state，在渲染期间不允许出现副作用，建议使用 componentDidCatch() componentDidCatch(error, info) （此方法不常用） 此方法在后代组件抛出错误后被调用 如果发生错误，可以通过调用 setState 使用 componentDidCatch() 渲染降级 UI，但在未来的版本中将不推荐这样做。 可以使用静态 getDerivedStateFromError() 来处理降级渲染。123456789101112131415161718192021222324252627class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; static getDerivedStateFromError(error) &#123; // 更新 state 使下一次渲染可以显降级 UI return &#123; hasError: true &#125;; &#125; componentDidCatch(error, info) &#123; // "组件堆栈" 例子: // in ComponentThatThrows (created by App) // in ErrorBoundary (created by App) // in div (created by App) // in App logComponentStackToMyService(info.componentStack); &#125; render() &#123; if (this.state.hasError) &#123; // 你可以渲染任何自定义的降级 UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; Example123456789101112131415161718192021222324252627282930313233343536373839404142434445class Square extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value:null &#125;; &#125; static getDerivedStateFromProps(props, state) &#123; // 实例化组件之后以及在重新呈现组件之前调用新的静态生命周期。它可以返回要更新的对象state，或null指示新对象props不需要任何state更新。 &#125; componentDidMount() &#123; // 组件被渲染到 DOM 中后运行 console.log('DidMount: 1') &#125; shouldComponentUpdate()&#123; // 更新前 &#125; getSnapshotBeforeUpdate()&#123; // &#125; componentDidUpdate() &#123; // 更新后 &#125; static getDerivedStateFromError() &#123; // 出错时 &#125; componentDidCatch()&#123; // capture error &#125; compoentwillUnmount()&#123; // 组件被删除的时候 console.log('UnMount: end') &#125; render() &#123; return ( &lt;button className="square" onClick = &#123;()=&gt;&#123;this.setState(&#123;value:'X'&#125;)&#125; &#125;&gt; &#123;this.state.value&#125; &lt;/button&gt; ); &#125;&#125; 参考资料]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React life cycle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React.Component API]]></title>
    <url>%2F2019%2F07%2F29%2Freact.Component%2F</url>
    <content type="text"><![CDATA[React.Component 使用ES6 classes 方式定义React组件的基类最好不要建立自己的组件基类，因为，在React组件中，代码重用的主要方式是组合而不是继承 setState(updater[, callback]) 用于更新用户界面以响应事件处理器和处理服务器数据的主要方法 此方法不会总数立即更新组件，他会批量推迟更新，如果需要使用setState 后立即读取 state可能会是旧值。使用 componentDidMount 方法或使用 setState的回调函数可解决旧值问题。注意 shouldComponentUpdate 方法返回false，将不会重新渲染页面 参数一 updater函数 或者对象 带有连个形参的函数 或者一个对象类型12345// updater functionthis.setState((state,props)=&gt;(&#123;name:state.name+props.name&#125;))// object typethis.setState(&#123;name:this.state.name&#125;) updater 函数中 state 是对应组件 state 的引用，它不应直接被修改；须返回一个对象，会与state进行浅合并 object 类型中 setState 也是异步的，并在同一周期内对多个 setState 进行处理,如果后续状态取决于当前状态，建议使用 updater 函数的形式代替。example：123456Object.assign( previousState, &#123;count: state.count + 1&#125;, &#123;count: state.count + 1&#125;, ...) 深入学习：何时以及为什么 setState() 会批量执行？深入：为什么不直接更新 this.state？ setState的第二个参数为可选的回调函数，它将在setState 完成合并并重新渲染组件后执行，通常建议使用componentDidMount方法代替。 forceUpdate(callback) 默认情况下，组件数据发生变化就会重新渲染，如果 render 方法依赖其他数据，可以使用 forceUpdate 强制让组件刷新 此方法会跳过 shouldComponentUpdate方法。但是子组件会正常触发。通常应该避免使用forceUpdate方法，尽量在render方法中使用 state 和 props。 Class属性defaultProps此属性可以给对应的组件添加 props,通常用于 prop未赋值且不能为null。example：12345678910111213141516class Example extends React.Component &#123; render()&#123; return ( &lt;div&gt; &lt;h3&gt;&#123;this.props.name&#125;&lt;/h3&gt; &lt;main&gt; &lt;Text text ='null'/&gt; // props.text 将是 null &lt;/main&gt; &lt;/div&gt; ) &#125;&#125;Example.defaultProps = &#123; name:'Owen', text:'Owen is a programmer '&#125; 实例属性props 类似 vue中的 propsthis.props 包括被该组件调用者定义的 props。其中this.props.children 是一个特殊的 prop，通常由 JSX 表达式中的子组件组成，而非组件本身定义。 state 类似 vue 中的data组件中 state 包含随时可能发生变化的数据。由用户自定义，是一个普通的对象，永远不要直接改变 this.state，因为后续调用的 setState() 可能会替换掉你的改变。请把 this.state 看作是不可变的。 React.PureComponent React.PureComponent 与 React.Component 相似二者区别于 shouldComponentUpdate的实现 React.Component 并未实现 shouldComponentUpdate方法 React.PureComponent 中以层对比 prop 和state 的方式实现shouldComponentUpdate方法 在某些情况下使用React.PureComponent可提高性能注意：如果对象中包含赋值的数据结构，可能因无法监测深层次的差别，产生错误的对比结果。所以仅在props和state较为简单时使用React.PureComponent。此外，shouldComponentUpdate方法会跳过所有子组件树的prop 更新 React.memo React.memo 是高级函数组件，它与 React.pureComponent 相似，但不支持class组件。此方法仅做为性能优化的方式存在1234const MyMemo = (props) =&gt;&#123; return &lt;li&gt;/* ... */&lt;/li&gt;&#125;const MemoComponent = React.memo(MyMemo) 如果函数组件在给定相同的 props 情况下渲染结果相同，就可将其保证在 React.memo中调用，这样就可通过记忆组件渲染结果的方式来提高组件的性能，意味着React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。 默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。1234567891011function MyComponent(props) &#123; /* 使用 props 渲染 */&#125;function areEqual(prevProps, nextProps) &#123; /* 如果把 nextProps 传入 render 方法的返回结果与 将 prevProps 传入 render 方法的返回结果一致则返回 true， 否则返回 false */&#125;export default React.memo(MyComponent, areEqual); 参考资料]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 基础学习]]></title>
    <url>%2F2019%2F07%2F23%2Freact%2F</url>
    <content type="text"><![CDATA[概览 React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript库。可以将一些简短、独立的代码片段组合成复杂的UI界面，这些片段被称为“组件”。 React 大体包含下面这些概念： 组件 JSX Virtual DOM Data Flow 组件 可以将UI 拆分为独立且复用的代码片段，每部分都可独立维护。组件，从概念上类似于 JavaScript 函数。它接受任意的参数（即 “props”），并返回用于描述页面展示内容的React 元素。自定义组件命名：必须以大写字母开头，React 会将以小写字母开头的组件视为原生DOM标签。123456789101112131415161718192021import React from 'react'; // React 的核心库import ReactDOM from 'react-dom'; // 提供与 DOM 相关的功能class ShoppingList extends React.Component &#123; render() &#123; return ( &lt;div className="shopping-list"&gt; &lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Instagram&lt;/li&gt; &lt;li&gt;WhatsApp&lt;/li&gt; &lt;li&gt;Oculus&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;ShoppingList name="Mark" /&gt;, document.getElementById('root')); React 应用都是构建在组件之上。ShoppingList就是一个React 组件类型，ReactDOM.render 函数会将组件方到页面上的某个节点元素中。(render 返回了一个 React 元素 ，这是一种对渲染内容的轻量级描述。)大多数 React应用只会调用一次 ReactDOM.render()。 其中props（是 properties 的简写） 是组件包含的两个核心概念之一，另一个是state。 propsprops接收一些其他组件的参数（比如上方的 name )，来配置组件，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。 statestate 来实现所谓“记忆”的功能。可以通过 React 组件的构造函数中设置 this.state;this.state 应该被视为一个组件的私有属性。修改this.state值需要通过this.setState方法赋值,有些 props 值或 state 值可能是异步更新的，使用对象赋值的方式更改 state 可能无效，可使用回调传参方式更新1this.setState( (state,props)=&gt; (&#123;count:state.count + props.count&#125;) ); 类组件 通过 class 语法来定义组件，必须包含render() 方法,并且继承于 React.Component。类组件必须包含render()，并且return 只能返回一个父元素（类似vue中的template中必须要有一个父元素）。1234567891011121314151617181920212223class Square extends React.Component &#123; /** * @name constructor * @param &#123;*&#125; props * 每次定义子类的构造函数时，都必须调用 super 方法。 * 因此，在所有含有构造函数的React组件中，构造函数必须以super(props)开头 * state 保存着组件中的数据 类似 vue 中的 data 属性 */ constructor(props) &#123; super(props); this.state = &#123; value:null &#125;; &#125; render() &#123; return ( &lt;button className="square" onClick = &#123;()=&gt;&#123;this.setState(&#123;value:'X'&#125;)&#125; &#125;&gt; &#123;this.state.value&#125; &lt;/button&gt; ); &#125;&#125; render方法中的onClick 事件监听函数中调用this.setState方法，可以设置this.state 中的属性推荐使用箭头函数，避免this 造成困扰。 简单组件(函数组件)简单组件是一个函数，不需要使用class关键字，当然就没有constructor和state 12345const Square = (props) =&gt; &#123; return (&lt;button className= "square" onClick= &#123; props.onClick&#125; &gt;&#123; props.value &#125; &lt;/button&gt;)&#125; 受控组件input、&lt;select&gt;、&lt;textarea&gt; 等表单的状态发生改变，都得同时通过onChange事件改变组件中的state值，否则表单不会发生变化。通过这种方式控制取值的表单叫做受控组件。1234567891011121314151617181920212223242526class Input extends Component &#123; constructor(props)&#123; super(props) this.state = &#123; value:'3s' &#125; &#125; render ()&#123; return &lt;input type="text" value = &#123;this.state.value&#125; /&gt; // 用户在表单中输入任何信息都是无效的 &#125;&#125;// 使用事件来改变 render ()&#123; return ( &lt;input type="text" value = &#123;this.state.value&#125; onChange = &#123;(&#123;target&#125;) =&gt;&#123; this.setState(&#123; value:target.value &#125;) &#125;&#125; /&gt; ) &#125; React受控组件更新state的流程: 通过在初始化state中设置表单默认值； 每当表单值发生变化时，调用onChange事件 事件通过合成的事件对象来改变状态更新 state setState触发视图渲染更新，完成表单组件值的更新 渲染多个组件将组件变成数组集合放入花括号中即可渲染多个组件,通常使用数组的map()方法123456789const Lis = (props) =&gt; &#123; const lis = props.list.map((val,key)=&gt; &lt;li key=&#123;key&#125;&gt;&#123;key+1&#125;&lt;/li&gt;); return &lt;ul&gt;&#123;lis&#125;&lt;/ul&gt;&#125;const list = Array(7).fill(null);ReactDOM.render( &lt;Lis list = &#123;list&#125; /&gt;, document.getElementById('root')); 状态提升当多个组件发生数据联动时，建议将共享状态提升到最近的共同父组件中去。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* * @Author: Owen * @Date: 2019-07-23 23:55:17 * @Last Modified by: Owen * @Last Modified time: 2019-07-29 16:06:22 */import React,&#123;Component&#125; from 'react';import &#123;render&#125; from 'react-dom';// 温度转化器let toConvert = (temperature,callback) =&gt; &#123; let num = parseInt(temperature); if(Number.isNaN(num)) return '' num = callback(num) return Math.round(num*1000)/1000;&#125;const BoilingVerdict = (props) =&gt;&#123; let text = props.temperature &gt; 100?'':' not'; return (&lt;p&gt; The water would&#123;text&#125; boil. &lt;/p&gt;)&#125;// 公共input组件只接收行为和状态const TemperatureInput = (props) =&gt;&#123; return ( &lt;input value =&#123;props.temperature&#125; onChange = &#123;props.valueChange&#125; /&gt; )&#125;// 父组件设置行为和状态class Calculator extends Component &#123; constructor(props)&#123; super(props) this.state = &#123; temperature:'', scale:'C' &#125; &#125; toFahrenheit(&#123;target&#125;) &#123; this.setState(&#123; temperature:target.value, scale:'F' &#125;) &#125; toCelsius(&#123;target&#125;) &#123; this.setState(&#123; temperature:target.value, scale:'C' &#125;) &#125; render() &#123; let &#123;temperature,scale&#125; = this.state; let celsius = scale === 'F'?toConvert(temperature,(val)=&gt;(val - 32)*5/9):temperature; let fahrenheit = scale === 'C'?toConvert(temperature,(val)=&gt;val*9/5+32):temperature; return ( &lt;div&gt; &lt;div&gt; Celsius： &lt;TemperatureInput scale ='C' temperature = &#123;celsius&#125; valueChange = &#123;this.toCelsius.bind(this)&#125; /&gt; &lt;/div&gt; &lt;div&gt; Fahrenheit： &lt;TemperatureInput scale ='F' temperature = &#123;fahrenheit&#125; valueChange = &#123;this.toFahrenheit.bind(this)&#125; /&gt; &lt;/div&gt; &lt;div&gt;&lt;BoilingVerdict temperature = &#123;this.state.temperature&#125; /&gt;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;render(&lt;Calculator /&gt;,document.querySelector('#root')) 在就React 应用中，任何科比数据应当只有一个相对应的数据源，通常，多个组件需要相同数据，可以将数据提升到这些组件的共同父组件中。依靠自上而下的数据流，去控制组件，而不是尝试在不同组件同步 state。这样会减少将来排查和隔离BUG所需要的工作量 组合（类似vue中的 slot）有些组件无法提前知晓它们子组件的具体内容，需要留坑，那么也可以通过 props来占位。 默认坑位props.children件起始标签和结束标签之间的内容都会被将{props.children}替换。12345678910111213141516171819function FancyBorder(props) &#123; return ( &lt;div className=&#123;'FancyBorder FancyBorder-' + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125;function WelcomeDialog() &#123; return ( &lt;FancyBorder color="blue"&gt; &lt;h1 className="Dialog-title"&gt; Welcome &lt;/h1&gt; &lt;p className="Dialog-message"&gt; Thank you for visiting our spacecraft! &lt;/p&gt; &lt;/FancyBorder&gt; );&#125; 自定义坑位因为 React元素 本质就是对象，所以可以将它当中参数像其他数据一样传递。123456789101112131415161718192021222324function SplitPane(props) &#123; return ( &lt;div className="SplitPane"&gt; &lt;div className="SplitPane-left"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className="SplitPane-right"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125; JSX 每个 JSX 元素都是调用 React.createElement() 的语法糖。一般来说，如果你使用了 JSX，就不再需要调用createElement()或createFactory()方法。React 提出的一种叫 JSX 的语法，这应该是最开始接触 React 最不能接受的设定之一,因为前端被“表现和逻辑层分离”这种思想“洗脑”太久了。实际上组件的 HTML 是组成一个组件不可分割的一部分，能够将 HTML 封装起来才是组件的完全体. JSX是一个JavaScript语法扩展。它类似于模板语言，但它具有JavaScript 的全部能力。它最终会被编译为React.createElement()函数调用，返回称为 React元素的普通JavaScript`对象。 推荐使用箭头函数，避免this 造成困扰 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 function Square(props) &#123; return ( &lt; button className = "square" onClick = &#123; props.onClick &#125; &gt; &#123; props.value &#125; &lt;/button&gt; );&#125;class Board extends React.Component &#123; constructor(props)&#123; super(props) this.state = &#123; squares: Array(9).fill(null), xIsNext:true, // 先落子，并确认该哪位玩家落子 &#125; &#125; /** * 只接受一个squares副本，而不直接修改本身数据 * 1. 这样可以简化复杂的功能，不可变性使得复杂的特性更容易实现。 * 2. 可以跟踪数据的改变，如果直接修改源数据就很难跟踪变化的数据。 * 3. 可以帮助我们在 React 中创建 purecomponents。可以轻松的确定不可变数据是否发生了改变， * 从而确定何时对组件进行重新渲染。 * @param &#123;*&#125; i * @memberof Board */ handleClick(i) &#123; const squares = this.state.squares.slice(); squares[i] = this.state.xIsNext? "X":"O"; this.setState(&#123; squares,xIsNext:!this.state.xIsNext &#125;) &#125; renderSquare(i) &#123; // 返回一个 Square 组件 return ( &lt; Square value = &#123; this.state.squares[i] &#125;// 给子组件传递 value数据 onClick = &#123;()=&gt; this.handleClick(i)&#125; // 给子组件传递 onClick事件 /&gt;); &#125; render() &#123; let &#123;state&#125; = this; const status = `Next player: $&#123;state.xIsNext?'X':'O'&#125;`; return ( &lt;div&gt; &lt;div className="status"&gt;&#123;status&#125;&lt;/div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(0)&#125; &#123;this.renderSquare(1)&#125; &#123;this.renderSquare(2)&#125; &lt;/div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(3)&#125; &#123;this.renderSquare(4)&#125; &#123;this.renderSquare(5)&#125; &lt;/div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(6)&#125; &#123;this.renderSquare(7)&#125; &#123;this.renderSquare(8)&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 在 JSX 中你可以任意使用JavaScript表达式，只需要用一个大括号({})括起来；事实上每个 React 元素都是一个JavaScript 对象，可以把它保存在变量中或者作为参数传递。 为避免遇到自动插入分号陷阱，最好将内容包裹在小括号中，如果只有一行代码则不需要括号。 12345678910111213141516171819202122// 加括号class App extends React.Component &#123; render() &#123; return ( &lt;div className="shopping-list"&gt; &lt;h1&gt;Shopping List for&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Instagram&lt;/li&gt; &lt;li&gt;WhatsApp&lt;/li&gt; &lt;li&gt;Oculus&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;// 不用加括号class App extends React.Component &#123; render() &#123; return &lt;li&gt;Instagram&lt;/li&gt;; &#125;&#125; JSX 语法更接近于 JavaScript，所以 ReactDom 使用cameCase(小驼峰命名)来定义属性名称,并且不要使用引号将大括号包裹，两者是不能并存的。对于字符串值使用引号，对于表达式使用大括号 React 中无法通过 return false 的方式阻止默认行为，必须使用e.preventDefault()阻止默认事件。但是不用担心event事件的兼容问题 JSX 本身就能防止XSS攻击123456789101112131415161718// 原生DOM&lt;a href="#" onclick="console.log('The link was clicked.'); return false"&gt; Click me&lt;/a&gt;// JSXclass App extends React.Component &#123; render() &#123; return ( &lt;a href="#" onclick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt; //每次渲染时都会创建不同的回调函数。该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。 Click me &lt;/a&gt;; &lt;a href="#" onclick=&#123;(e)=&gt;this.handleClick(id,e)&#125;&gt; // 向事件处理程序传递参数 Click me &lt;/a&gt;; ) &#125;&#125; 事件处理程序回调函数中的 this 在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this的值为 undefined。123456789101112131415161718class App extends React.Component &#123; // 此语法确保 `handleClick` 内的 `this` 已被绑定。 // 注意: 这是 **实验性** 语法。 使用 Create React App 默认会启用此语法 handleClick = (e)=&gt; &#123; e.preventDefault(); console.log(e) &#125; render() &#123; return ( &lt;a href="#" onclick=&#123;this.handleClick&#125;&gt; Click me &lt;/a&gt;; &lt;a href="#" onclick=&#123;this.handleClick。bind(this,id)&#125;&gt; // 向事件处理程序传递参数, 事件对象会被隐式传递 Click me &lt;/a&gt;; ) &#125;&#125; Virtual DOM 当组件状态state有更改的时候，React会自动调用组件的render方法重新渲染整个组件的UI。 React实现了一个Virtual DOM，组件 DOM 结构就是映射到这个Virtual DOM 上，React 在这个Virtual DOM 上实现了一个diff算法，当要重新渲染组件的时候，会通过diff 寻找到要变更的DOM 节点，再把这个修改更新到浏览器实际的DOM 节点上，所以实际上不是真的渲染整个DOM树(React DOM 只会更新实际改变了的内容)。这个 Virtual DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 单例模式 （Singleton Pattern）]]></title>
    <url>%2F2019%2F07%2F21%2FsingletonPattern%2F</url>
    <content type="text"><![CDATA[概念 确保只有一个实例，并提供全局访问。 实现思路一个类能返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法，通常命名为getIntance）；当我们调用这个方法时，类持有的引用不为空则返回这个引用，如果为空须创建该类实例并将实例的引用赋予该类保持的引用；同时将该类的构造函数定义为私有方法，那么其他环境就无法通过调用该类的构造函数来实例化该类的对象，只能通过该类提供的静态方法得到该类唯一的实例。 实现 Java 语言中的单例模式1234567891011121314151617public class Singleton &#123; private static final Singleton &#123; private Singleton() &#123; &#125;; public static Singleton getInstance &#123; if (INSTANCE == null) &#123; synchronized(Singleton.class) &#123; if(INSTANCE = null) &#123; INSTANCE = new Singleton() &#125; &#125; &#125; return INSTANCE; &#125; &#125;&#125; 实现 JavaScript 语言中的单例模式12345678910111213141516let Singleton = function(name)&#123; this.name = name;&#125;Singleton.prototype.getName = function() &#123; console.log(this.name)&#125;Singleton.getInstance = (function() &#123; let instance; return function(name) &#123; if(instance) return instance; return instance = new Singleton(name) &#125;&#125;)()let s1 = Singleton.getInstance('owen'); // Singleton &#123;name: "owen"&#125;let s2 = Singleton.getInstance('guowen'); // Singleton.getInstance('guowen');s1 === s2 // true JavaScript中单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。 应用命名空间使用命名空间可以降低全局变量带来的命名污染；最简单的方法是对象字面量12345const globalWeb = &#123; a() &#123;&#125;, b() &#123;&#125; // ...&#125; 或者使用闭包1234567891011121314151617181920let Singleton = (function()&#123; let instance; let init = function() &#123; let name = 'owen'; return &#123; name, data()&#123; return &#123;&#125; &#125;, method:&#123; &#125; &#125; &#125; return &#123; getInstance() &#123; if(instance) return instance; return instance = init() &#125; &#125;&#125;())let app = Singleton.getInstance() // &#123;name: "owen", data: ƒ, method: &#123;…&#125;&#125; 惰性单例 惰性单例指在需要的时候才创建对象实例，在实现开发中非常有用，即目标对象只有在使用的时候才被创建，而不是页面加载好时创建。 模态框示例 点击一个按钮弹窗一个模态框，很明显页面是唯一的，一次不会弹窗多个模态框的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;modal box&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding:0; &#125; html&#123; width:100%; height:100%; &#125; .Owen &#123; width:30%; height:30%; margin:10% auto; &#125; #modal &#123; width:100%; height:100%; position:fixed; left:0; top:0; background: rgba(0, 0, 0, 0.52); display:none; &#125; .main&#123; width:30%; height:30%; margin:10% auto; text-align: center; background-color: #b0e8ff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="Owen"&gt; &lt;button&gt;Owen&lt;/button&gt; &lt;/div&gt; &lt;div id="modal"&gt; &lt;div class="main"&gt; &lt;div&gt; 我是弹框 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function()&#123; let openModal = document.querySelector("button") let modal = document.querySelector("#modal") openModal.addEventListener('click',function()&#123; modal.style.display = 'block' &#125;)&#125;&lt;/script&gt;&lt;/html&gt; 第一种方法是在页面加载完成时创建好这个弹框，一开始就是隐藏的，只有点击按钮的时候才显示，这种方式有一个问题，就是我们进入页面，只是看看其他内容，不做任何操作；这样就造成资源浪费 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;modal box&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding:0; &#125; html&#123; width:100%; height:100%; &#125; .Owen &#123; width:30%; height:30%; margin:10% auto; &#125; #modal &#123; width:100%; height:100%; position:fixed; left:0; top:0; background: rgba(0, 0, 0, 0.52); &#125; .main&#123; width:30%; height:30%; margin:10% auto; padding:20px; text-align: right; background-color: #b0e8ff; position:relative; &#125; .main div &#123; text-align: center; &#125; .main span &#123; display: inline-block; padding:5px; cursor:pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="Owen"&gt; &lt;button&gt;点我&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function()&#123; init()&#125;function init() &#123; let openModal = document.querySelector("button") let createModal =( function() &#123; let flag; // 生成 Modal 容器 let div = document.createElement('div') div.id = "modal" div.style.display = "none"; return function() &#123; if(flag) return div; flag = true; let fra = document.createDocumentFragment(); // 添加 Modal 内容 els = `&lt;div class="main"&gt; &lt;span class="close"&gt;×&lt;/span&gt; &lt;div&gt; 我是弹框 &lt;/div&gt; &lt;/div&gt; ` div.innerHTML = els; fra.appendChild(div) document.body.appendChild(fra) // 关闭 Modal let close = document.querySelector('.close') close.addEventListener('click',function()&#123; flag = false; document.body.removeChild(div) &#125;) return div &#125; &#125;()) // 显示 Modal openModal.addEventListener('click',function()&#123; createModal().style.display = "block"; &#125;)&#125;&lt;/script&gt;&lt;/html&gt; 第二种方法，只执行一次DOM的创建修改操作，不用频繁的创建和删除节点，提高资源利用率； 参考资料 《JavaScript设计模式与开发实践》基维 大叔]]></content>
      <categories>
        <category>design patterns</category>
      </categories>
      <tags>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 高阶函数（Heigher-order function）]]></title>
    <url>%2F2019%2F07%2F12%2FdesignPatterns3%2F</url>
    <content type="text"><![CDATA[什么是高阶函数 《javascript设计模式和开发实践》中定义 函数既可作为参数被传递，也可以作为返回值输出 满足以下条件: 接受一个或多个函数作为输入 输出一个函数 高阶函数一般是那些函数型包含多于函数。在函数式编程中，返回另一个函数的高阶函数被称为Curry化的函数。 函数作为参数传递 将函数作为参数传递，我们就可以抽离以部分容易变化的业务逻辑，这样可以分离业务代码中变与不变的部分 回调函数： 将函数传进一个方法中，函数不会立即执行，等待出来结果之后在执行。123456789let func = function (callback)&#123; if(n === 'owen')&#123; callback() //回调函数 &#125;&#125; function say ()&#123; console.log('Hello Word') &#125; func(say) Array 对象常用的方法 1234[1,2,3,4].forEach(iteration) function iteration(v)&#123; console.log(v) &#125; 作为返回值输出 让函数继续返回一个可执行的函数，意味着运行过程是可延续的。 判断数据类型1234567891011121314151617let type = type =&gt;&#123; return obj =&gt; Object.prototype.toString.call(obj) === `[object $&#123;type&#125;]`&#125;let isArray = type('Array'),isString = type('String'),isNumber = type('Number'),isObject = type('Object');// orlet Type = (function()&#123; let type = &#123;&#125;,types = ['Object','Array','Number','String'] for (let val of types) &#123; (function(str)&#123; type[`is$&#123;str&#125;`] = (obj) =&gt; Object.prototype.toString.call( obj ) === `[object $&#123;str&#125;]` &#125;(val)) &#125; console.log(type) return type&#125;())Type.isNumber(2) // true 实现AOP（面向切片编程） AOP 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。JAVA 语言中 AOP 将一些跟核心业务逻辑模块无关的功能抽离出来，通常包括日志统计、安全控制、异常处理灯。再通过“动态织入”的方式掺入业务逻辑中。好处： 可以保持业务逻辑模块的纯净和高内聚，方便复用日志统计等功能模块。 JavaScript中实现AOP是指把一个函数“动态织入”到另一个函数之中具体实现：123456789101112131415161718192021222324252627Function.prototype.before = function(beforeFn)&#123; let that = this; // 谁调用指向谁 下面是由 func 函数调用所以是指向 func return function( ...args)&#123; beforeFn.apply(this,args) // 执行回调函数 beforeFn return that.apply(this,args) // 执行原函数 &#125;&#125;Function.prototype.after = function(afterFn)&#123; let that = this; // 谁调用指向谁 下面是由befor函数调用所以是指向 befor return function( ...args)&#123; let ret = that.apply(this,args) // 执行并接收原对象 afterFn.apply(this,args) // 执行回调函数 beforeFn return ret &#125;&#125;var func = function ()&#123; console.log(2)&#125;func = func.before(function ()&#123; console.log(1)&#125;).after(function ()&#123; console.log(3)&#125;)func()// 1 2 3 函数柯里化 （function currying） 在数学和计算机科学中，柯里化是将多个参数的函数转换成一系列使用一个参数的函数，且返回接受余下的参数的新函数 curring 又称部分求值；一个 curring 函数首先会接收一些参数，该函数并不会立即求值，而是继续返回另外一个函数，而刚传入的参数会被保存在形成的闭包中，待函数真正需要求值的时候，之前的所以参数都会被一次性用于求值 简单示例：1234567function add(a,b) &#123; return a + b&#125;add(1,2) // 3// 如果柯里化add(1)(2) // 3 接下来使用 currying 实现一个几天之内消费总和的函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 普通方法var cost = (function() &#123; var args = []; return function()&#123; if(!arguments.length)&#123; let money = 0 for (let val of args )&#123; money += val; &#125; return money &#125;else&#123; [].push.apply(args,arguments) &#125; &#125;&#125;)()cost(100);cost(100);cost(100);cost(); // 300cost(100)(100)(100)// currying/** * 保存原函数参数返回到新函数中使用 */// func(100,100,100) //300function count (...args)&#123; let num = 0; if(args.length&gt;1)&#123; for (let v of args)&#123; num +=v &#125; return num &#125;else&#123; return args[0] &#125;&#125;var curry = function(func)&#123; let args = [] return function fn(...Args)&#123; if (Args.length)&#123; [].push.apply(args,Args) return fn &#125;else&#123; return func.apply(this,args) &#125; &#125;&#125;cost = curry(count);cost(100);cost(100);cost(100);cost(); // 300 函数节流JavaScript 中大多数情况都是用户主动出发函数，除非函数本身的实现不合理，否则一般不会遇到跟性能相关的问题，少数情况下，函数不是由用户直接触发控制，可能被频繁调用造成严重的性能问题。比如：12345678910111213141516window.addEventListener('resize', function(e) &#123; // do something...&#125;);window.addEventListener('scroll', function(e) &#123; // do something...&#125;);Dom.addEventListener('mousemove', function(e) &#123; // do something...&#125;);// progressxhr.upload.addEventListener("progress", function(result) &#123; // do something...&#125;, false);// ... 上述事件1秒种触发很多次，并且常常操作DOM节点，非常损耗性能，浏览器会因此吃不消而卡顿；实际我们不需要触发如此高的频率因此我们可以在一段时间内忽略掉一些执行次数 节流原理： 如果持续触发事件，可每隔一段时间只执行一次。 使用定时器实现节流 将即将被执行的函数用 setTimeout 函数延迟一段时间执行，如果该定时器未执行完成则忽略接下下来的需被执行的函数。1234567891011121314151617181920 function throttle(func,wait) &#123; let timer, firstFlag = true; //第一次立即执行 return function(...args) &#123; if(timer) return false; // 如果存在定时器这不执行 let that = this; if(firstFlag)&#123; firstFlag = false; return func.apply(that,args); &#125; timer = setTimeout(function()&#123; clearTimeout(timer); timer = null; func.apply(that,args); &#125;,wait) &#125; &#125; window.addEventListener('scroll', throttle(function(e) &#123; console.log(e)&#125;,1000)); 函数防抖 和节流一定时间段内只调用一次事件处理函数不同，防抖是一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。（用户不再触发对应事件才执行一次事件）12345678910111213function debounce(func,wait) &#123; let timer; return function(...args) &#123; let that = this; clearTimeout(timer); timer = setTimeout(function()&#123; func.apply(that,args) &#125;,wait) &#125;&#125; window.addEventListener('scroll', debounce(function(e) &#123; console.log(e)&#125;,1000)); 参考资料 《JavaScript设计模式与开发实践》 基维 AOP 基维 高阶函数 JavaScript专题之跟着 underscore 学节流]]></content>
      <categories>
        <category>design patterns</category>
      </categories>
      <tags>
        <tag>Heigher-order</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 设计模式基础（二）]]></title>
    <url>%2F2019%2F07%2F09%2FdesignPatterns2%2F</url>
    <content type="text"><![CDATA[原型模式在以类为中心的面向对象编程语言中，类和对象的关系就像铸模和铸件的关系，对象总是从类中创建。而原型编程中，类不是必须的，对象未必从类中创建而来，可以拷贝另一个对象而变成新对象 从设计模式角度讲，原型模式是用于创建对象的一种模式，找到一个对象，不需要关心对象的具体类型，通过克隆来创建一个一模一样的对象。 原型不单是一种设计模式，也被称为编程泛型 原型模式实现的关键是语言本身是否提供了 clone 方法， ECMAScript 5 提供了 Object.create 方法123456789101112function Plane (propertys)&#123; //工厂方法 this.blood = propertys.blood; this.attackLevel = propertys.attackLevel; this.defenseLevel = propertys.defenseLevel;&#125;var plane = new Plane(&#123; blood :100, attackLevel :10, defenseLevel :10&#125;);var clonePlane = Object.create(plane);console.log(clonePlane.__proto__) // Plane &#123;blood: 100, attackLevel: 10, defenseLevel: 10&#125; 通过克隆 plane 对象得到 clonePlane 对象,那么 plane 就被称为 clonePlane 的原型；而 plane 中所有的属性和方法都将挂载到__proto__ 原型属性上 每个 JS 对象都有 __proto__ 属性(隐式原型属性)，指向创建该对象的构造函数的原型,这个属性可以访问到原型（[[prototype]]） 内部属性。这个属性在现在来说已经不推荐直接去使用它了。 由于 JavaScript 作为一门基于原型的语言，没有类的概念，每一个对象都是基于另一个对象的克隆，因此语言最初只有一个根对象 Object.prototype,如果A对象是从B对象克隆而来，那么B就是A的原型，如果C又是B的原型。它们之间就形成了一条原型链 原型编程中有一个重要特性：访问对象中某个属性或方法，而对象本身没有对应属性和方法，那么它会从自己的原型链上查找，一直查到根对象为止一级级向上，对性能有影响，寻找的层级越多，性能影响越大123456console.log(clonePlane) // Plane &#123;&#125;console.log(clonePlane.blood) // 100console.log(clonePlane.color) // undefinedconsole.log(clonePlane.__proto__) //原型 Plane &#123;blood: 100, attackLevel: 10, defenseLevel: 10&#125;上述代码中的clonePlane 对象 本身是没有 blood 和 color 属性，却能访问到blood的值而访问不到color的值，是因为 clonePlane 对象 原型链中有 blood 属性而没有color属性。原型编程基本规则：1. 所有数据都是对象2. 对象会记住它的原型（类似于继承）3. 要得到一个对象，需要将另一个对象作为原型并克隆它4. 访问不到对象的某个属性或方法，那么它会从自己的原型链上查找，一直查到根对象为止## 原型继承在JavaScript中我们遇到的每一个对象都是从 Object.prototype克隆而来，通过Object.getPrototypeOf来判断对象的原型从属关系。12345let obj = new Object();let obj1 = &#123;&#125;;console.log(Object.getPrototypeOf(obj) === Object.prototype) // trueconsole.log(Object.getPrototypeOf(obj1) === Object.prototype) // true由于引擎内部会自动实现对 Object.prototype 的克隆，所有我们执行显示的使用let obj = new Object(); let obj1 = {}; prototype 有一个属性 constructor，默认指向原型所在的构造函数,constructor是一个公有且不可枚举的属性。一旦我们改变了函数的 prototype ，那么新对象就没有这个属性了,如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。下面我们来看new 运算符 JavaScript中没有类的概念，所以 Object 是一个构造函数，JavaScript 中的函数即可作为普通函数调用，又可作为构造器调用,当使用 new 运算调用函数时，函数就是构造器。 new命令的原理 创建一个空对象，作为返回的对象实例 将构造函数指向原型prototype属性（继承构造函数） 绑定作用域（ this 指向空对象 ） 执行构造函数,如果构造函数return 为对象则使用该对象，否则 return 创建的空对象 模拟 new 运算12345678910111213141516function __new (fun,args)&#123; // 获取构造函数 let arr =[...arguments] let Con = arr.shift() // 创建对象，将构造函数的原型指向它 let obj = Object.create(Con.prototype) // 绑定 this let ret = Con.apply(obj,arr) return (typeof ret === 'object' &amp;&amp; ret !== null )? ret : obj&#125;let person = __new(function Person(&#123; name,sex,age &#125;)&#123; this.name = name; this.sex = sex this.age = age&#125;,&#123;name:'owen',sex:'man',age:18&#125;)console.log(person) // Person &#123;name: "owen", sex: "man", age: 18&#125; new.target： 可利用 它来判断是否使用 new 命令 12345678function func() &#123; if (!new.target) &#123; throw new Error('请使用 new 命令调用！'); &#125; // ...&#125;func() // Uncaught Error: 请使用 new 命令调用！ call，apply and bindJavascript 编程中 call，apply 和 bind 方法被广泛运用，在学习设计模式前先理解这几个概念 三者都可改变函数内部this的指向（即函数执行时所在的作用域） call and apply 都是在改变this 指向后调用该函数。1234567function test() &#123;&#125;//test() == test.call()let obj =&#123;&#125;;Object.prototype.toString.call(obj) //"[object Object]"//因为call 和 apply 会将函数中的this指向第一个参数//相当于 obj.toString() call and apply 二者区别在于传参： call 第二个参数开始单个单个参数传 apply 第二个参数为数组或类数组 123456//返回数组中最大的数let arr = [1, 2, 4, 1, 15];Math.max.apply(null, arr) // 15//将数组的空元素变为undefinedArray.apply(null,[1,,3,,4])//[1,undefined,3,undefined,4]; 空元素与undefined的差别 forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 转换类似数组的对象 12let obj=&#123;0: 1, length: 2&#125;Array.protetype.slice.apply(obj);//[1,undefined] 被处理的对象必须有length属性，以及相对应的数字键。 参数为空、null和undefined，则默认传入全局对象。 bindbind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 1234567891011121314151617181920212223let counter = &#123; count: 0, func: function () &#123; this.count++; &#125;&#125;;let func = counter.func.bind(counter);func(); // 相当于 count++counter.count // 1let add = function (x, y) &#123; return x * this.m + y * this.n;&#125;let obj = &#123; m: 2, n: 2&#125;;let newAdd = add.bind(obj, 5); //将x 绑定为 5newAdd(5) // 20newAdd(1,6)//12 6为起作用 相当于 5*2+1*2 第一个参数是null或undefined，等于将this绑定到全局对象 bind方法使用注意点 bind方法每运行一次，就返回一个新函数 需要一个变量接收 模拟 bind1234567891011Function.prototype.bind = function (...Args) &#123; if (typeof this !== "function") &#123; throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); &#125; let that = this, //保存原函数 target = Args.shift(), //提取须绑定的对像 func = (...args) =&gt;that.apply(target ? this : target || window, aArgs.concat(args)); // aArgs.concat(args) 合并参数 func.prototype = Object.create(this.prototype); // 继承原函数的原型 return func;&#125;; 结合回调函数使用 1234567891011121314let counter = &#123; count: 0, inc: function () &#123; 'use strict'; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 结合call方法使用 1234567891011121314151617181920[1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1]//将Array.prototype.slice变成Function.prototype.call方法所在的对象//调用时就变成了Array.prototype.slice.call。let slice = Function.prototype.call.bind(Array.prototype.slice);Function.prototype.slice.call([1, 2, 3], 0, 1) // [1]//slice([1, 2, 3], 0, 1)let push = Function.prototype.call.bind(Array.prototype.push);let pop = Function.prototype.call.bind(Array.prototype.pop);let a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 将Function.prototype.bind方法变成Function.prototype.call的方法，就意味着bind的调用形式也可以被改写 1234567function f() &#123; console.log(this.v);&#125;let o = &#123; v: 123 &#125;;let bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123]]></content>
      <categories>
        <category>design patterns</category>
      </categories>
      <tags>
        <tag>Pattern intro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 设计模式基础（一）]]></title>
    <url>%2F2019%2F07%2F08%2FdesignPatterns1%2F</url>
    <content type="text"><![CDATA[什么是设计模式？ 模式 起源于建筑学。20世纪70年代，哈佛大学建筑学博士Christopher Alexander和他的团队花大约20年，来研究为解决同一个问题而设计出的不同建筑结构，从中发现那些高质量设计中的相似性，并且用模式来指代这种相似性； 受Christopher Alexander观点的启发，Erich Gamma, Richard Helm, Ralph Johnson和 John Vlissides(人称Gang Of Four, GoF),将这种 模式 观点应用于面向对象的软件设计中，并总结了23种常见的软件开发设计模式， 于 1995 年发布一本名叫《Design Patterns: Elements Of Reusable Object-Oriented Software》的书 设计模式的定义：在面向对象软件设计过程种针对特定的问题的简洁而优雅的解决方案。就是给面向对象软件开发中一些 好的设计取个名。 为什么要给好设计取名？在开发中，一些稍有经验的程序员也许在不知不觉中使用过设计模式，于是他向别人描述它时会遇到困难，沟通成本高、效率低。而 GoF 将这些好的设计从面向对象中挑选出来，这些都是久经考验的反应了开发者的经验和见解的使用模式来定义的技术，给它们一个好听又好记的名字，这样就方便我们更好的传播和学习，当遇到一个问题时，知道这是哪种设计模式，就能很快想出几种解决方案，提高工作效率。 好处： 提供固定的解决方法来解决在软件开发中出现的问题。 很容易地重用，防止在应用程序开发过程中出现的一些可能导致重大问题的小问题，提高工作效率。 避免重复代码来减小我们文件大小。 模式善于表达，交流更快速，降低沟通成本。 所有设计模式的实现都遵循一条原则：找出程序中变化的地方，将变化封装起来。一个程序的设计总是可以分为 可变部分和不变的部分；找出可变部分，将其封装，剩下的不变和稳定部分就非常容易复用。作用： 让人写出可复用和可维护的程序。JavaScript是一门面向对象语言[1][2][3]，设计模式通过对面向对象的特征封装、继承、组合、多态等技术的反复使用，提炼出可复用的面向对象设计技巧。 设计模式基础 JavaScript 在语言层面没有抽象类和接口的支持，没有类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。 编程语言类型编程语言按数据类型大体可分两大类：静态类型语言和动态类型语言 。静态类型语言在编译时就已经确定变量的类型，动态类型语言只有在程序运行的时候才能确定变量的类型。而JavaScript就是动态类型语言。 静态语言优点： 编译时就能发现类型不匹配的错误，可以避免程序运行时有可能发生的错误。 编译器可针对对应变量的类型进行优化，提高程序运行速度。 静态语言缺点： 迫使程序员按照对应的规则来写程序，为每个变量规定数据类型分散程序员注意力，增加代码量。 动态语言优点： 代码简洁，程序员可以把更多精力放在业务逻辑处理上，更加专注 无需类型检测，灵活性高，只关注须对象的行为，无需关注对象本身 不必借助超类型来实现”面向接口编程” 动态语言缺点： 无法保证变量的类型，程序可能发生意想不到的bug. 面向对象的特征(参考JAVA)多态、继承、封装 多态 定义：同一操作作用于不同对象，产生不同的解释和不同的执行结果 给不同对象发送同一个消息时，这些对象会根据这个消息分别给出不同的回应。 123456789101112var sendInfo = target =&gt; &#123; if ( target instanceof ObjOne) &#123; console.log(new ObjOne) &#125;else if (target instanceof ObjTwo) &#123; console.log(new ObjTwo) &#125;&#125; function ObjOne () &#123;&#125; function ObjTwo () &#123;&#125; sendInfo(new ObjOne()) sendInfo(new ObjTwo()) 上述代码段就体现了多态性,当发送 sendInfo 消息时每个对象做出不同的回应，但是这样的多态性很糟糕，如果再这个家一个对象 ObjThere 就得改动代码，对象越来越多时，修改的代码越多，出错的可能性越大。 多态背后的思想是将 做什么 和 谁去做以及怎样做分开，也就是将 不变的事物和可能变化的事 分开。上述代码段中，每个对象都会打印日志,这是不变的，而各个对象输出哪些信息是变化的，将不变的隔离出来，把变化的封装起来，这样程序就又了扩展能力，是可生长的，这样就符合 开发-封闭 原则。下面是修改后的代码： 1234567891011let sendInfo = target =&gt; &#123; target.log()&#125; function ObjOne () &#123;&#125;ObjOne.prototype.log = function()&#123;console.log(this)&#125;;function ObjTwo () &#123;&#125;ObjTwo.prototype.log = function()&#123;console.log(this)&#125;; sendInfo(new ObjOne()) sendInfo(new ObjTwo()) 现在我们增加一个对象就不需要修改 sendInfo里的代码了 123function ObjThere () &#123;&#125;ObjThere.prototype.log = function()&#123;console.log(this)&#125;;sendInfo(new ObjThere()) 类型检查和多态类型检查是再表现出对象多态性之前一个绕不开的话题，JavaScript 是一门不必进行类型检查的动态类型语言，为了真正了解多态的目的，须从静态语言说起。 以JAVA为例，由于在编译时会进行类型检查，所有不能给变量赋予不同类型的值。1234String str;str = 'ab'str =2 // error 将之前的例子换成 Java 123456789101112131415161718192021222324public class ObjOne &#123; public void log () &#123; System.out.println('a') &#125;&#125;public class ObjTwo &#123; public void log () &#123; System.out.println('b') &#125;&#125;public class SendInfo &#123; public void log (ObjOne objOne) &#123; objOne.log() &#125;&#125;public class Test &#123; public static void main (String args[] ) &#123; SendInfo sendInfo = new SnedInfo(); ObjOne objOne = new ObjOne() sendInfo(objOne) // 'a' ObjTwo objTwo = new objTwo() sendInfo(objTwo) // error &#125;&#125; 上述代码段中 sendInfo(objOne) 可以顺利输出，而sendInfo(objTwo)因为传入的类不同而报错，为了解决这一问题，静态类性的面向对象通常被设计为可向上转型：当给一个类变量赋值时，这个变量的类型既可以用这个类本身，也可以用这个类的超类 就像描述一只咖啡猫在跑、一只波斯猫在跑，如果忽略它们具体类型，可以说 一只猫在跑。 同理，当 ObjOne 和 ObjTwo 对象的类型都被隐藏在超类 Objects 身后时， ObjOne 和 ObjTwo就能被交换使用，这就让对象表现出多态性，这种表现正是实现众多设计模式的目标。要实现多态归根结底得先要消除类型之间的耦合关系。一个JavaScript对象即可表示ObjOne又可表示ObjThere,这意味着JavaScript对象的多态性是与生俱来的 多态在面向对象程序设计中的作用Martin Fowler 在重构一书中写到： 多态的最根本好处在于，你不必再向对象询问“你是什么类” 而后根据得到的答案调用对象的某个行为————你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。 多态最根本的作用就是把过程化的条件分支语句转化为对象的多态性，从而消除条件分支语句 就好比如在电影拍摄现场，导演喊出“action”时，每个人都做自己应该做的事，而不用导演走到每个人面前确认他们的职责，然后告诉他们该做什么。对象应该做什么并不是临时决定的，而是事先约定排练好的，每个对象该做什么，已经成为该对象的一个方法，被安装在对像内部，每个对像负责自己的行为，然后这些对象通过同一个消息，有条不紊的工作将行为分布在各个对象中，让他们各自负责自己的行为，这便是面向对象设计的优点。 继承使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”,被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。 使用继承来得到多态效果,是让对象表现出多态性最常用的手段。继承通常包括实现继承(使用基类的属性和方法而无需额外编码的能力)和接口继承( 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力)和可视继承(子窗体（类）使用基窗体（类）的外观和实现代码的能力) 注意： 使用继承时,两个类之间的关系应该是“属于”关系。 将上述JAVA例子进一步封装 1234567891011121314151617181920212223242526272829public abstract class Objects &#123; //抽象出一个超类 abstract void log();&#125;public class ObjOne extends Objects &#123; public void log () &#123; System.out.println('a') &#125;&#125;public class ObjTwo extends Objects &#123; public void log () &#123; System.out.println('b') &#125;&#125;public class SendInfo &#123; //让 log 方法接收 Objects 类 public void log (Objects objects) &#123; objects.log() &#125;&#125;public class Test &#123; public static void main (String args[] ) &#123; SendInfo sendInfo = new SnedInfo(); Objects objOne = new ObjOne(); Objects objTwo = new objTwo(); sendInfo(objOne) // 'a' sendInfo(objTwo) // 'b' &#125;&#125; 上述代码段中 ObjOne 和 ObjTwo 继承自 Objects 类即可通过这个桥梁来使用对应的方法。 封装封装是实现面向对象程序设计的第一步，将数据或函数等集合在一个个单元中（在java中称之为类，JavaScript中就是一个函数对象） 封装是隐藏数据、实现细节、设计细节以及对象的类型等，是代码模块化；是把过程和数据包围起来，只能通过已定义的方法访问数据。把客观事物封装成抽象的类，并且只对可信的类或对象来操作这个类的数据和方法，而对不可信的对象进行信息隐藏 封装的意义： 保护数据成员，不然其他对象或类直接访问或修改，只能通过提供的接口访问，防止用户无意破坏（数据封装） 方法的细节对外是隐藏的，只要接口不变，内容的修改不会影响到外部的调用这（封装实现） 封装数据在许多语言的对象系统中，封装数据是由语法解析来实现的比如 JAVA 提供了 public 、private、protected等关键字来设置不同的访问权限。 JavaScript 中并没有提供这些关键字，只能依赖作用域来实现封装特性，而且只能模拟出 public、和private1234567891011121314let myObject=(()=&gt;&#123; let __name = "owen"; // private return &#123; // publice 对象 getName()&#123; return __name &#125;, setName(value)&#123; return __name = value &#125; &#125;&#125;)()myObject.getName() // "owen"myObject.setName('gao')myObject.getName() // "gao" ES6 中除了 let 、const 外还可使用 Symbol 类型建立私有属性 封装实现封装使对象内部的变化对其他对象或类而言是透明不可见的，对象对他自己的行为负责，其他对象或类不用关心他内部的实现，对象之间只通过暴露 API接口来通信。 比如 Array中的forEach 方法遍历一个聚合对象，我们不用关心 forEach 内部是争议实现的，只要它提供的功能正确就行，即使修改它内部的代码，只要调用方式没有变化就不用关系它内部实现的改变 12let arr = [1,2,3]arr.forEach(val =&gt; console.log(val)) 封装在更重要的层面体现为封装变化《设计模式》一书曾提到： 考虑你的设计中哪些地方可能变法，这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变，而是考虑你怎么样才能够在不重新设计的情况下进行改变。这里的关键在于封装发送变化的概念，这是许多设计模式的主题 《设计模式》一书中归纳总结了23种设计模式，从意图上可将这些模式划分为 创建型模式、结构型模式和行为型模式。 通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统演变过程中，只需替换哪些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易；这样可以很大程度的保证程序的稳定性或可扩展性。 面向对象基本原则单一职责原则（Single Responsibility Prunciple） 一个类只允许有一个职责，即只有一个导致该类变更的原因。 简单来说一个类只专注做一件事。并不是说一个类只有一个函数，而是说这个类中的函数所做的工作必须高度相关（高内聚） 不过这个原则很容易违背，因为可能由于某种原因，原来功能单一的类需要被细化成颗粒更小的职责1跟职责2，不过这个拆的粒度可能因人而已，有时候并不需要拆的过细，不要成了为设计而设计。所以在每次迭代过程中可能需要重新梳理重构之前编写的代码，将不同的职责封装到不同的类或者模块中。 优点： 类的复杂性降低，实现什么职责都有清晰明确的定义,可读性提高，可维护性提高； 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。 开发关闭原则（Open Closed Principle） 一个软件实体应该是可以扩展的，但是不可修改。 在软件开发过程中，永远不变的就是变化。因此当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象。优点： 增加稳定性。 可扩展性高。 里氏替换原则 （Liskov Substitution Principle） 子类必须能够替换掉它们的基类，而程序执行效果不变。 所有使用基类代码的地方，如果换成子类对象的时候还能够正常运行，则满足这个原则，否则就是继承关系有问题，应该废除两者的继承关系，这个原则可以用来判断我们的对象继承关系是否合理。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法. 优点： 提高代码的重用性； 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性； 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，很多开源框架的扩展接口都是通过继承父类来完成的； 可以用来判断我们的对象继承关系是否合理,约束继承在使用上的泛滥。 缺点： 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束； 增强了耦合性。当父类的常量、变量和方法被修改时，必需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大片的代码需要重构。 依赖倒置原则 （Dependence Inversion Principle） 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 我们经常说“针对接口编程”，这里的接口就是抽象，我们应该依赖接口，而不是依赖具体的实现来编程。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖 高低应该是从开发者当前的角度来看的，不过DIP原则从不同角度来看它都适合且需要被遵守。假如我们高层模块直接依赖于底层模块，带来的后果是每次底层模块改动，高层模块就会受到影响，整个系统就变得不稳定，这也违反了开放关闭原则。 通常我们会通过引入中间层的方式来解决这个问题，这个中间层相当于一个抽象接口层，高层模块和底层模块都依赖于这个中间层来交互，这样只要中间抽象层保持不变，底层模块改变不会影响到高层模块，这就满足了开放关闭原则；而且假如高层模块跟底层模块同时处于开发阶段，这样有了中间抽象层之后，每个模块都可以针对这个抽象层的接口同时开发，高层模块就不需要等到底层模块开发完毕才能继续了。 优点： 通过抽象来搭建框架，建立类和类的关联，以减少类间的耦合性。而且以抽象搭建的系统要比以具体实现搭建的系统更加稳定，扩展性更高，同时也便于维护。 接口隔离原则 （Interface Segregation Principle） 多个特定的客户端接口要好于一个通用性的总接口。 应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。 需要注意的是：接口的粒度也不能太小。如果过小，则会造成接口数量过多，使设计复杂化。优点： 避免同一个接口里面包含不同类职责的方法，接口责任划分更加明确，符合高内聚低耦合的思想。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 迪米特法则 （Law Of Demeter） 或 最少知识原则（Least Knowledge Principle） 一个对象应该对其他对象有最少的了解;一个类应该对自己需要耦合或调用的类知道得最少。类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。优点： 降低复杂度；降低耦合度；增加稳定性。 减少类与类之间的关联程度，让类与类之间的协作更加直接。]]></content>
      <categories>
        <category>design patterns</category>
      </categories>
      <tags>
        <tag>Pattern intro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 学习]]></title>
    <url>%2F2019%2F07%2F05%2Fnginx%2F</url>
    <content type="text"><![CDATA[什么是 Nginx Nginx 是一款轻量级高性能的web 和 反向代理服务器，类似于Apache，也是一个 IMAP/POP3/SMTP （电子邮件）代理服务器。，由俄罗斯程序设计师 Igor Sysoev开发；在高连接并发的情况下，Nginx能够支持高达 50000 个并发连接数的响应，是 Apache 服务器不错的替代品。 nginx做为HTTP服务器，有以下几项基本特性： 1. 处理静态文件，索引文件以及自动索引；打开文件描述符缓冲． 2. FastCGI和反向代理加速(无缓存)，简单的负载均衡和容错． 3. 模块化的结构。包括gzipping, byte ranges, chunked responses,以及 SSI-filter等filter。如果由FastCGI或其它代理服务器处理单页中存在的多个SSI，则这项处理可以并行运行，而不需要相互等待。 4. 支持SSL 和 TLSSNI． Nginx支持热部署。它的启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。nginx是异步的，多个连接（万级别）可以对应一个进程。 apache是同步多进程模型，一个连接对应一个进程；nginx的优势是处理静态请求，cpu内存使用率低，apache适合处理动态请求，所以现在一般前端用nginx作为反向代理抗住压力，apache 作为后端处理动态请求。 正向代理： 服务器代理客户端向服务端发送请求，并将数据分发给客户端，服务端无法知道客户端的信息反向代理： 服务器代理服务端接收客户端的请求，并分发给服务器（分布式部署），反向代理隐藏了服务器的信息。负载均衡： 客户端发送的、Nginx反向代理服务器接收到的请求数量，就是负载量。请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则，即代理服务器将请求按一定的规则分发的过程就是负载均衡。 安装下载点击进入官网下载 Windows版本,解压至 C盘 启动双击 nginx.exe 或者 打开 CMD 进入 nginx 目录 输入 start nginx,如果启用防火墙，允许访问即可 常用命令须使用CMD 进入跟目录才能使用 nginx12345nginx -h //查看帮助nginx -v // 查看版本nginx -s stop //停用nginx -s reload //重载配置，重启进程nginx -s reopen //重启日志 代理配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#user nobody;#开启进程数 &lt;=CPU数 worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#进程号保存文件 #pid logs/nginx.pid;events &#123; #每个进程最大连接数（最大连接=连接数x进程数）每个worker允许同时产生多少个链接，默认1024 worker_connections 1024; &#125;http &#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #日志文件输出格式 这个位置相对于全局设置 #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #请求日志保存位置 #access_log logs/access.log main; #打开发送文件 sendfile on; #tcp_nopush on; #keepalive_timeout 0; #连接超时时间 keepalive_timeout 65; #打开gzip压缩 #gzip on; server &#123; #监听端口，默认是80端口 listen 80; #监听域名 server_name localhost; #charset koi8-r; #nginx访问日志放在logs/host.access.log下，并且使用main格式（可以自定义格式） #access_log logs/host.access.log main; #如果没有location更明确的匹配访问路径的话，访问请求都会被该location处理 location / &#123; #root指定nginx的根目录为/usr/local/nginx/html root html; #默认访问文件，欢迎页先去html目录下找index.html，如果找不到再去找index.htm index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # #错误页面及其返回地址，错误码为500、502、503、504都会返回50.html错误页面 error_page 500 502 503 504 /50x.html; #location后面是"="的话，说明是精确匹配 location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 要监听多个端口和域名 可配置多个 server。 参考文章:Nginx 中文文档Nginx 相关介绍深入浅出Nginx]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for,for...of, for...in, array iteration 运行速度测试]]></title>
    <url>%2F2019%2F07%2F03%2Fperformance%2F</url>
    <content type="text"><![CDATA[for,for…of, for…in, array iteration 运行速度测试 由于不同浏览器，不同版本性能不一，且控制台本质是是套用了一大堆eval，沙盒化程度高,所以需使用node环境测试来提高准确性12345678910111213141516171819// 准备待测数组const NUM = 1e7;let arr = new Array(NUM).fill(1);// for 测试let arr1 =[];console.time('for');for (let i = 0; i &lt; arr.length; i++) &#123; arr1.push(arr[i])&#125;console.timeEnd('for');// Chrome/75.0.3770.100 Safari/537.36 环境//VM1324:10 for: 576.733154296875ms// node v10.11.0 环境// for: 412.087ms for 几种写法 常规写法 123456let arr1 = []console.time('one')for (let i = 0; i &lt; arr.length; i++ )&#123; arr1.push(arr[i])&#125;console.timeEnd('one') 数组长度是会动态变化，每次循环会重新计算length长度，可能会出现死循环 cache arr.length 123for (let i = 0, len = arr.length; i &lt; len; i++ )&#123; arr1.push(arr[i])&#125; 缓存length 值，无需重新计算length 倒序 123for (let i = arr.length-1; i &gt;= 0; i--)&#123; arr1.push(arr[i])&#125; 比第二种方法更简洁 倒叙简洁版 123for (let i = arr.length-1; i--;)&#123; arr1.push(arr[i])&#125; 两个分号之间的表达式为 true 会一直执行直到 判断为 false (i = 0) 正序简洁版 123for (let i = 0, len;len = arr[i++]; )&#123; arr1.push(arr[i])&#125; 当 i 大于等于数组长度或arr[i++]值为false时 将停指循环，同时由于arr.length动态变化时可能会造成死循环 for…of123for (let value of arr)&#123; arr1.push(value)&#125; es6推出的迭代器，最简洁，可以是用 break，continue和return 终止循环 for…in123for (let key in arr)&#123; arr1.push(arr[key])&#125; for…in 一般用于遍历对象，他会将本身属性和原型链上的属性（除系统内置属性）全部遍历出来即便是不可枚举属性（enumerable:false), 可以通过 items.hasOwnProperty来遍历本身属性,由于查询到自己的原型链上，所以性能方面比较差 forEach123arr.forEach(function(value)&#123; arr1.push(value)&#125;) 数组的迭代方法，没有返回值 map123arr.map(function(value)&#123; return arr1.push(value)&#125;) 浅拷贝原数组，并且返回一个新数组 性能测试 测试次数 常规for cache for 倒序 for 倒叙简版 for 正序简版 for for..of for..in forEach map 1 542.121ms 573.618ms 764.181ms 755.961ms 571.464ms 945.199ms 4077.020ms 625.859ms 3573.946ms 2 430.008ms 541.933ms 524.474ms 668.276ms 553.475ms 897.442ms 4402.246ms 605.271ms 2732.859ms 3 409.531ms 661.765ms 534.167ms 655.481ms 600.939ms 1141.093ms 3806.704ms 584.712ms 2779.192ms 4 412.972ms 643.868ms 536.026ms 674.081ms 725.149ms 930.655ms 3201.387ms 599.780ms 3152.499ms 5 417.034ms 624.323ms 520.674ms 799.568ms 574.713ms 943.449ms 3261.512ms 587.182ms 2954.195ms 6 525.771ms 955.737ms 526.208ms 771.443ms 531.962ms 954.199ms 4351.009ms 608.264ms 2888.752ms 7 498.039ms 602.703ms 555.588ms 531.464ms 541.599ms 916.678ms 3264.334ms 596.168ms 2834.663ms 8 431.694ms 523.381ms 544.974ms 527.472ms 517.833ms 1049.283ms 3744.972ms 600.286ms 3467.499ms 9 417.521ms 518.093ms 547.404ms 611.024ms 594.503ms 767.059ms 4979.348ms 601.420ms 3638.023ms 10 424.806ms 557.961ms 535.541ms 837.561ms 541.882ms 772.686ms 3284.424ms 602.443ms 3599.642ms 11 409.402ms 521.131ms 534.265ms 517.709ms 551.397ms 752.101ms 3228.123ms 629.625ms 3535.545ms 12 425.362ms 532.882ms 406.637ms 522.287ms 570.259ms 914.135ms 3449.256ms 800.857ms 3429.123ms 平均值 439.2738ms 578.3565ms 553.1468ms 651.7057ms 507.8718ms 909.0785ms 3,686.96ms 605.6298ms 3,221.5056ms 堆值差 357245536 Byte 357245808 Byte 357245624 Byte 357245872 Byte 357246824 Byte 199268080 Byte 757187208 Byte 357244456 Byte 437247640 Byte 测试总结 运行效率: 常规for &gt; 正序简版 for&gt; 倒序 for &gt; cache for &gt; 倒叙简版 for&gt; forEach &gt; for..of &gt; map &gt; for..in 几种普通 for 循环占用内存相差不大, 而 for..of 占用运行内存最小 for..in 性能最差，内存占用高，速度很慢]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Iteration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript定时器]]></title>
    <url>%2F2019%2F06%2F28%2Ftimer%2F</url>
    <content type="text"><![CDATA[什么是定时器 在一段时间间隔后执行一个函数或执行一段代码的方法 JavaScript 原生提供几种定时器 setInterval、setTimeout 、requestAnimationFrame 执行函数中的作用域未全局作用域this指向全局，可通过 bind 方法给执行函数传递参数或指定作用域 (严格模式下，setTimeout( )的回调函数里面的this仍然默认指向window对象， 并不是undefined) setInterval 每相隔一段时间间隔执行一个函数或执行一段代码的方法 通过clearInterval方法来取消定时器12let timerInterID = window.setInterval(callback,delay[,param...]) setTimeout( clearInterval.bind(null,timerInterID),1000) 参数 callback 重复执行的函数或代码段（不推荐使用一段字符串构成的代码，应为这样做不安全，会被不法分子利用） delay 时间间隔，单位为毫秒（ms）实际间隔可能会稍长（最小间隔是4ms） timerInterID 每次调用setInterval方法返回的唯一 ID，可通过调用 clearInterval方法来清除setInterval方法 param1, …, paramN 传递给执行函数（callback）的参数 (IE9 及更早的 IE 浏览器不支持向回调函数传递额外参数。如果你想要在IE中达到同样的功能,你必须使用一种兼容代码 ) setTimeout 在一段时间间隔后执行一个函数或执行一段代码的方法 通过clearTimeout方法来清除定时器1let timerTimeID = setTimeout(callback,delay[,param1, ..., paramN ]) 参数 callback 重复执行的函数或代码段（不推荐使用一段字符串构成的代码，应为这样做不安全，会被不法分子利用） delay 时间间隔，单位为毫秒（ms），默认为0实际间隔可能会稍长（最小间隔为 4ms ） timerTimeID 每次调用setTimeout方法返回的唯一 ID，可通过调用 clearTimeout方法来清除setTimeout方法 param1, …, paramN 传递给执行函数（callback）的参数 (IE9 及更早的 IE 浏览器不支持向回调函数传递额外参数。如果你想要在IE中达到同样的功能,你必须使用一种兼容代码 ) requestAnimationFrame 类似于setInterval方法，执行动画时推荐使用 会在浏览器下次重绘前执行函数 执行间隔通常是每秒60次，当运行在后台标签页或隐藏在 iframe时，会暂停调用12let frameID = window.requestAnimationFrame(callback)setTimeout(cancelAnimationFrame.bind(null,FrameID),1000) 参数 callback 更新动画帧所调用的函数 一帧大约 16.7ms 兼容性]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包（closure）]]></title>
    <url>%2F2019%2F06%2F27%2Fclosure%2F</url>
    <content type="text"><![CDATA[什么是闭包（closure）？在理解闭包前，须理解变量作用域。作用域分全局和局部作用域，是指代码中定义变量的区域。(变量有效访问的范围。) 静态作用域 静态作用域又叫做词法作用域，采用词法作用域的变量叫词法变量。词法变量有一个在编译时静态确定的作用域。(JavaScript 采用的是词法作用域) 词法变量的作用域可以是一个函数或一段代码，该变量在这段代码区域内可见（visibility）；在这段区域以外该变量不可见（或无法访问）。词法作用域里，取变量的值时，会检查函数定义时的文本环境，捕捉函数定义时对该变量的绑定。 动态作用域 动态作用域的变量叫做动态变量。程序正在执行定义了动态变量的代码段，那么在这段时间内，该变量一直存在；代码段执行结束，该变量便消失。(函数的作用域在函数调用时才决定。)动态作用域里，取变量的值时，会由内向外逐层检查函数的调用链，并打印第一次遇到的那个绑定的值。显然，最外层的绑定即是全局状态下的那个值。 变量无权访问子作用域，只能访问自己和父级以上的作用域 12345678910var name = "Owen"; // 全局变量var sex = "Man";function person()&#123; console.log(name) // "Owen" var age = "18" var sex = "man"; console.log(sex) // "man" 优先访问 局部变量 sex&#125;person()console.log(age) // age is not defined 无法访问 person 中的 age 局部变量 预编译当函数执行时，会创建一个执行期上下文(即作用域)的对象AO(存储在[[scope]]中), 一个新的AO指向 定义了一个函数执行时的环境。函数执行时对应的AO, 是独一无二的，每次调用函数就创建一个OA， 函数执行完毕 AO的指向就会销毁 [[scope]]: 每个函数都是对象，对象中有些属性可访问，有些不可以，[[scope]]就不可访问，它存储了运行期上下文的集合([GO,AO])。作用域链：就是[[scope]]中所存储的AO对象集合，呈链式链接 查找变量：函数刚定义就存储了 所在环境的执行期上下文,执行时 创建自己的AO 123456789101112131415161718192021222324252627function fun (a)&#123; console.log(a);// function var a=123; function a ()&#123;&#125;; console.log(a)// 123 函数声明已提升所以不用管 var b =function()&#123;&#125;; console.log(b);//function 因为是函数表达式，只提升了 变量b， 这样的函数体不会提升&#125;fun(1); //函数 123 123 函数/*代码执行1. 会创建 一个（全局为GO）AO(Activation Object)对象（执行期上下文/作用域）一个存储空间库2. 找形参和变量声明，将形参和变量名作为AO的属性名，值为undefined,重复的只用写一个3. 将实参值和形参统一4. 在函数体里找函数声明，值为函数体5. if/return 不用管 声明还是会提升AO&#123; a:function a ()&#123;&#125;; b:undefined&#125;记住函数是一等公民权限最高*/ 函数内部声明变量的时候，一定要使用var，let or const命令。如果不用的话，你实际上声明了一个全局变量！ 变量的生命周期内存生命周期： 分配你所需要的内存 使用分配到的内存（读, 写） 不需要时将其释放/归还 全局变量可永久访问，除非主动销毁，而局部变量在函数运行结束时就会随之销毁，当局部变量还能被外界访问时，将会保留，不被销毁 闭包简单理解：在Javascript语言中，只有函数内部的子函数才能访问该函数的变量，而定义在一个函数内部的函数并且外部能接收到这个函数，那么这个函数就是闭包。(能够读取其他函数内部变量的函数。) 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。 特点： 函数套函数，并且外部能访问嵌套函数。 父函数被销毁 的情况下，子函数的[[scope]]中仍然保留着父级的变量对象和作用域链，因此可以继续访问父级的变量对象,进而改变父作用域内部的变量值 占用内存，过多使用会产生性能问题，在IE中可能会导致内存泄漏。（可在销毁函数前，将无用的变量删除） 1234567891011121314151617// 例一function A() &#123; let a = 1 B = function () &#125;&#125;A()B() // 1//例二function A() &#123; let a = 1 return function () &#123; console.log(a) &#125;&#125;A()()//1 闭包与内存泄漏 内存泄漏是指，页面随着时间的延长使用的内存越来越多而没有及时释放。 javascript中 不需要开发人员像C语言一样手动使用 malloc()分配内存，也不需要用完后使用free()回收；而是使用垃圾回收策略来自动管理内存，即找出那些不再使用的值，然后释放所占用的内存。 垃圾回收只针对局部变量进行回收销毁，全局变量只有网页关闭才会消除。垃圾回收有两种方法引用计数和标记清除垃圾回收算法主要依赖于引用的概念 什么是引用：在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。 引用计数 引用计数是跟踪记录每个值被引用的次数。即看一个对象是否有指向它的引用。如果没有其他对象指向它（零引用），说明该对象已经不再需要了。123456let obj = &#123; name:'owen'&#125;// 此时 对象 &#123; name:'owen' &#125; 被创建并引用一次obj = null// 此时 对象引用次数为零，将被回收机制销毁 引用计数有一个循环引用的问题：如果两个对象互相引用，它们的引用次数永远不会为零，将永远不会被回收，从而占据内存12345678910111213function obj()&#123; let obj1 = &#123; name:'owen'&#125;// 此时 对象 &#123; name:'owen' &#125; 被创建并引用一次let obj2 = &#123;&#125;obj2.name = obj1obj1.name = obj2// 此时 两个对象相互引用 ，俩个对象引用次数为二，永远也不会被收回&#125;obj() 标记清除 现代浏览器常用的方法，当变量进入环境时（例如，在函数中声明一个变量），这个变量标记为“进入环境”；而当变量离开环境时，则将其标记为“离开环境”。 把”对象是否不再需要”简化定义为”对象是否可以获得”。如把JavaScript想象一个树，每个JS都存在一个根(浏览器中为window对象,Node中为global对象 )，每当一个函数执行，就会生成一个节点。嵌套的函数调用就会有子节点。当函数执行完时，内部的变量都是无法被其他代码访问的，所以它就被标记为“无法被访问”。GC 时，JS 引擎统一对所有这些状态的对象进行回收。当进行一轮垃圾回收时，主线程会被阻塞，各个浏览器的时间不同可能是10ms、50ms、1s 应用封装变量将不需要暴露在全局的变量封装成”私有变量”。 1234567891011121314151617181920212223// 乘积let mult = (...args) =&gt;&#123; let num = 1; for (let val of args )&#123; num *= val; &#125; return num;&#125;// 由于每次运行函数都会完全遍历所以形参，效率较低下，我们可以加入缓存机制提供函数性能let mult1 = (()=&gt;&#123; let cache = &#123;&#125;; return (...args) =&gt; &#123; if(cache[args.join(',')]) return cache[args.join (',')]; let num = 1; for (let val of args )&#123; num *= val; &#125; return cache[args.join(',')]= num; // 缓存数值 &#125;&#125;)()// 我们看到 cache 变量仅仅在 mult 函数中使用，我们可以将它封装在函数内部，减少全局变量，变量发生不必要的错误 如果一个大函数中有些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里并有个良好的命名，将有助于复用，和注释作用；如果小函数不需要在其他程序中使用，最好使用闭包封装起来123456789101112131415let mult1 = (()=&gt;&#123; let cache = &#123;&#125;; let calculate = (...args)=&gt; &#123; let num = 1; for (let val of args )&#123; num *= val; &#125; return num &#125; return (...args) =&gt; &#123; let property = args.join(',') if(cache[property]) return cache[property]; return cache[property]= calculate.apply(null,args); // 缓存数值 &#125;&#125;)() 延续变量12345678910111213141516171819// img案例let imgSrc = (src) =&gt; &#123; let img = new Image(); img.src = src;&#125;imgSrc('http://xxxx.com/img')// 在一些低版本浏览器中使用 imgSrc 函数，会丢失一些数据，因为当函数调用结束后 img变量会随之销毁，此时可能未及时发出HTTP请求// 使用闭包解决数据丢失问题let imgSrc = (function ()&#123; let imgs = []; return function (src)&#123; let img = new Image(); imgs.push(img) img.src = src;&#125;&#125;)()imgSrc('http://xxxx.com/img') 三种方法解决循环中 var 定义函数的问题123456789101112131415161718192021//one 利用闭包for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)(i);&#125;//two 设置第三个参数for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer(j) &#123; console.log(j) &#125;, i * 1000,i)&#125;//three 利用 letfor (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer(i) &#123; console.log(i) &#125;, i * 1000)&#125; 因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候i 就是 固定了，所以会输出一堆 固定值。 函数中的this对象普通函数this 指向取决于 调用它时处在的执行上下文 对于new 的方式来说，this 被永远绑定在了赋值变量上面，不会被任何方式改变 this箭头函数箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this 否则指向全局。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fetch]]></title>
    <url>%2F2019%2F06%2F24%2Ffetch%2F</url>
    <content type="text"><![CDATA[fetch 一个获取资源的接口，类似于ajax 是基于 Promise之上设计，旧版本IE 完全不支持，须借助 polyfill来兼容 提供了对 Request 和 Response （以及其他与网络请求有关的）对象的通用定义 发送请求或者获取资源，需要使用 window.fetch or WindowOrWorkerGlobalScope.fetch 方法。 参数资源路径（url string） 他必须接收一个需要请求的资源路径，返回一个promise对象，请求成功的数据返回到Responese回调中，请求失败的信息返回到 Request中。 当接收到一个代表错误的 HTTP状态码时，fetch返回的promise不会被标记为 reject而会被标记为resolve，比如状态码为 404，500.只有网络故障或请求被阻止时才被标记为reject 1234567fetch('https://api.apiopen.top/musicDetails1') .then(function(response) &#123; return response.json(); &#125;) .then(function(myJson) &#123; console.log(myJson); //&#123;code: 400, message: "404 Not Found", result: "https://api.apiopen.top/musicDetails1"&#125; &#125;) fetch 默认是不会从服务端发送接收或发送任何 cookie,如果需要则必须设置 credentials,自 2017/8 起默认的credentials政策变更为same-originFirefox也在61.0b13中改变默认值 [, config] 配置项对象，包括所有对请求的设置 method: 请求使用的方法，如 GET、POST。 headers: 请求的头信息，形式为 Headers 的对象或包含 ByteString值的对象字面量。 body: 请求的 body信息： 可能是: Blob（ 表示一个不可变、原始数据的类文件对象）、BufferSource （ 用于表示自身为ArrayBuffer或者TypedArray提供对象的对象ArrayBufferView。）、 FormData（表示表单数据的键值对的构造方式，经过它的数据可以使用XMLHttpRequest.send() 方法送出，本接口和此方法都相当简单直接。如果送出时的编码类型被设为 “multipart/form-data”，它会使用和表单一样的格式。）、 URLSearchParams （接口定义了一些实用的方法来处理 URL 的查询字符串） 或者 USVString 对象。 注意GET 或HEAD方法的请求不能包含 body 信息。 mode: 请求的模式，如 cors、 no-cors 或者 same-origin。 credentials: 请求的 credentials，如 omit、same-origin 或者 include。为了在当前域名内自动发送 cookie ， 必须提供这个选项， 从 Chrome 50 开始， 这个属性也可以接受 FederatedCredential 实例或是一个 PasswordCredential 实例。 如果需要跨域请求需设置为 “include” 如果只在同域内发送cookie 则设置为 “same-origin” 如果任何情况都不发送cookie 则设置为 “omit” cache: 请求的 cache 模式: default 、 no-store 、 reload 、 no-cache 、 force-cache 或者 only-if-cached 。 redirect: 可用的redirect 模式:follow(自动重定向), error (如果产生重定向将自动终止并且抛出一个错误), 或者manual (手动处理重定向). 在Chrome中，Chrome 47之前的默认值是 follow，从 Chrome 47开始是manual。 referrer: 一个USVString 可以是 no-referrer、client或一个URL。默认是client。 referrerPolicy:指定引用HTTP头的值。可能是一个 no-referrer、 no-referrer-when-downgrade、 origin、 origin-when-cross-origin、 unsafe-url 。 integrity: 包括请求的subresource integrity值（例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=）。 12345678910111213141516171819202122232425262728293031const Fetch = function (url,config)&#123; if(typeof(config) !== 'object' || config === null) return throw `Config needs to pass an object type` let data = config || &#123;&#125; ; let &#123;method = 'GET', param = null, mode = "cors", cache = "no-cache",headers = &#123;'Access-Control-Allow-Origin': '*', 'content-type': 'application/json'&#125;, redirect = "follow", credentials = "include", referrer = "no-referrer"&#125; = data; /* // 传输 JSON 数据 需将 param 转换 JSON.stringify(param) //上传文件 需传输 formData 格式 let formData = new FormData() let fileField = document.querySelector("#myFile") formData.append('title',"My File") formData.append('fileField ',fileField .files[0]) */ return fetch(url,&#123; method:method.toUpperCase(), body:param, mode, cache, headers, redirect, credentials,&#125;).then(res =&gt;&#123; if(res.ok) return res.json() throw new Error("Network response fail："+res.status)&#125;).catch(err=&gt;console.error(err))&#125;Fetch('https://api.apiopen.top/musicDetails1',&#123;credentials:'omit'&#125;).then(res =&gt;console.log(res)).catch(err=&gt;console.error(err)) Headers constructor 创建一个 headers 对象 一个 headers 对象是一个简单的多名值对：12345let content = "Hello World";let myHeaders = new Headers();myHeaders.append("Content-Type", "text/plain");myHeaders.append("Content-Length", content.length.toString());myHeaders.append("X-Custom-Header", "ProcessThisImmediately"); 可以传一个多维数组或者对象字面量：123456789101112131415161718let content = "Hello World";let myHeaders = new Headers(&#123; "Content-Type": "text/plain", "Content-Length": content.length.toString(), "X-Custom-Header": "ProcessThisImmediately",&#125;);//获取和设置console.log(myHeaders.has("Content-Type")); // trueconsole.log(myHeaders.has("Set-Cookie")); // falsemyHeaders.set("Content-Type", "text/html");myHeaders.append("X-Custom-Header", "AnotherValue"); console.log(myHeaders.get("Content-Length")); // 11console.log(myHeaders.getAll("X-Custom-Header")); // ["ProcessThisImmediately", "AnotherValue"] myHeaders.delete("X-Custom-Header");console.log(myHeaders.getAll("X-Custom-Header")); // [ ] 如果使用了一个不合法的HTTP Header属性名，那么Headers的方法通常都抛出 TypeError 异常。如果不小心写入了一个不可写的属性，也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。 检查 content type 是否正确123456789fetch(myRequest).then(function(response) &#123; if(response.headers.get("content-type") === "application/json") &#123; return response.json().then(function(json) &#123; // process your JSON further &#125;); &#125; else &#123; console.log("Oops, we haven't got JSON!"); &#125;&#125;); Response 对象 fetch 返回的对象 对象中常用的属性 status： 响应状态码 如 200 404 等 statusText：返回和状态码对应信息 ok 检查状态码是否 在 200-299之间，返回true or false 检查环境支持度12345if(this.fetch) &#123; // run my fetch request here&#125; else &#123; // do something with XMLHttpRequest?&#125; 兼容性 Fetch规范]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[filter]]></title>
    <url>%2F2019%2F06%2F21%2Ffilter%2F</url>
    <content type="text"><![CDATA[filter 将模糊或者颜色偏移等图像效果用于元素，通常用于调整图像，背景和边框的渲染 css 标准中已内置一些预定义效果的函数，也可通过url使用SVG滤镜 语法12345678910111213141516171819202122/* URL to SVG filter */filter: url(filter.svg#id);/* &lt;filter-function&gt; values */filter: blur(5px);filter: brightness(0.4);filter: contrast(200%);filter: drop-shadow(16px 16px 20px blue);filter: grayscale(50%);filter: hue-rotate(90deg);filter: invert(75%);filter: opacity(25%);filter: saturate(30%);filter: sepia(60%);/* Multiple filters */filter: contrast(175%) brightness(3%);/* Global values */filter: inherit;filter: initial;filter: unset; 滤镜属性 需要设定某一函数的值。如果该值无效，函数返回“none“。 url() url 函数接收一个XML文件，该文件是一个SVG filter，并且包含一个ID值 来指定哪一个滤镜1filter:url(resources.svg#c1) blur() 定义模糊度 可以接受css长度单位，不接受百分比1filter:blur(5px) brightness() 定义亮度 默认为1， 1-0 逐渐变暗，1以上逐渐变亮 可以是百分比， 不能为负数 contrast() 定义对比度 1-0 逐渐变成灰黑 1以上颜色逐渐变艳丽 可以是百分比， 不能为负数 drop-shadow() 定义阴影效果，合成在图像下面， 参数 和 shadow, box-shadow 相似 和shadow, box-shadow属性不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。 传参顺序从左至右： 水平偏移距离正值右偏，负值左偏（offset-x）。必传 垂直偏移距离正值向下偏，负值上偏（offset-y）。必传 一个length值(表示距离尺寸的一种css数据格式) 值越大，越模糊阴影会变得更大更淡.）不允许负值 默认为0 （blur-radius）可选 一个length值，正值会使阴影扩张和变大，负值会是阴影缩小，默认 0 color 色值，在Gecko (Firefox), Presto (Opera)和Trident (Internet Explorer)中， 会应用color 属性的值,颜色值省略，WebKit中阴影是透明的。 1filter:drop-shadow(16px 16px 10px black) grayscale() 定义灰度 取值0 - 1的数值之间，可设置百分比，不可为负数1filter:grayscale(50%); hue-rotate() 定义颜色，色相旋转调整 单位 deg 可为负值 1filter: hue-rotate(90deg) invert() 反向输入图，定义转换比例 默认0 0%和100%之间，则是效果的线性乘子。1filter: invert(100%) opacity() 转化图像的透明程度 类似于css的opacity属性 1-0 逐渐变透明，支持百分比 ，不能为负数 和opacity属性不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。1filter: opacity(50%) saturate() 定义图像饱和度 1-0 至完全不包和，1为正常， 1以上饱和度更高，更艳丽，支持百分比 1filter:saturate(369%) sepia() 定义深褐色的色度 0 - 1 逐渐变为深褐色 支持百分比，不支持负数 1filter: sepia(100%) 组合函数 可以将任意数量的函数一起控制渲染，其中有一个不符合规范将全部失效1filter:sepia(100%) saturate(369%) opacity(50%) 兼容性]]></content>
      <tags>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setProperty]]></title>
    <url>%2F2019%2F06%2F18%2FsetProperty%2F</url>
    <content type="text"><![CDATA[css3 原生 var 变量 可以降低维护成本，有更高性能，文件更高压缩率。 语法 声明 --* * 表示变量名称，对于命名不能包含特殊字符（ $，[，^，(，% ）等等 必须在块级（{}）区域内声明,且只能给属性名的值，设值，不能给属性设置123:root &#123; --color: purple; &#125; 使用 通过var(x,y)函数调用 函数的可选第二个参数用作回退值。如果第一个参数引用的自定义属性无效，则该函数将使用第二个值。123div &#123; color: var(--color);&#125; CSS变量不合法的缺省特性 CSS变量，只要语法是正确的，就会作为正常的声明解析 如果发现变量值是不合法的，就让默认值代替123456789body &#123; --color: 20px; background-color: #fff; background-color: var(--color, #000);&#125;/* 等同于 */body &#123; background-color: transparen;&#125; CSS变量不合法的空格尾随特性 变量值后面会尾随空格,所以变量值最好加单位123456789body &#123; --width: 20; width: var(--width)px;&#125;/* 等同于 */body &#123; /* 宽度失效 */ width: 20 px; &#125; CSS变量的相互传递特性 声明CSS变量时候可以引入其他变量12345body &#123; --width: 20px; --width: var(--width); --height: calc( var(--width) / 10);&#125; 兼容性 setProperty 给一个样式设置新值 dom.style.setProperty(propertyName, value, priority); 参数 propertyName 必须是一个字符串，代表被更改的CSS属性。 value 对应 propertyName css 属性值。如果未传，则为空字符串 priority 设置css 的权重 “important” ,”undefined”, “” 如果不设置权重 则可简写为 dom.style.propertyName = &quot;value&quot; getPropertyPriority 获取一个样式属性的权重 dom.getPropertyPriority(&#39;property&#39;) 返回值 ‘important’ 或 ‘’ removeProperty 删除属性 dom.getPropertyPriority(&#39;property&#39;) 返回被删除的属性值 多个单词组成的属性要用连字符连接各个单词，不接收驼峰命名法的形式。 getComputedStyle 兼容 IE9及以上 获取当前元素所以最终使用的 CSS属性值 返回一个实时的 CSSStyleDeclaration 对象，当元素的样式更改时，它会自动更新本身。 语法 let styles = window.getComputedStyle(element, [pseudoElt]); element: Dom 元素 [pseudoElt]: 可选指定一个伪元素 （在Gecko2.0 (Firefox 4 / Thunderbird 3.3 / SeaMonkey 2.1)之前版本，参数pseudoElt是必要的。如果为null，则不指定其他主要浏览器必须指定此参数。Gecko已经更改为匹配其他浏览器的行为。） getComputedStyle 和 style 区别 element.style 同样可以获取 css 对象，可读写，而getComputedStyle(el) 只能读 element.style返回已设置的样式属性,而 getComputedStyle(el) 会将所有属性给返回getComputedStyle(el)element.style defaultView 此属性只读。 在浏览器中，document.defaultView 返回window与文档关联的对象，或者null如果没有可用的对象。 getComputedStyle 不仅挂载在 window对象上，而且还挂载在 defaultView对象上 因为在firefox3.6上访问（iframe)必须 defaultView对象上访问 css属性解析值（resolved value），计算值（computed value） 和 应用值（used value） 属于 getComputedStyle方法返回的值，大多数属性是一个计算值，有些是应用值 计算值（computed value） 子元素继承父元素的值，通过指定值计算出来 处理特殊的值 inherit(元素获取其父元素的计算值),initial(属性的初始默认值),unset(优先用 inherit 的样式，其次会应该用initial的样式) 进行计算，达到对应属性值的要求 计算值所需要的计算通常包括将相对值（em,rem %,)转换成绝对值（px） 应用值（used value） 完成所有计算后最终使用的值 计算出CSS属性的最终值有三个步骤 指定值（Specified value） 从样式表中接收（按权重规则来接收）未设置将使用继承值或者默认值 按规范算出计算值（span 指定 position: absolute 后display 变为 block） 计算布局（尺寸比如 auto 或 百分数 换算为像素值） 最后就是应用值， 只能使用 getComputedStyle来获取最终的应用值]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>setProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中的 zoom 和 scale 区别]]></title>
    <url>%2F2019%2F06%2F17%2FzoomAndScale%2F</url>
    <content type="text"><![CDATA[zoom 不是标准属性 对文字最小缩到 12pX 缩放位置相对于左上角缩放 调整时改变了元素占据的空间大小、尺寸，等比例缩放元素 *zoom:1 用来给老版本IE浏览器（IE6/7）清除浮动 由于缩小改变原来的空间尺寸，所以整个页面会重新渲染单位 百分比 zoom:50% 缩小到原来的一半 数值 zoom:0.5 等同 zoom:50%，不能为负数 zoom:normal 等同于 zoom:1 scale 等比例缩放元素 transform: scale(1) 对文字等比缩放 改变时不会从新渲染页面 默认居中缩放,原始尺寸不变 属于 w3c 规范 IE9以上都支持此属性 使用 transform 会覆盖以前的 transform 属性，即 以前 transform 对应的属性将被全部替换 可控制方向 transform:scale(x,y), transform:scaleX(x) or transform:scaleY(y)单位 只能是数值 可以为负数 chrome 中 同时使用两者效果会叠加transform 变换 支持 3D 变换 可以 拉伸，压缩，旋转，偏移目标元素 只能转换由盒子模型定位的元素。根据经验，如果元素具有display: block，则由盒模型定位元素。（转换行内元素，须设置display样式属性） 支持 IE10以上 IE9 需加私有前缀 -ms-（IE） -webkit-(chrome，safari) -o-（opera）-moz- （Firefox)类型skew 对目标对象进行歪斜变换 transform: skew() 参数 X,Y transform: skew(X,Y) 表示沿着 X轴和 Y轴 扭曲角度 默认为0 单位 degress (度) transform: skew(100deg,100deg) grad (百分度) transform: skew(10grad,10grad) rad（弧度） 一个完整的圆 为2π transform: skew(10rad,10rad) turn (圈数) 一个完整的圆 为1turn transform: skew(0.25turn，1.2turn) 可以为负数 scale 等比例缩放元素 transform: scale(1)单位 只能是数值 可以为负数 rotate 旋转元素 transform: rotate(x,y) 默认以目标对象中心为圆点转动单位同 skew translate 平移目标元素 transform: translate(x,y) 单位同 skew transition 平滑的改变CSS的值 只要CSS 属性值发生改变都会实现过渡效果 支持IE10 以上类型 transition-property 指定过度属性 transition-property:height height 就会参与过渡 transition-duration 指定持续时间 transition-duration:2s 指过渡持续 2S 单位 s (秒) ms(毫秒)transition-delay 过渡开始作用之前需要等待的时间。 transition-delay:0.2s 等待0.2S 后执行过渡单位 s (秒) ms(毫秒)transition-timing-function 指定动画运动时的节奏 transition-timing-function:ease 匀速运行 参数 ease ease-in 由慢到快 ease-out 由快到慢 ease-in-out 由慢到快在到慢 linear 线性过度 step-start step-end steps(5,end) 其它参数设置 transition 简写 transition: property-color duration timing-function; transition: height 0.3s ease; animations 用来指定一组或多组动画，每组之间用逗号相隔 支持IE10以上类型 -webkit-animation-name; 指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列 值 none 默认静止 定义 @keyframes 后的 名字 由大小写不敏感的字母a-z、数字0-9、下划线(_)和/或横线(-)组成。第一个非横线字符必须是字母，数字不能在字母前面，不允许两个横线出现在开始位置。举个栗子12345.cylon_eye &#123; -webkit-animation-name: resize;&#125;@-webkit-keyframes resize &#123; from &#123; margin-left: -20%; &#125; to &#123; margin-left: 100%; &#125; &#125; @keyframes resize &#123; from &#123; margin-left: -20%; &#125; to &#123; margin-left: 100%; &#125; &#125; -webkit-animation-duration 指定一个动画周期的时长 默认为 0 无动画 单位 s , ms -webkit-animation-duration: 1.5s; -webkit-animation-iteration-count 定义动画运行的次数 -webkit-animation-iteration-count:4 属性 默认运行一次 infinite 无限循环 播放的次数 不可为负值. 可以用小数定义循环(0.5 将播放动画到关键帧的一半 -webkit-animation-direction 指示动画是否反向播放 -webkit-animation-direction: alternate; 属性 normal 默认 每个动画循环结束，动画重置到起点重新开始 alternate 动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向 计数取决于开始时是奇数迭代还是偶数迭代 reverse 反向运行动画，每周期结束动画由尾到头运行。 alternate-reverse 动画第一次运行时是反向的，然后下一次是正向，后面依次循环。决定奇数次或偶数次的计数从1开始。 -webkit-animation-timing-function: ease-in-out;animation-timing-function 每一个动画周期中执行的节奏，作用于一个关键帧周期而非整个动画周期值同 transition-timing-function 简写语法 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写属性形式12345678910111213141516.cylon_eye &#123; background-color: red; background-image: linear-gradient(to right, rgba(0, 0, 0, .9) 25%, rgba(0, 0, 0, .1) 50%, rgba(0, 0, 0, .9) 75%); color: white; height: 100%; width: 20%;/* 调用动画 指定对应 持续时间 运动时的节奏 延迟时间 循环次数 对应动画 */ -webkit-animation: 4s linear 0s infinite alternate move_eye; animation: 4s linear 0s infinite alternate move_eye;&#125;/* 定义动画 */@-webkit-keyframes move_eye &#123; from &#123; margin-left: -20%; &#125; to &#123; margin-left: 100%; &#125; &#125; @keyframes move_eye &#123; from &#123; margin-left: -20%; &#125; to &#123; margin-left: 100%; &#125; &#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>zoom and transform:scale</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记]]></title>
    <url>%2F2019%2F06%2F13%2FvueNotes%2F</url>
    <content type="text"><![CDATA[vue 框架中遇到的问题props如果 data中的属性取不到 props 中的数据，可以通过 computed 或者 watch 属性监听变化 如果想要组件或者原生HTML节点重新渲染可以使用 v-if使用 prototype 挂载自定义方法或插件123Vue.prototype.$bus = Bus;// orVue.use(bus); template 中的 全局变量白名单123456789101112131415161718192021222324Infinity,undefined,NaN,isNaN,isFinite,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,require $slots只读属性，可访问插槽分发的内容，每个具名插槽都挂载到 $slots 中,默认插槽则为 default 使用渲染函数JSX时非常有用1234567891011121314Vue.component('anchored-heading', &#123; render: function (createElement) &#123; return createElement( 'h' + this.level, // 标签名称 this.$slots.default // 子节点数组 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) axios 问题接收二进制流文件乱码问题。1. 须将axios 配置中的responseType设置为’arraybuffer’，这样就不会让表格出现乱码现象；2. 如果要动态设置文件名则需要让后台将名字设置到响应头中，否则将是一个乱码的文件名；3. 然后通过&lt;a&gt;&lt;/a&gt; 标签的特性来，自动点击下载文件；4. 如果要兼容IE则需要利用navigator.msSaveOrOpenBlob方法；5. 兼容Firefox 须将&lt;a&gt;&lt;/a&gt; 标签添加到body中，最后再移除&lt;a&gt;&lt;/a&gt; 标签 12345678910111213141516171819202122232425// axios config config = &#123; responseType: 'arraybuffer' &#125;// 返回数据处理getUserInfoExport(data).then((&#123;data,headers&#125;) =&gt; &#123; let blob = new Blob([data], &#123; type: 'application/vnd.ms-excel' &#125;) // 将服务端返回的文件流（二进制）excel文件转化为blob let fileName = headers.filename if (window.navigator &amp;&amp; window.navigator.msSaveOrOpenBlob) &#123; // IE10+ window.navigator.msSaveOrOpenBlob(blob, fileName) &#125; else &#123; let objectUrl = (window.URL || window.webkitURL).createObjectURL(blob) let downFile = document.createElement('a') downFile.style.display = 'none' downFile.href = objectUrl downFile.download = fileName // 下载后文件名 document.body.appendChild(downFile) downFile.click() document.body.removeChild(downFile) // 下载完成移除元素 // window.location.href = objectUrl window.URL.revokeObjectURL(objectUrl) // 只要映射存在，Blob就不能进行垃圾回收，因此一旦不再需要引用，就必须小心撤销URL，释放掉blob对象。 &#125; &#125;) 参考连接 DOM 树HTML 文档的骨干是标签。根据文档对象模型(DOM)，每个HTML标签都是一个对象，同样标签内的文本也是一个对象。因此这些对象都可通过 JavaScript 操作如果文档中有空格（就像任何字符一样），那么它们将成为 DOM 中的文本节点，如果我们删除它们，则不会有任何内容。&lt;head&gt; 之前的空格和换行符被忽略&lt;/body&gt; 之后放置了一些东西，那么它会自动移动到 body 内部，因为 HTML 规范要求所有内容必须位于 内。所以 后面可能没有空格。 通常再浏览器中的文本不会显示开头/结尾的空文本节点，标签之间也不会显示空文本节点。 如果浏览器遇到格式不正确的HTML，在形成DOM是会自动修复它如：&lt;html&gt; 即使不在文档中，浏览器也会自动创建它 按DOM规范，table 必须具有 &lt;tbody&gt;,因此table中未使用&lt;tbody&gt; 形成DOM时会自动添加。 其它 节点：注释不会以任何方式影响视觉表示，但是必须遵循一条规则 —— 如果HTML中有东西，那么它必须在DOM树中。HTML中所有内容都是DOM的一部分，注释是一个节点甚至&lt;!DOCTYPE...&gt;也是一个节DOM总有12种节点 遍历DOM节点所有对DOM的操作都是从document对象开始，将这个对象赋予一个变量，对其进行修改操作 最顶端的节点DOM节点树可以通过 document属性使用顶端的节点对应&lt;html&gt; 并且 &lt;html&gt; = document.documentElement而&lt;body&gt; = document.body,&lt;head&gt; = document.headdocment.body可能为null，如果将script脚本放入 &lt;head&gt;标签种，那么此脚本无法访问到document.body，即为null childNodeschildNodes 集合提供对所有子节点包括文本节点的访问，它看起来是一个数字，实际上只是一个可迭代的类数组对象，因此没有数组的方法所有的Dom 集合节点都是只读的无法通过赋值来替换对应的节点除小部分节点，几乎所有的DOM集合都是实时的，它们反应的是DOM的实时状态不要是有 for...in来遍历DOM集合，此方法会列出其所有的属性。注意此属性只能访问到当前script脚本之前对应的节点可以通过elem.hasChildNodes()来检测是否含有子节点 parentNOde / siblingNode通过elem.parentNode可访问当前节点的父节点通过elem.previousSibling/elem.nextSibling可访问对应节点的上/下兄弟节点 只访问元素节点 children： 只获取类型为元素节点的子节点 firstElementChild,lastElementChild：只获取第一或最后一个子元素 previousElementSibling, nextElementSibling：兄弟元素 parentElement：父元素 parentElement 可能为null,因为其方法返回的是父元素节点，而parentNode返回的是任何类型的父节点，因此,document.documentElement.parentElement === null HTMLCollection （动态）通过元素查找子元素如果子元素是一个集合将返回 HTMLCollection 类数组12345678let tb = documet.querySelector('table')let tbs = tb.tBodies // HTMLCollection [tbody]let trs =tbs.rows // HTMLCollection [tr,tr,tr,...]let tr1 = trs[0] tr1.sectionRowIndex //0 当前 tr 在集合中的位置 tr1.rowIndex // 1 当前 tr 在整张表中的 位置let tds = tr1.cells // HTMLCollection [td,td,td,...] td[0].cellIndex //0 当前 td 在父元素 tr节点 中的位置 NodeList （静态）通过 document 中的方法 document.querySelectorAll 或elem.querySelectorAll获取的元素集合将返回NodeList类数组getElement* 方法只能通过 document对象调用12let divs = document.querySelectorAll('div') // NodeList(4) [div.Owen, div#modal, div.main, div] document.getElementsByTagName('div')//HTMLCollection [div.Owen] matcheselem.matches(css)会检测 elem是否匹配到给定的css选择器，返回 true 或 false closestelem.closest(css)此方法会查找css选择器匹配到的祖先HTML，包括自身，并返回最先找到的元素 containselem.catains(dom) 判断 dom 是否为 elem 的后代，或等于elem，返回true 或false 节点属性所有的节点都继承自根节点 EventTarget EventTarget:作为基础，让所有DOM 节点都支持事件 Node：作为DOM 节点的基础，提供DOM树的核心功能：parentNode、nextSibling、previousSibling、ChildNodes等（只能读取 getter）;文本节点 Text,元素节点Element,注释节点Comment都继承自Node Element：做为DOM 元素的基类。提供元素级导航： nextElementSibling、children、getElement*、querySelector等等，浏览器不仅支持HTML，还支持 XML、SVG等，分别对应的基类 HTMLElement、XMLElement、SVGElement HTMLElement:作为所有元素的基类，被各种元素继承 innerHTML 和 outerHTML innerHTML: 获取或替换当前节点的所有子节点（不包含当前节点） outerHTML: 替换当前节点 文档片段 DocumentFragment用于存储节点的包装器，不会再浏览器中展示，需要通过插值方法才能展示包装器里面的内容1234567891011function creatEl()&#123;let frag = new DocumentFragment(); for (let i=1;i&lt;4;i++) &#123;let li = document.createElement('li') li.append(i) frag.append(li)&#125;return frag&#125;ul.append(creatEl()) 类样式的修改等操作elem.className 对应元素的类名，多个类目以空格分隔1ul.className // "class1 class2 ..." 同时还要一个 elem.classList 对象可访问类名，它以类数组的方式存在，同时具有 add/remove/toggle/contains 等方法123456ul.classList // DOMTokenList(2) ["333", "444", value: "333 444"]ul.classList.add('class1')ul.classList.remove('class1')ul.classList.toggle('class1') // true 新增ul.classList.toggle('class1') // false 去除ul.classList.contains('class1') //false 是否包含 通常我们使用 style.*单独对样式属性进行修改，如果想要对多种样式进行调整可使用 cssText，此方法会直接替换之前的样式12345ul.style.cssText = ` color: red ; background-color: skyblue; width: 20px; text-align: center;` style 属性仅针对 style 属性值进行操作，无法读取css类中的属性值123456&lt;style&gt;body &#123;margin:20 auto;&#125;&lt;/style&gt;&lt;script&gt;document.body.style.margin // ""&lt;/script&gt; 这时我们需要使用 getComputedStyle(el,[,pseudo])方法来获取对应的值如果不传参或值无意义，将返回元素所有样式,其属性值都为解析值，如 font-size:1em 最后获取的可能为解析后的值”16px” 123let res = getComputedStyle(document.body)res.marginTop // "20px"res.margin // 谷歌 "20px 0px" 在火狐中为 "" 因此访问确切属性值须使用完整属性名 获取元素的尺寸和滚动距离 offsetTop/Left: 获取相对于设置有position属性为 absolute relative、fixed 的值或td、th、table、body的元素的距离 offsetWidth/Height：获取外部宽度/高度，包含border,padding,scrollbar (display:none 或自身不在文档中，其值为0或null，由此可判断当前元素是否被隐藏) clientTop/Left：获取内侧与外侧的距离（滚动条在左边时，包含滚动条的宽度） clientWidth/Height：获取可视区内容的宽高，即不包含滚动条和border scrollWidth/Height：获取全部内容（包含隐藏部分）的宽高 scrollTop/Left: 获取 元素隐藏部分的上/左距离，包含border,这两个属性可修改，其它属性能只读取HTML 文件里如果没有 &lt;!DOCTYPE HTML&gt; 上述的属性可能会有所不同，这不是一个 JavaScript 的问题，但会影响到 JavaScript。 滚动浏览器窗口pageXOffset/pageYOffset: 获取可视窗口移动的距离 无法设值 可通过 window.scrollBy, window.scrollTo, elem.scrollIntoView来滚动窗口 scrollBy(x,y)：滚动页面至相对于现在位置的(x,y)位置 scrollTo(x,y)：滚动到页面相对于文档左上方的（x,y）,位置，类似于 scrollTop/scrollLeft elem.scrollIntoView(truly)：如果 truly 为真则使 当前元素 滚动至窗口顶部，元素顶部与窗口顶部对齐，如果truly 为false,则当前元素底部与窗口底部对齐。 如果禁止窗口滚动可使 样式属性 overflow 值为 hidden 坐标getBoundingClientRect()`方法获取相对于可视窗口的坐标对象其所有属性都是以可视窗口左端（X）和顶部（Y）为起点123456789101112131415ul.getBoundingClientRect()/*DOMRect &#123; bottom: 829.59375 // 元素底部的Y坐标 height: 210 // 元素真实高度 left: 0 // 元素左边 X 坐标 right: 1903 // 元素右边 X 坐标 top: 619.59375 // 元素顶部 Y 坐标 width: 1903 // 元素自身真实宽度即不包含滚动条 x: 0 y: 619.59375&#125;*/ document.elementFromPointdocument.elementFromPoint(x,y)返回可视窗口坐标（x,y），最顶层的元素1let elem = document.elementFromPoint(0,0) // &lt;p&gt;556666&lt;/p&gt; 如果x,y不在正常范围内将返回 null, 相对于文档坐标，JS并未提供原生标准方法，可自己写一个出来：1234567function getDomCoords(el)&#123; let &#123;top,left&#125; = el.getBoundingClientRect() return &#123; top:top+ window.pageYOffset, left:left+window.pageXOffest &#125;&#125; Node 中的问题获取本机 IP 地址12345678910111213141516171819202122const os = require('os');const ip = showObj(os.networkInterfaces());function showObj(obj)&#123;/* for (let devName in obj)&#123; let iface = obj[devName]; for (let i = 0;i &lt; iface.length;i++)&#123; let alias = iface[i]; if (alias.family === 'IPv4' &amp;&amp; alias.address !== '127.0.0.1' &amp;&amp; !alias.internal)&#123; return alias.address; &#125; &#125; &#125; */ for (let devName in obj)&#123; let iface = obj[devName]; for (let alias of iface )&#123; if ( alias.family === 'IPv4' &amp;&amp; alias.address !== '127.0.0.1' &amp;&amp; !alias.internal) return alias.address; &#125; &#125;&#125; 开发方式当我们确定组件层级时，最容易的方式就是先用已有的数据模型渲染一个不包含交互功能的UI。最好将渲染UI 和添加交互两个过程分开 因为，编写一个应用的静态版本时，往往需要编写大量代码，不需要考虑太多交互细节；添加交互细节功能时则需考虑大量细节，而不需要编写太多代码。所以将两个过程分开进行更为合适。 自上而下首先编写较高的组件，对于简单应用使用这种方式更加方便 自下而上对于复杂应用先编写较为底层的组件，同时为底层组件编写测试的方式更加简单]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[array method]]></title>
    <url>%2F2019%2F05%2F20%2Farray%2F</url>
    <content type="text"><![CDATA[js 内置 7种类型 基本类型: string number boolean null undefined symbol 引用类型: object Array es3/es5:12345678910111213141516171819202122232425262728293031323334353637383940//改变原数组//push :向数组尾部添加数据 可添加多位//自定义pushArray.prototype.push =function()&#123; &#125;//pop :剪切尾部一项数据//unshift : 向数组前方添加数据//revesre : 翻转数组//splice : 第一个参数从第几位开始，第二个参数，截取几位，第三个参数覆盖截取的数据，返回截取的数据/* sort :排序一个函数为参数 ，同时 函数必须有两参数(a,b)1. 函数返回值为正时 b在a前面2. 为负数时 a在b前面3. 0 时 不动原理冒泡排序 */ var obj = [&#123;age:18,name:'1'&#125;,&#123;age:38,name:'1'&#125;,&#123;age:14,name:'1'&#125;,&#123;age:28,name:'1'&#125;], arr.sort(function(a,b)&#123; return a.age - b.age;//升序&#125;)//打乱有序的数组arr.sort(function(a,b)&#123; return Math.random() - 0.6;&#125;)//不改变原数组需要变量接收concat ： 拼接数组并返回 join : 将数组每一位以传进的参数链接slice : 第一个参数 开始截取为，第二个参数 截取到的位置//将类数组转化为数组 var arr=[].slice.call(arguments) string methods1234567891011121314151617var str ='123'str.split('');//camelize: 连字符转驼峰const camelizeRE = /-(\w)/gexport const camelize = cached((str: string): string =&gt; &#123; return str.replace(camelizeRE, ( _, c) =&gt; c ? c.toUpperCase() : '')&#125;)//变量的值转换为 string 类型并返回export function toString (val: any): string &#123; return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val)&#125; interation method12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 const inventors = [ &#123; first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 &#125;, &#123; first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 &#125;, &#123; first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 &#125;, &#123; first: 'Marie', last: 'Curie', year: 1867, passed: 1934 &#125;, &#123; first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 &#125;, &#123; first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 &#125;, &#123; first: 'Max', last: 'Planck', year: 1858, passed: 1947 &#125;, &#123; first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 &#125;, &#123; first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 &#125;, &#123; first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 &#125;, &#123; first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 &#125;, &#123; first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 &#125; ];// Array.prototype.filter()// 1. Filter the list of inventors for those who were born in the 1500'slet Filters= inventors.filter(el =&gt; el.year&lt;1600 ) console.table(Filters)// Array.prototype.map()// 2. Give us an array of the inventors' first and last nameslet maps = inventors.map(el =&gt;`$&#123;el.first&#125; $&#123;el.last&#125;`) console.log(maps)// Array.prototype.sort()// 3. Sort the inventors by birthdate, oldest to youngest inventors.sort((a,b) =&gt; a.year-b.year) console.table(inventors)// Array.prototype.reduce()// 4. How many years did all the inventors live? let lives = inventors.reduce((first,second)=&gt;(first+(second.passed - second.year)), 0) console.table(lives)// 5. Sort the inventors by years lived inventors.sort((a,b) =&gt; -((a.passed-a.year)-(b.passed-b.year))) console.table(inventors) const people = [ &#123; name: 'Wes', year: 1988 &#125;, &#123; name: 'Kait', year: 1986 &#125;, &#123; name: 'Irv', year: 1970 &#125;, &#123; name: 'Lux', year: 2015 &#125; ];const coms = [ &#123; text: 'Love this!', id: 523423 &#125;, &#123; text: 'Super good', id: 823423 &#125;, &#123; text: 'You are the best', id: 2039842 &#125;, &#123; text: 'Ramen is my fav food ever', id: 123523 &#125;, &#123; text: 'Nice Nice Nice!', id: 542328 &#125;];// Some and Every Checks// Array.prototype.some() // is at least one person 19 or older?let isNineOld = people.some(el=&gt; (new Date()).getFullYear() - el.year&gt;=19)// Array.prototype.every() // is everyone 19 or older?let everyone=people.every(el=&gt; (new Date()).getFullYear() - el.year&gt;=19)// Array.prototype.find()// Find is like filter, but instead returns just the one you are looking for// find the comment with the ID of 823423let comment = coms.find(el=&gt;el.id ===823423 )// Array.prototype.findIndex()// Find the comment with this IDlet i = coms.findIndex(el=&gt;el.id ===823423 )// delete the comment with the ID of 823423let newcoms = [...coms.slice(0,i),coms.slice(i+1)]coms.splice(i,1) Label123456789101112131415161718192021222324// 举一个比较典型的例子，看完后即明白 Label 的应用：（未添加 Label） var num = 0; for (var i = 0 ; i &lt; 10 ; i++)&#123; for (var j = 0 ; j &lt; 10 ; j++)&#123; if( i == 5 &amp;&amp; j == 5 )&#123; break; &#125; num++; &#125; &#125; alert(num); // 循环在 i 为5，j 为5的时候跳出 j循环，但会继续执行 i 循环，输出 95// 对比使用了 Label 之后的程序：（添加 Label 后） var num = 0; outPoint: for (var i = 0 ; i &lt; 10 ; i++)&#123; for (var j = 0 ; j &lt; 10 ; j++)&#123; if( i == 5 &amp;&amp; j == 5 )&#123; break outPoint; &#125; num++; &#125; &#125; alert(num); // 循环在 i 为5，j 为5的时候跳出双循环，返回到outPoint层继续执行，输出 55]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2019%2F04%2F21%2Falgorithm%2F</url>
    <content type="text"><![CDATA[术语 时间复杂度: 一个算法执行所耗费的时间。 一个算法花费的时间与算法中语句的执行次数成正比例,一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化，要知道变化时呈现什么规律就引入了时间复杂度概念算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 空间复杂度: 运行完一个程序所需内存的大小。 一个算法所需的存储空间用f(n)表示。S(n)=O(f(n)) 其中n为问题的规模，S(n)表示空间复杂度。 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 更多信息 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素(自己不能跟自己加起来等于target)。 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解答：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */// 方法一 嵌套循环 时间复杂度：O(n^2) 空间：O(2)var twoSum = function(nums, target) &#123; for (let [i,k] of nums.entries())&#123; for (let j = i+1; j&lt; nums.length; j++) &#123; if( (target - k) === nums[j]) &#123; return [i,j]; &#125; &#125; &#125;&#125;;// 方法二 嵌套循环 比 方法一 更快var twoSum = function(nums, target) &#123; let len = nums.length; for (let i = 0; i&lt;len; i++)&#123; for (let j = i+1; j&lt;len; j++) &#123; if( (target - nums[i]) === nums[j]) &#123; return [i,j]; &#125; &#125; &#125;&#125;;// 方法三 has表 时间复杂度：O(n) 空间：O(n)/** * 存储对应的值 和 索引 */var twoSum = function(nums, target) &#123;userManage const m = new Map(); const len = nums.length； for (let i = 0; i &lt; len; i++ ) &#123; if(m.has(nums[i]) &amp;&amp; m.get(nums[i]) !== i)&#123; return [m.get(nums[i]),i] &#125; m.set((target - nums[i]),i); &#125;&#125;;//orvar twoSum = function(nums, target) &#123; const m = new Map(); const len = nums.length； for (let i = 0; i &lt; len; i++ ) &#123; let res = target - nums[i]; if(m.has(res) &amp;&amp; m.get(res) !== i)&#123; return [m.get(res),i] &#125; m.set(nums[i],i); &#125;&#125;; 整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 12345678910111213141516171819202122/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123; let res =( x+'' ).split(""); if(res[0] !== '-')&#123; let num = parseInt(res.reverse().join(''),10); if( num&gt; Math.pow(2,31) -1)&#123; return 0 &#125; return num; &#125;else&#123; res.reverse().pop(); let num = parseInt(res.join(''),10); if( num&gt; Math.pow(2,31) -1)&#123; return 0 &#125; return '-' + num; &#125;&#125;; 回文数 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数 。 输入: 121 输出: true输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。注意 0 是回文数 进阶: 不将整数转为字符串来解决这个问题 123456789101112131415161718192021222324/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */ // 方法 一 转化未字符串var isPalindrome = function(x) &#123; return x &lt; 0? false: (parseInt((x+'').split('').reverse().join('')) === x ? true : false);&#125;;/** * 方法二 中间数的右边反转后 等于 左边 * 提取中间数的右边 通过 *10 、 %10 来提取 * */var isPalindrome = function(int) &#123; if(int &lt; 0 || (int%10 === 0 &amp;&amp; int !== 0)) return false; let num = 0; while (int &gt; num )&#123; num = num * 10 + int % 10; int = parseInt(int/10); &#125;console.log(int,num) return int === num || int === parseInt(num/10);&#125;;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Sum of two numbers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生Ajax的封装 和 Axios的 二次封装]]></title>
    <url>%2F2019%2F04%2F17%2Faxios%2F</url>
    <content type="text"><![CDATA[AJAX异步的JavaScript与XML技术（ Asynchronous JavaScript and XML ）Ajax 核心使用 XMLHttpRequest （XHR）对象,首先由微软引入的一个特性；Ajax 不需要任何浏览器插件，能在不更新整个页面的前提下维护数据（可以向服务器请求额外的数据无需重载页面），但需要用户允许JavaScript在浏览器上执行。 XHR 对象用法1var xhr = new XMLRequestHttp() // 通过XMLHttpRequest 构造函数来创建 open 方法1xhr.open(method, url, async, user, password); -method：要发送的请求类型 GET、POST、PUT、DELETE 。（必选）url：请求的URL （必选） axync ：布尔值，是否异步发送请求，默认true（true 时，已完成事务的通知可供事件监听使用，如果 xhr.multipart为true,则此参数必须为true；false 时，send()方法直到收到答复前不会返回） user：用户名用于认证用途 默认 null password：用户名用于认证用途 默认 null 调用open方法不会真正发送请求，只是准备发送请求，并且URL有同源策略的限制（须和页面的主域、端口、协议一致，只要一处不符合要求将报错，数据将被拦截，可通过前后端配置，或使用代理来解决）。 setRequestHeader()如需设置 Accpet 头部信息，可通过setRequestHeader() 方法来设置 Accpet 头部信息：告知客户端可以处理的内容类型，用 MIME类型 表示；服务端使用 Content-Type 通知客户端它的选择媒体类型（ MIME类型 ） ：一种标准，用来表示文档、文件或字 节流的性质和格式。 完整类型列表 Content-Type ：实体头部用于指示资源的 MIME 类型，告诉客户端实际返回的内容类型；浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。1xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded') send 方法 data：作为请求主体发送的数据，如果不需要通过请求主体发送数据，则必须传 null调用 send()发送请求，在收到响应后，响应的数据会自动填充XHR对象的属性 1xhr.send(data); responseText ：从服务端返回的文本123456xhr.onload = function () &#123; if (xhr.readyState === xhr.DONE) &#123; if (xhr.status === 200) &#123;5 console.log(xhr.responseText); &#125; &#125;&#125;; responseXML如果响应的 Content-Type 为text/html 或 application/xml，将保存包含响应数据的 XML DOM 文档，对于其它类型的数据则为 null, 也可通过overrideMimeType() 强制 XHR 对象解析为 XML123456789// overrideMimeType() 用来强制解析 response 为 XMLxhr.overrideMimeType('text/xml');xhr.onload = function () &#123; if (xhr.readyState === xhr.DONE) &#123; if (xhr.status === 200) &#123; 8 console.log(xhr.responseXML); &#125; &#125;&#125;; status返回响应的HTTP状态码，请求完成前值为0，如果XHR 对象出错 值也是0， 200 表示请求成功，304表示请求的资源并没有修改，可直接使用浏览器种缓存的数据。 其它状态信息 statusText 返回响应的HTTP状态说明，status 值为 200 时 statusText为 “OK” readyState返回一个当前XHR对象所处的活动状态 值 状态 描述 0 UNSENT 代理被创建，但尚未调用 open() 方法。 1 OPENED open() 方法已经被调用。 2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。 3 LOADING 下载中；响应体部分正在被接收 responseText 属性已经包含部分数据。 4 DONE 下载操作已完成。 onreadystatechange当 readyState变化时会触发次事件函数，如果使用 abort() 取消请求则次事件函数不会被触发12345xhr.onreadystatechange = function () &#123; if(xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125; 参考资料封装示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 创建 构造函数function Ajax(obj) &#123; this.url = obj.url ||''; this.type = obj.type || 'get'; this.data = obj.data ||&#123;&#125;; this.success = obj.success || null; this.error = obj.error || null;&#125;// 再原型上创建方法Ajax.prototype.send = function()&#123; var self = this; var toStr = Object.prototype.toString; if (self.data === null &amp;&amp; typeof self.data !== 'object' &amp;&amp; Array.isArray(obj)) return; return (function()&#123; // 实例化 XML对象 var xhr = new XMLHttpRequest(); var data = ''; // 序列化参数 for (var k in self.data)&#123; data += k + '=' + self.data[k] + '&amp;'; &#125; data = data.substr(0,data.length - 1); // 接收回调函数 xhr.onreadystatechange = function()&#123; if (xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; isFunction(self.success) &amp;&amp; self.success(xhr.responseText) &#125;else&#123; isFunction(self.error) &amp;&amp; self.error(xhr) &#125; &#125; &#125; // 初始化请求 if(self.type.toLocaleLowerCase() === 'post')&#123; xhr.open ('post',self.url,true) // 设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); //发送请求 xhr.send(data) &#125; else &#123; xhr.open('get', self.url + "?" + data,true) xhr.send(null) &#125; &#125;());&#125;;function isFunction(obj)&#123; return toStr.call(obj) === "[object Function]"&#125;var ajax = new Ajax(&#123; type:'post', url:"/login", data:&#123; loginname:"admin", password:"admin" &#125;, success:function(e)&#123; console.log(e) &#125;, error:function(err)&#123; console.log(err) &#125;, &#125;).send(); XMLHttpRequest Level 2 相比于 老版本的 XMLHttpRequest 新增以下内容：可以设置 HTTP 请求超时时间 123456789var xhr = XMLHttpRequest();xhr.open('GET','url');// 超时 2sxhr.timeout = 2000;// 超时处理xhr.ontimeout = function(e) &#123; console.log(e)&#125;xhr.send(null) 可以通过 FormData 发送表单数据 1234567 // 实例化 FormDatavar formData = new FormData(); // 添加数据 formData.append(key,value); xhr.open('POST','url'); xhr.send(formData); 可以上传文件 FormData 除了可以添加字符串数据，也可以添加 blob、file 类型的数据，因此可以用于上传文件。 在浏览器中，一般是通过文件上传输入框来获取 file 对象，比如： 1&lt;input type="file" name='uploadFile' id="upload-file" /&gt; 12345678document.getElementById('upload-file') .addEventListener('change', function () &#123; var formData = new FormData(); // 获取数据 formData.append('uploadFile', this.files[0]) xhr.send(formData) &#125;) 支持跨域请求 浏览器默认是不允许跨域请求的，有时候又是必要的，在以前通常使用JSONP来解决（IE10 以下不支持） 为了标准化跨域请求， W3C提出 跨域资源共享（CORS）前端无须修改代码，只需 服务器返回 Access-Control-Allow-Origin 响应头，指定允许对应的域，如果是公共资源可指定“*” CORS 默认不发送 cookie 如果需要发送，前端需要设置 withCredentials属性，同时服务器需要 返回 Access-Control-Allow-Credentials: true 1xhr.withCredentials = true; 检测XHR是否支持CORS最简单的方式，就是检查是否存在 withCredentials，再检测XDomainRequest 对象是否存在，即可兼顾所有浏览器 12345678910111213141516171819let createCORSRequest = (method,url)=&gt;&#123; let var xhr = mew XMLHttpRequest(); if ('withCredentials' in xhr)&#123; xhr.open(method,url,true); &#125;else if(typeof XDomainRequest != 'undefined')&#123; xhr = new XDomainRequest(); xhr.open(method,url); &#125;else&#123; xhr = null &#125; return xhr&#125; let request = createCORSRequest('get','baidu.com') if(request)&#123; request.onload = function()&#123; // request.responseText &#125; request.send() &#125; Preflighted Requests： 一个透明服务器验证机制，用于检查服务器是否支持CORS这是一个 OPTIONS 请求，使用了三个请求头 Access-Control-Request-Method：请求自身使用的方法 Access-Control-Request-Headers：自定义头部信息，多个头部以逗号分隔 Origin报头：和简单请求相同，将请求的域发送给服务端，服务端再Access-Control-Allow-Origin 响应头中返回同样的域即可解决跨域问题。 img src特性： 一个网页可以从任何网页中加载图像，不用担心跨域问题，通过onload 和 onerror 事件处理确定是否接收到响应 请求的数据通过查询字符串形式发送，响应可以是任意内容，通常是像素图或204响应。 只能发送 get 请求，无法访问服务器的响应文本12345let img = new Image();img.onload = function ()&#123; console.log('done')&#125;img.src = 'http://www.baidu.com?test=test1' 请求数据 可以获取服务端二进制数据 使用 overrideMimeType 方法覆写服务器指定的 MIME 类型，从而改变浏览器解析数据的方式123456// 参数 MIME 类型// 告诉浏览器，服务器响应的内容是用户自定义的字符集xhr.overrideMimeType('text/plain; charset=x-user-defined');// 浏览器就会将服务器返回的二进制数据当成文本处理，我们需要做进一步的转换才能拿到真实的数据 // 获取二进制数据的第 i 位的值 var byte = xhr.responseText.charCodeAt(i) &amp; 0xff “&amp; 0xff” 运算 参考 阮一峰的文章 xhr.responseType 用于设置服务器返回的数据的类型,将返回类型设置为 blob 或者 arraybuffer，然后就可以从 xhr.response 属性获取到对应类型的服务器返回数据。12345xhr.responseType = 'arraybuffer'xhr.onload = function () &#123;var arrayBuffer = xhr.response// 接下来对 arrayBuffer 做进一步处理...&#125; 可以获取数据传输进度信息 参考资料 使用 onload 监听了一个数据传输完成的事件。1234567// 上传进度监听xhr.upload.addEventListener('progress', onProgressHandler, false);// 传输成功完成xhr.upload.addEventListener('load', onLoadHandler, false);// 传输失败信息xhr.upload.addEventListener('error', onErrorHandler, false); 兼容性 更多资料参考:阮一峰的文章MDN Axios 基于 Promise 的 Http 库 可以在客户端 和 nodeJs中使用 在客户端创基 XMLHttpRequests 在nodeJs 创建 HTTP 请求 支持Promise 可拦截转化请求和响应数据 取消请求 自动转化JSON数据 支持客户端 XSRF 兼容性 安装1npm install axios methodsGet123456789101112131415161718192021const axios = require('axios')axios.get('url?id=xxx') .then(res =&gt; &#123; console.log(res) &#125;) .catch(err =&gt;&#123; console.log(err) &#125;)//oraxios.get('url',&#123; params:&#123; id:'xxxxx' &#125; &#125;) .then(res =&gt;&#123; console.log(res) &#125;) .catch(err =&gt;&#123; console.log(err) &#125;) 同样的传参方法有 delete post1234567axios.post('url',&#123;name:'Owen'&#125;) .then(res =&gt;&#123; console.log(res) &#125;) .catch(err =&gt;&#123; console.log(err) &#125;) 同样的传参方法有 put patch concurrent requests1axios.all([axios.get('url1'),axios.get('url2')]) API axios(config)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180axios(&#123; method:'get', // default is get url:'url', // request url data:&#123; // 仅支持post，put和patch方法，数据作为请求主体发送 ( Only the post,put and patch methods are supported, and the data is sent as the request body ) /* 浏览器仅支持传递 FormData, File, Blob （The browser only supports passing FormData, File and Blob) Node 仅支持传递 Stream, Buffer (The Node only supports passing Stream, Buffer) */ name:'owen' &#125;, baseURL:'base/url', // 除非url是绝对路径，否则将baseURL添加到url的前面 (Add baseURL to then front of the url unless the url is an absolute path) transformRequest: [function (data, headers) &#123; // 可以修改发送的请求数据和请求头，只支持put，post和patch，回调函数必须返回Buffer，ArrayBuffer，FormData或Stream数据 // Can modify the sent request data and request header,only support put, post and patch. // Callback must return Buffer, ArrayBuffer, FormData or Stream data // Do whatever you want to transform the data return data; &#125;], transformResponse: [function (data) &#123; // 修改响应数据，再传递给 then或catch 方法 （Modify the response data and pass it to the then or catch method) // Do whatever you want to transform the data return data; &#125;], headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // 自定义请求头 (Custom request header) params:&#123; // 添加到url尾部的参数，一般用于get 和 delete（ Parameters addde to the end of the url,generally used for get and delete ) id:'xxx' &#125;, paramsSerializer: function (params) &#123; //序列化 [params] (https://www.npmjs.com/package/qs) return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, timeout:1000,// default is 0 , 设置请求超时时间，单位毫秒 （ Set request timeout in milliseconds ) withCredentials: true, // default is false, 跨域时是否携带cookie（ Whether to carry cookies when crossing domains ) adapter: function (config) &#123; /*拦截响应数据*/ // At this point: // - config has been merged with defaults // - request transformers have already run // - request interceptors have already run // Make the request using config provided // Upon response settle the Promise return new Promise(function(resolve, reject) &#123; var response = &#123; data: responseData, status: request.status, statusText: request.statusText, headers: responseHeaders, config: config, request: request &#125;; settle(resolve, reject, response); // From here: // - response transformers will run // - response interceptors will run /** * Resolve or reject a Promise based on response status. * * @param &#123;Function&#125; resolve A function that resolves the promise. * @param &#123;Function&#125; reject A function that rejects the promise. * @param &#123;object&#125; response The response. */ function settle(resolve, reject, response) &#123; var validateStatus = response.config.validateStatus; if (!validateStatus || validateStatus(response.status)) &#123; resolve(response); &#125; else &#123; reject(createError( 'Request failed with status code ' + response.status, response.config, null, response.request, response )); &#125; &#125;; /** * Create an Error with the specified message, config, error code, request and response. * * @param &#123;string&#125; message The error message. * @param &#123;Object&#125; config The config. * @param &#123;string&#125; [code] The error code (for example, 'ECONNABORTED'). * @param &#123;Object&#125; [request] The request. * @param &#123;Object&#125; [response] The response. * @returns &#123;Error&#125; The created error. */ function createError(message, config, code, request, response) &#123; var error = new Error(message); return enhanceError(error, config, code, request, response); &#125; /** * Update an Error with the specified config, error code, and response. * * @param &#123;Error&#125; error The error to update. * @param &#123;Object&#125; config The config. * @param &#123;string&#125; [code] The error code (for example, 'ECONNABORTED'). * @param &#123;Object&#125; [request] The request. * @param &#123;Object&#125; [response] The response. * @returns &#123;Error&#125; The error. */ function enhanceError(error, config, code, request, response) &#123; error.config = config; if (code) &#123; error.code = code; &#125; error.request = request; error.response = response; error.isAxiosError = true; error.toJSON = function() &#123; return &#123; // Standard message: this.message, name: this.name, // Microsoft description: this.description, number: this.number, // Mozilla fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, // Axios config: this.config, code: this.code &#125;; &#125;; return error; &#125; &#125;); &#125;, auth:&#123; // 表示应使用HTTP Basic身份验证，并提供凭据 ( indicates that HTTP Basic auth should be used, and supplies credentials. ) user:'xxx', password:'***' &#125;, responseType: 'json',/* 服务器响应的数据类型（ The server response data type ） 支持 arraybuffer, blob, document, json, text, stream */ responseEncoding:'utf8', // 用于解码响应的编码 (Encoding for decoding the response ) xsrfCookieName: 'XSRF-TOKEN', // default is XSRF-TOKEN , csrf令牌Cookie 名称 xsrfHeaderName: 'X-XSRF-TOKEN', //default is X-XSRF-TOKEN, xsrf标记值的http标头的名称onUploadProgress: function (progressEvent) &#123; //上传进度事件 （handling of progress events for uploads ） console.log(progressEvent) &#125;,onDownloadProgress: function (progressEvent) &#123; // 下载进度事件 （ handling of progress events for downloads） console.log(progressEvent) &#125;,maxContentLength: 2000, // 允许响应内容的最大字节 （defines the max size of the http response content in bytes allowed）validateStatus: function (status) &#123; // 返回给定HTTP状态范围, 如果状态在给定范围内，响应数据传给`then` ，否则传给 `catch` ( Returns the given HTTP status range, if the status is within the give range, the respones data is passed to `then`, otherwise passed to `catch` ) return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, maxRedirects: 5, // default is 5 // 定义Node 中最大重定向数 ( defines the maximunn number of redirects in Node ) socketPath: null, // default is null 定义要在node.js中使用的 UNIX socket httpAgent: new http.Agent(&#123; keepAlive: true &#125;), // node 中 http 和 https 的代理 httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),// http://nodejs.cn/api/http.html proxy: &#123; // 代理配置 host: '127.0.0.1', port: 9000, auth: &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, cancelToken: new CancelToken(function (cancel) &#123; // 取消请求的 token &#125;) &#125;) .then(res =&gt;&#123; console.log(res) &#125;) .catch(err =&gt;&#123; console.log(err) &#125;) 全局配置 通过 axios.create 方法来替换全局配置 123const instance = axios.create(&#123; baseURL: 'base/url'&#125;); 通过axios.defaults 对象替换全局默认配置 12instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 拦截器 拦截请求前的数据 12345axios.interceptors.request.use(function (config) &#123; return config; &#125;, function (error) &#123; return Promise.reject(error); &#125;); 拦截响应数据 1234567axios.interceptors.response.use(function (response) &#123; // Do something with response data return response; &#125;, function (error) &#123; // Do something with response error return Promise.reject(error); &#125;); 删除拦截器 12const myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 二次封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/** * @desc: axios封装 * @author: ggw * @module: axios * @description: 配合使用 饿了么的 Message和Loading * @Date: 2018 */import axios from 'axios';import qs from 'qs';import &#123; Message, Loading&#125; from 'element-ui';import router from '../router';let loading;let headerNone = &#123; 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'&#125;;let headerTwo = &#123; 'Content-Type': 'application/json; charset=UTF-8'&#125;;let baseURL = window.location.origin ;/** * @description: 定义初始化Loading * @method: startLoading */ const startLoading = () =&gt; &#123; loading = Loading.service(&#123; target: '.content-box', background: 'rgba(220, 220, 220, 0.51)' &#125;);&#125;;let count = 0;/** * @description: 显示Loading 同时多个发送请求 只开启一次Loading * @method: showLoading &amp;&amp; hideLoading */ const showLoading = () =&gt; &#123; if (count === 0) startLoading(); count++;&#125;; const hideLoading = () =&gt; &#123; if (count &lt;= 0) return; count--; if (count === 0) &#123; setTimeout(() =&gt; &#123; loading.close(); &#125;, 300); &#125;&#125;;export let filiter = r =&gt; &#123; for (let item of Object.keys(r)) &#123; if (r[item] === ' ' || r[item] === '') &#123; delete r[item]; &#125; &#125;&#125;;/** * @description: 出口 * @exports api * @param:options 必须是对象 * options 对象为 axios对应参数 */export default (options) =&gt; &#123; /** * @description: 用来初始化承诺的回调。 * 这个回调被传递了两个参数： * 一个解析回调用一个值或另一个承诺的结果来解析承诺， * 以及一个拒绝回调，用来拒绝承诺的原因或错误。 * @constructor: Promise */ return new Promise((resolve, reject) =&gt; &#123; const instance = axios.create(&#123; withCredentials: true, headers: headerNone, baseURL &#125;); // 请求拦截器 instance.interceptors.request.use(config =&gt; &#123; let &#123;load = true&#125; = config.data || config.params || &#123;&#125; ; if (load) showLoading(); // 过滤无值参数 if (config.params) &#123; delete config.params.load; filiter(config.params); &#125; else if (config.data) &#123; filiter(config.data); delete config.data.load; &#125; if ( config.method.toLocaleLowerCase() === 'post' || config.method.toLocaleLowerCase() === 'put' ) &#123; // json 格式传递 if (config.json) &#123; config.headers = headerTwo; &#125; else &#123; config.data = qs.stringify(config.data); config.data = config.data + '&amp;t=' + Date.now(); &#125; &#125; return config; &#125;, error =&gt; &#123; hideLoading(); return Promise.reject(error); &#125;); // 响应拦截器 instance.interceptors.response.use(response =&gt; &#123; setTimeout(hideLoading,0); let data; // IE9时response.data是undefined，因此需要使用response.request.responseText(Stringify后的字符串) if (!response.data ) &#123; data = response.request.responseText; &#125; else &#123; data = response.data; &#125; switch (data.code) &#123; // 接口定义字段 case '001': Message(&#123; showClose: true, message: data.msg || '未知错误,请联系管理员', type: 'error' &#125;); router.push(&#123; path: '/login' &#125;); break; default: &#125; return data; &#125;, err =&gt; &#123; hideLoading(); if (err &amp;&amp; err.response) &#123; let msg = &#123; 400: '请求错误', 401: '未授权，请登录', 403: '拒绝访问', 404: `请求地址出错: $&#123;err.response.request.responseURL&#125;`, 408: '请求超时', 500: '服务器内部错误', 501: '服务未实现', 502: '网关错误', 503: '服务不可用', 504: '网关超时', 505: 'HTTP版本不受支持' &#125;; let status = parseInt(err.response.status,10); Message(&#123; showClose: true, message: msg[status] || '', type: 'error' &#125;); &#125; else &#123; Message(&#123; message: err.config ? `请求地址出错: $&#123;err.config.url&#125;` : err, type: 'error' &#125;); &#125; return Promise.reject(err); &#125;); // 请求 instance(options) .then(res =&gt; &#123; resolve(res); return false; &#125;) .catch(error =&gt; &#123; reject(error); &#125;); &#125;);&#125;;]]></content>
      <categories>
        <category>XMLHttpRequest</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class]]></title>
    <url>%2F2019%2F04%2F17%2Fclass%2F</url>
    <content type="text"><![CDATA[class 生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令 123456789class Point &#123; // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 实例的属性除非显式定义在其本身（即定义在this对象上）， 否则都是定义在原型上（即定义在class上）。 12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 与 ES5 一样，类的所有实例共享一个原型对象。 避免对环境产生依赖，生产环境中，我们可以使用 Object.getPrototypeOf方法来获取实例对象的原型，然后再来为原型添加方法/属性。 12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return 'Oops' &#125;;p1.printName() // "Oops"p2.printName() // "Oops"var p3 = new Point(4,2);p3.printName() // "Oops" 由于p1的原型就是p2的原型，因此p2也可以调用这个方法。 而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 constructor constructor方法是类的默认方法, 通过new命令生成对象实例时，自动调用该方法。 一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。相当于es5 new Vue 1234567891011class Point &#123;&#125;// 等同于 class Point &#123; constructor() &#123;&#125; //JavaScript 引擎会自动为它添加一个空的constructor方法。&#125;// 等同于new Point ()&#123; &#125; constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 表达式定义12345678910const MyClass = class Me &#123; getClassName() &#123; return Me.name; //这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。 &#125;&#125;;//内部没用到Me的话可以省略Meconst YouClass = class &#123;//...&#125;; 采用 Class 表达式，可以写出立即执行的 Class。 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // "张三" 不存在变量提升 （hoist），必须保证子类在父类之后定义 ，这一点与 ES5 完全不同。12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 继承类123456&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; //Bar继承Foo &#125;&#125; 私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。有三种方法可模拟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//第一种class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // _bar方法前面的下划线，表示这是一个只限于内部使用的私有方法 但是，在类的外部，还是可以调用到这个方法。&#125;//第二种class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // 内部调用了bar.call(this, baz)，成为了当前模块的私有方法&#125;//私有方法移出模块function bar(baz) &#123; return this.snaf = baz;&#125;//第三种const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。&#125;; 私有属性的提案 方法是在属性名之前，使用#表示。 1234567891011121314class Point &#123; #x=0;// 私有属性可以指定初始值，在构造函数执行时进行初始化。 constructor(x = 0) &#123; #x = +x; // 写成 this.#x 亦可 &#125; get #x() &#123; return #x &#125; set #x(value) &#123; #x = +value &#125; #sum() &#123; return #a + #b; &#125; //私有方法 // #x是一个私有属性，它的读写都通过get #x()和set #x()来完成。 #x和x是两个不同的属性&#125;//JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。@已经留给了 Decorator。 私有属性不限于从this引用，类的实例也可以引用私有属性 123456789class Foo &#123; #privateValue = 42; static getPrivateValue(foo) &#123; return foo.#privateValue; &#125;&#125;Foo.getPrivateValue(new Foo()); // 42console.log(Foo.#privateValue) // 报错 class 的取值函数（getter）和存值函数（setter）12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter']]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS问题整理]]></title>
    <url>%2F2019%2F04%2F10%2FJSquestion%2F</url>
    <content type="text"><![CDATA[赋值运算符多次出现，优先计算问题(结合性) 赋值表达式为右结合先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用。1234567891011121314151617181920212223242526272829303132333435363738394041424344a = b = c = v/*先解析 左侧的操作数1. refa2. refb3. refc4. value v*/refa = (refb = (refc = value v))/* 再计算右侧表达式的值 然后和从右到左赋值1. value v 赋值 refc2. value v 赋值 refb3. calue v 赋值 refa4. 返回 value v*/ //examplevar foo = &#123;n:1&#125;;var bar = foo;foo.x = foo = &#123;n:2&#125;;/*变量名 存储在栈中， 引用对象存储在堆中根据规则 先解析 =号左侧的引用 refx = (refo = &#123;n:2&#125;)再赋值refo = &#123;n:2&#125; //refo 开辟新指针 foo 指向 &#123;n:2&#125;refx = &#123;n:2&#125; // 在原refo指针对象中开辟新指针 指向 &#123;n:2&#125;结果 refo.x == undefined*//*或者 foo.x赋值前是&#123;n:1,x:unfiend&#125;;赋值后&#123;n:1,x:&#123;n:2&#125;&#125;;*/foo.x //undefinedbar.x // &#123;n: 1, x: &#123;n:2&#125;&#125;; split123456'81 newO'.split('') //["8", "1", " ", "n", "e", "w", "O"]'81 newO'.split(' ')// ["81", "newO"]'81 newO'.split('').reverse().join('');//"Owen 18" ###]]></content>
      <tags>
        <tag>JSQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interator]]></title>
    <url>%2F2019%2F04%2F04%2FInterator%2F</url>
    <content type="text"><![CDATA[Interator “集合”数据的结构主要有 Array 、Object、 Set and Map ，任何数据结构只要部署 Iterator 接口，就可完成遍历操作 遍历过程： 创建指针，指向当前数据结构起始位。（遍历对象本质是一个指针对象）。 依次循环调用指针对象的 next方法，对应指向数据结构成员，直至结束。每次调用next方法，返回对象当前成员的信息{value：text,done:true},其中value表示成员值，done` 表示遍历是否结束 123456789101112131415161718let arr = ['Owen','18'];let makeInterator = array =&gt;&#123; let index = 0; return &#123; next ()&#123; return index &lt; array.length ? &#123;value:array[index++],done:false&#125; : &#123;value:undefined, done:true&#125; &#125; &#125;&#125;let inter = makeInterator(arr);inter.next()it.next() // &#123; value: "Owen", done: false &#125;it.next() // &#123; value: 18, done: false &#125;it.next() // &#123; value: undefined, done: true &#125; 对与遍历器对象来说 done: false and value:undefined 可省略 原生具备 Iterator 的数据结构：Array 、 String 、 Map、 Set 、arguments and NodeList 都默认部署 [Symbol.iterator] 方法1234567891011121314151617181920212223//const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;;obj[Symbol.iterator]().next() //&#123;value: 1, done: true&#125;let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125;iter.next() // &#123; value: undefined, done: true &#125; 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//原型上部署Interatorclass RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; return &#123;done: true, value: undefined&#125;; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value); // 0, 1, 2&#125;//对象上部署Interatorfunction Obj(value) &#123; this.value = value; this.next = null;&#125;Obj.prototype[Symbol.iterator] = function() &#123; var iterator = &#123; next: next &#125;; var current = this; function next() &#123; if (current) &#123; var value = current.value; current = current.next; return &#123; done: false, value: value &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; return iterator;&#125;var one = new Obj(1);var two = new Obj(2);var three = new Obj(3);one.next = two;two.next = three;for (var i of one)&#123; console.log(i); // 1, 2, 3&#125; 类似数组对象，可引用 Array.prototype[Symbol.iterator]123456789101112131415161718//NodeListNodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];// 或者NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];[...document.querySelectorAll('div')] //objlet iterable = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for (let item of iterable) &#123; console.log(item); // 'a', 'b', 'c'&#125; 一些 默认调用 Iterator 的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 解构赋值let set = new Set().add('a').add('b').add('c');let [x,y] = set; // x='a'; y='b'let [first, ...rest] = set; // first='a'; rest=['b','c'];//扩展运算符var str = 'hello';[...str] // ['h','e','l','l','o']let arr = ['b', 'c'];['a', ...arr, 'd'] // ['a', 'b', 'c', 'd']//yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125;// for...of//for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、 Generator 对象，以及字符串。let arr = document.querySelectorAll("p");for (let item of arr ) &#123; console.log(item)&#125;/* 其他操作*/Array.from()Map(), Set(), WeakMap(), WeakSet() //生成对应数据结构Promise.all()Promise.race() 遍历器return方法和throw方法return() return方法必须返回一个对象。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。如果for…of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。 1234567891011121314151617181920212223242526function readFile(file) &#123; return &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123;done:false&#125; &#125;, return()&#123; file.close() return &#123;done:true&#125; &#125; &#125;; &#125; &#125;;&#125;//触发 return()for (let line of readFile(fileName)) &#123; console.log(line); break;&#125;//触发 return()for (let line of readLinesSync(fileName)) &#123; console.log(line); throw new Error();&#125; for…of 和其他遍历语法对比12345678910111213141516171819202122232425262728293031323334353637383940414243let arr = [1,2];//普通 `for`循环 for (var index = 0; index &lt;arr.length; index++) &#123; console.log(arr[index]);&#125;/** * 书写比较麻烦*/// Array.forEach arr.forEach(function(item)&#123; console.log(item)&#125;)/** * 无法跳出循环，无法使用 break or return */// for...infor (let index in arr) &#123; console.log(arr[index]);&#125;/** * 1.数组键名为字符串形式的数字 * 2.会遍历出原型链上的键，和手动添加的键 * 3.有些情况是无顺序遍历 */for (let item of arr) &#123; console.log(item);&#125;/** * 1.语法简洁 * 2.没有 for...in 的缺点 * 3.可以使用 return、break and continue * */]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Interator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator]]></title>
    <url>%2F2019%2F04%2F04%2Fgenerator%2F</url>
    <content type="text"><![CDATA[Generator ES6 提供的一种异步编程解决方案Generator 函数是一个状态机，封装了多个内部状态。还是一个遍历器对象生成函数。返回遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 Generator 函数特征 function关键字和函数名之间 有 * ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。 函数体内部有 yield 表达式123456789101112131415function* generator() &#123; yield 'Owen'; yield 18; return 'end';&#125;//调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象 Iterator let person = generator();person.next() //&#123;value:'Owen',done:false&#125;person.next() //&#123;value:18,done:false&#125;person.next() //&#123;value:'end',done:true&#125;person.next() //&#123;value:undefined,done:true&#125;person.next() //&#123;value:undefined,done:true&#125; yield yield 后面的表达式以分号作为结束语句一种可以暂停函数执行的表达式，配合 next方法使用。只能再在 Generator 函数中使用，普通函数中使用会报错.yield 如果用在另一个表达式中,必须用圆括号包起来，作为函数参数或者赋值表达式右边可以不用加括号。 next 运行逻辑 调用 next 遇到 yield表达式 暂停执行函数后面的操作，并且 紧跟 yield 后面的表达式的值作为返回对象 value 属性的值。 再次调用 next,继续执行yield表达式 后面的逻辑代码，直到下一个 yield表达式 或者 return 语句，返回值为 对象 value 属性的值。 如果没有 return 语句 ，则 value 属性的值为 undefined。 只有调用next方法，才会执行对应 yield 后面的表达式12345678function* g()&#123; yield 1 + 2&#125;let num = g() num //g &#123;&lt;suspended&gt;&#125;num.next() //&#123;value:3,done:false&#125;num.next() //&#123;value:undefined,done:true&#125; 使用 Interator 由于 Generator 函数是遍历器生成函数，因此 把它赋值给对象的 [Symbol.interator]属性，该对象就可以被遍历123456789let iter = &#123;&#125;;iter[Symbol.iterator] = function* ()&#123; yield 1; yield 2; yield 3;&#125;[...iter] //[1, 2, 3] next 参数 yield 本身的返回值为 undefined， 而 next方法可以带一个参数，当作上一个 yield的返回值 12345678910111213141516171819202122232425262728293031let g = fn(); g.next() //&#123;value:0,done:false&#125; g.next() //&#123;value:1,done:false&#125; g.next() //&#123;value:2,done:false&#125; g.next(1) //&#123;value:0,done:false&#125; function* fn ()&#123; for (let i = 0; true; i++)&#123; let reset = yield i; if(reset) i = -1; &#125; &#125;function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result';&#125;let genObj = dataConsumer();genObj.next();// Started//&#123;value: "undefined", done: fales&#125;genObj.next('a')//1. a//&#123;value: "undefined", done: fales&#125;genObj.next('b')//2. b//&#123;value: "result", done: true&#125; for…of 中使用 Generator 可以不用调用 next 方法 如果 返回对象 done属性值为 true， 循环终并且不包含该对象返回值；1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function* fn()&#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let i of fn())&#123; console.log(i); //1 2 3 4 5 undefined&#125;//斐波那契数列function* fibonacci() &#123; let [prev, curr] = [0, 1]; for (;;) &#123; yield curr; [prev,curr] = [curr, prev + curr]; &#125;&#125;for (let f of fibonacci()) &#123; if (f &gt; 1000) break; console.log(f)&#125;//遍历任意对象方法function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let key of propKeys)&#123; yield [key,obj[key]]; &#125;&#125;let person = &#123;name:'Owen', age:18&#125;;for (let [key,value] of Object.entries(person))&#123; console.log(key,value); //name Owen // age 18&#125;for (let [key,value] of objectEntries(person))&#123; console.log(key,value); //name Owen // age 18&#125;//或者person[Symbol.interator] = objectEntriesfor (let [key,value] of person)&#123; console.log(key,value); //name Owen // age 18&#125; Generator throw 在函数体外抛出错误，再在 函数体内捕获。throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。因为只有执行一次 next方法，函数才开始执行。 1234567891011121314151617181920212223function* g() &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部1',e ) &#125;; try &#123; yield; &#125; catch (e) &#123; console.log('内部2',e) &#125;; &#125;let t = g();t.next(); //&#123;value: undefined, done: false&#125;try&#123; t.throw('a'); t.throw('b'); t.throw('c');&#125; catch(e)&#123; console.log('外部',e)&#125;//内部1 a//内部2 b//外部 c Generator return 结束 Generator 函数 并且给定对象返回值如果有 try...finally，且在执行中，return方法会等待finally 执行完毕，再执行。12345678910111213141516171819202122232425262728293031function* g()&#123; yield 1; yield 2;&#125;let ge = g();ge.next(); // &#123; value: 1, done: false &#125;ge.return('Owen'); // &#123; value:"Owen", done: true &#125;ge.next() // &#123; value: undefined, done: true &#125;// try...finallyfunction* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var nun = numbers();nun.next() // &#123; value: 1, done: false &#125;nun.next() // &#123; value: 2, done: false &#125;nun.return(7) // &#123; value: 4, done: false &#125;nun.next() // &#123; value: 5, done: false &#125;nun.next() // &#123; value: 7, done: true &#125; next()、throw()、return() 都是让 Generator 恢复执行，并且使用不同语句替换 yield yield* Generator 函数默认不在内部调用另一个 Generator 函数 是没有效果的，如果放到 yield 后面 会返回一个遍历器对象yield* 后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个 for...of 循环。如果 yield* 后面紧跟数组，会遍历数组成员（数组原始支持遍历器）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//默认function* f()&#123; yield 1; yield 2;&#125;function* g()&#123; yield 'x'; f(); yield 'y';&#125;for(let key of g())&#123; console.log(key) //"x" "y"&#125;//yield*function* y()&#123; yield 'x'; yield* f(); yield 'y';&#125;for (let k of y()) &#123; console.log(k); // "x" "y" 1 2&#125;//无 returnfunction* concat(iter1, iter2) &#123; yield* iter1; yield* iter2;&#125;// 等同于function* concat(iter1, iter2) &#123; for (var value of iter1) &#123; yield value; &#125; for (var value of iter2) &#123; yield value; &#125;&#125;// yield* array 如果去掉 * 会返回整个数组//任何数据结构只要有 Iterator 接口，就可以被yield*遍历。function* gen()&#123; yield* ["a", "b", "c"];&#125;var g = gen();g.next() //&#123;value: "a", done: false&#125;g.next() //&#123;value: "b", done: false&#125;g.next() //&#123;value: "c", done: false&#125;g.next() //&#123;value: undefined, done: true&#125;//取出嵌套数组的所有成员function* iterTree(tree) &#123; if (Array.isArray(tree))&#123; for (let arr of tree) &#123; yield* iterTree(arr) &#125; &#125;else&#123; yield tree &#125;&#125;const tree = [1,[2,3],[4,[5,6],7],8];for (let v of iterTree(tree))&#123;console.log(v)&#125;//1 2 3 4 5 6 7 8[...iterTree(tree)] //[1, 2, 3, 4, 5, 6, 7, 8]//遍历完全二叉树// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 下面生成二叉树function make(array) &#123; // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123; result.push(node);&#125;result // ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 对象属性中的 Generator 函数1234567891011let obj = &#123; * generator()&#123; &#125;&#125;//orlet obj1 = &#123; generator :function* () &#123; &#125;&#125; Generator 函数的this Generator 函数不能和 new 一起使用 函数总返回一个遍历器，并且它指向 函数实例，同时继承 函数原型对象上的方法12345678910111213141516171819202122232425262728293031323334353637383940function* g() &#123; this.say = function()&#123; return 18 &#125;;&#125;g.prototype.say = function () &#123; return "Owen"&#125;let obj =g() //g &#123;&lt;suspended&gt;&#125;obj instanceof g //trueobj.say() //"Owen"obj.next() //&#123;value: undefined, done: true&#125;obj.say() //"Owen"//因为 next 返回的是遍历器对象而不是 this 对象,所以不会返回 18//通过call 绑定thisfunction* Gen()&#123; this.age = 18; yield this.name = "Owen";&#125;let obj = Gen.call(Gen.prototype);obj.next()obj.age // 18obj.next();obj.name //"Owen"// 使用 new 的变通方法function G()&#123; return Gen.call(Gen.prototype)&#125;let obj1 = new G();obj1.next()obj1.age // 18obj1.next();obj1.name //"Owen" Generator 函数异步应用 异步: 执行一个任务的时候还不能马上返回结果，那么先将其搁置到后台，执行其他任务，等到有结果返回之后放到消息队列中，等主线程任务执行完毕后，再从消息队列中取出对应任务（callback），执行。同步： 执行一个任务，中间无法中断，只能等待任务返回结果，才能执行其他任务。 异步编程： 回调函数123456$.ajax(&#123; url:&apos;url&apos;, success:function(res)&#123; console.log(res) &#125;&#125;) 事件监听 起初由网景公司知道一套事件驱动机制（事件捕获），之后IE 推出自己的驱动机制（事件冒泡）利用驱动机制实现事件代理委托12345678910111213141516el.addEventListener(event,function()&#123;&#125;,boolean);//IE8 以下el.attachEvent(event,function()&#123;&#125;)//事件代理委托var parent = document.getElementById('parent');parent.addEventListener('click',showColor,false); function showColor(e)&#123; var son = e.target; if(son.nodeName.toLowerCase() === 'li')&#123; console.log('The color is ' + son.innerHTML); &#125; &#125; 发布/订阅（观察者模式）123456789101112131415161718192021222324252627282930313233343536373839404142434445//实现一个简单的发布订阅/* 订阅一个事件，发布对应事件并且执行方法 需要先有代理主题 message proxy 然后订阅者去订阅 然后发布者发布消息执行方法 */ function PubSub () &#123;&#125;; // message proxy PubSub.prototype.message = &#123;&#125;; // publish PubSub.prototype.pub = function () &#123; // Turn arguments into real array let args = [].slice.call(arguments,0); let event = args.shift(); if(!this.message[event]) return this; let list = this.message[event]; for (let item of list) &#123; item.apply(this,args); &#125; return this; &#125; // subscribe PubSub.prototype.sub = function (event,callback)&#123; if( !this.message[event]) &#123; this.message[event] = []; &#125; this.message[event].push(callback); return this; &#125; // unsubscribe PubSub.prototype.unsub = function (event) &#123; if (!this.message[event]) return this; this.message[event] = null; &#125; Promise 对象 为了解决 “回调地狱”（callback hell）而提出的写法允许将 callback 变成链式调用12345678// read I/Olet readFile = require('fs-readfile-promise');readFile(fileA) .then( (data) =&gt; console.log(data.toString())) .then( () =&gt; readFile(fileB)) .then( (data) =&gt; console.log(data.toString())) .catch((err) =&gt; console.log(err)); Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 Generator 函数（es6）协程 多个线程相互协作，完成异步任务步骤 A方法开始任务 A方法执行到一半，暂停，将执行权转移到主线程 一段时间后主线程交还执行权 A方法恢复执行 12345678//examplefunction* async () &#123; //... do something let file = yield readFile(fileA); //... do something&#125;//异步操作需要暂停的地方，都用yield语句注明。 协程代码的写法非常像同步操作，Generator 函数最大优点是可以交出函数执行权 函数通过next 进行数据交换，通过 throw进行错误处理123456789101112function* async (num) &#123; let n; try&#123; n = yield ++num; &#125;catch(err)&#123; console.log(err) &#125; return n&#125;let g = async(1);g.next()g.throw('error'); 封装异步任务使用node-fetch 模块 返回一个Promise 对象123456789101112let fetch = require('node-fetch');let g = gen();let result = g.next();result.value.then((data) =&gt; data.json()) .then((data) =&gt; g.next(data) );function* gen() &#123; let url = '/index.json'; let result = yield fetch(url);&#125; Thunk (形实转换)函数传值策略 传值调用（参数在传入函数前计算）,简单易懂，不过可能会造成性能损失 传名调用（将参数放到一个临时函数，再将这个临时函数传入函数体（Thunk 函数)） 1234567891011//传值var x = 3;function fn (x,b) &#123; return x * 3 &#125;;fn(x + 1) // 4 * 3//传名fn(x + 1) // (x + 1) * 3 //等同于var thunk = function ()&#123; return x + 1&#125;fn (thunk) // thunk() * 3 async/await（es7)]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>async</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflect]]></title>
    <url>%2F2019%2F04%2F02%2FReflect%2F</url>
    <content type="text"><![CDATA[Reflect 将Object对象中一些属于语言内部的方法，放到 Reflect对象中会逐渐替换Object对象 中对应的方法优化一些放法返回的结果只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法,不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。 静态方法 13 个静态方法 作用对应Object同名方法 所有方法第一个参数，必须是对象，否则报错 Reflect.apply(target, thisArg, args) 等同于 Function 构造函数中的Function.prototype.apply.call(func, thisArg, args)1234567891011const ages = [11, 33, 12, 54, 18, 96];// ES5const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// Reflectconst youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []); Reflect.construct(target, args) 对应 new target(...args) 提供了一种不使用 new，来调用构造函数的方法。123456789function Greeting(name) &#123; this.name = name;&#125;// new 的写法const instance = new Greeting('Owen');// Reflect.construct 的写法const instance = Reflect.construct(Greeting, ['Owen']); Reflect.get(target, name, receiver) 查找目标对象属性值并返回1234567891011121314151617let obj = &#123; name : 'Owen', age:18, get baz()&#123; return this.name + this.age &#125;&#125;Reflect.get(obj,'name') //'Owen'Reflect.get(obj,'baz') //'Owen18'// receiver 改变 get 函数 this 指向let obj1 =&#123; name : 'Owen', age:16,&#125;Reflect.get(obj,'baz',obj1) //'Owen16 Reflect.set(target, name, value, receiver)123456789101112131415161718let obj = &#123; name : 'Owen', age:18, set baz(val)&#123; return this.age = val; &#125;&#125;Reflect.set(obj,'name','wen') obj.name //'wen'Reflect.set(obj,'baz', 16)obj.age // 16//receiver 改变 set this 指向let obj1 = &#123; name: 'wen'&#125;Reflect.set(obj,'baz', 16,obj1)obj.name // wen 如果 Proxy和 Reflect 联合使用，并且传入 receiver ， 那么 Reflect.set 会触发Proxy.defineProperty1234567891011121314151617181920212223let proxy = &#123; name:'Owen'&#125;let handler = &#123; set (target, key, value, receiver)&#123; console.log('set') Refelect.set(target, key, value, receiver) &#125;, defineProerty(target, key, attribute)&#123; console.log('defineProperty') Reflect.defineProperty(target, key, attribute) &#125;&#125;let obj = new Proxy(proxy,handler)obj.name = 'wen';// set// defineProperty/* 因为Proxy.set的receiver参数总是指向当前的 Proxy实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截。*/ Reflect.defineProperty(target, propertykey, attribute) 对应 Object.defineProperty12345678910111213function MyDate() &#123; /*…*/&#125;// es5Object.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;);// es6Reflect.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;); Reflect.deleteProperty(target, name) 对应 delete obj.name12345678let obj = &#123; name:'Owen'&#125;//es5 delete obj.name// ReflectReflect.deleteProperty(obj,'name') Reflect.has(target, name) 对应 name in obj 中的 in 运算12345678let obj = &#123; name:'Owen'&#125;//es5 'name' in obj // ture//ReflectReflect.has(obj,'name') //true Reflect.ownKeys(target) 对应 Object.getOwnPropertyNames and Object.getOwnPropertySymbols 返回对象所有属性1234567891011121314151617let obj = &#123; name:'Owen', age:18, [Symbol.for('name')]:'Owen', [Symbol.for('age')]:18&#125;//es5Object.getOwnPropertyNames(obj)// ['name', 'age']Object.getOwnPropertySymbols(obj)//[Symbol(name), Symbol(age)]//es6Reflect.ownKeys(obj)//['name', 'age',Symbol(name), Symbol(age)] Reflect.isExtensible(target) 对应 Object.isExtensible 返回 boolean，表示当前对象是否可扩展。123456const obj =&#123;&#125;//es5Object.isExtensible(obj) //true//es6Reflect.isExtensible(obj) //true Reflect.preventExtensions(target) 对应 Object.preventExtensions 让一个对象变为不可扩展。它返回 boolean，表示是否操作成功。123456const obj =&#123;&#125;// es5 Object.preventExtensions(obj) // Object &#123;&#125;// es6Reflect.preventExtensions(obj) // true Reflect.getOwnPropertyDescriptor(target, propertyKey) 对应 Object.getOwnPropertyDescriptors 返回对象所有自身属性（非继承） 的描述对象1234567891011var obj t = &#123;&#125;;Object.defineProperty(obj, 'hidden', &#123; value: true, enumerable: false,&#125;);// es5var theDescriptor = Object.getOwnPropertyDescriptor(obj, 'hidden');// es6theDescriptor = Reflect.getOwnPropertyDescriptor(obj, 'hidden'); Reflect.getPrototypeOf(target) 获取对象原型参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。1234567const myObj = new FancyThing();// es5 Object.getPrototypeOf(myObj) === FancyThing.prototype;// ReflectReflect.getPrototypeOf(myObj) === FancyThing.prototype; Reflect.setPrototypeOf(target, prototype) 对应Object.setPrototypeOf 设置 原型对象， 返回 Boolean 123456789101112const obj = &#123;&#125;;function Person ()&#123;&#125;//es5Object.setPrototypeOf(obj,Person.prototype);//es6 Reflect.setPrototypeOf(obj,Person.prototype);obj.length //0 Proxy Observer Mode 函数字段观察数据对象，如果数据改变，函数自动执行 1234567891011121314151617181920212223242526272829303132333435const queue = new Set();//队列函数const observe = callback =&gt; queue.add(callback);//观察目标const observable = obj =&gt; new Proxy(obj,&#123;set&#125;);//自动执行function set (target,key,value,receiver)&#123; const result = Reflect.set(target,key,value,receiver); queue.forEach(observer =&gt; observer() ); return result&#125;const person = observable(&#123; name:'Owen', age:18&#125;) function auto()&#123; console.log(`$&#123;person.name&#125;,$&#123;person.age&#125;`); &#125;observe(auto);person.name = 'Owen';/* 先定义一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。 */]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[proxy]]></title>
    <url>%2F2019%2F03%2F26%2Fproxy%2F</url>
    <content type="text"><![CDATA[Proxy 用于修改某些操作的默认行为。（对编程语言进行编程）在目标对象之前架设一层‘门户’，外界访问对象时，必须先访问这个门户，对外界的访问进行过滤和改写 生成: ES6中 所有proxy实例 通过 Proxy 构造函数生成12345678910 new Proxy(target,handler);// target对象 要访问的对象， handler对象 拦截行为var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35 Proxy 支持的操作get(target, propKey, proxy) 拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。12345678910111213141516171819202122/***get 接收三个参数*target 目标对象*property 属性名*proxy 实例本身**/var obj = &#123; name:"Owen"&#125;;var proxy = new Proxy(obj, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError("Property \"" + property + "\" does not exist."); &#125; &#125;&#125;);proxy.name // "Owen"proxy.age // error:Property "age" does not exist.//如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 set(target, propKey, value, proxy) 拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。12345678910111213141516171819202122232425262728293031/***set 有4 个参数*target 目标对象*property 属性名*value 属性值*proxy 实例本身 */ let validator = &#123; set: function(obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('The age is not an integer'); &#125; if (value &gt; 100) &#123; throw new RangeError('The age seems invalid'); &#125; &#125; // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; return true //严格模式下 return false or undefined 会报错 &#125;&#125;;let obj = new Proxy(&#123;&#125;, validator);obj.age = 18;obj.age ='18'; //errorobj.age =101;//error//每当对象发生变化时，会自动更新 DOM。 has(target, propKey) 拦截propKey in proxy的操作，返回一个布尔值。1234567891011121314151617/***接收两个参数*target目标对象*key 查询的属性名**/var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: 'Owen' &#125;;var proxy = new Proxy(target, handler);'_prop' in proxy // false//拦截以‘_’开头的属性名 对for ...in 遍历不生效 deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。1234567891011121314151617var handler = &#123; deleteProperty (target, key) &#123; invariant(key, 'delete'); delete target[key]; return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private "$&#123;key&#125;" property`); &#125;&#125;var target = &#123; _prop: 'foo' &#125;;var proxy = new Proxy(target, handler);delete proxy._prop// Error: Invalid attempt to delete private "_prop" property ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。123456789101112131415161718//拦截对象自身属性的读取操作let target = &#123; _bar: 'foo', _prop: 'bar', prop: 'Owen'&#125;;let handler = &#123; ownKeys (target) &#123; return Reflect.ownKeys(target).filter(key =&gt; key[0] !== '_'); &#125;&#125;;let proxy = new Proxy(target, handler);for (let key of Object.keys(proxy)) &#123; console.log(target[key]);&#125;//会自动过滤 不存在的属性，Symbol，不可遍历属性 getOwnPropertyDescriptor(target, propKey) 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。12345678910111213141516var handler = &#123; getOwnPropertyDescriptor (target, key) &#123; if (key[0] === '_') &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: 'bar', baz: 'tar' &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, 'wat')// undefinedObject.getOwnPropertyDescriptor(proxy, '_foo')// undefinedObject.getOwnPropertyDescriptor(proxy, 'baz')// &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125; defineProperty(target, propKey, propDesc) 拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。12345678var handler = &#123; defineProperty (target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.owen = 'Owen' // 不会生效 preventExtensions(target) 拦截Object.preventExtensions(proxy)，返回一个布尔值。该方法必须返回一个布尔值，否则会被自动转为布尔值。目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true12345678var proxy = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125;&#125;);Object.preventExtensions(proxy)//error getPrototypeOf(target) 拦截Object.getPrototypeOf(proxy)，返回一个对象。12345678910111213141516//主要拦截获取对象原型/** *Object.prototype.__proto__*Object.prototype.isPrototypeOf()*Object.getPrototypeOf()*Reflect.getPrototypeOf()*instanceof**/var proto = &#123;&#125;;var p = new Proxy(&#123;&#125;, &#123; getPrototypeOf(target) &#123; return proto; &#125;&#125;);Object.getPrototypeOf(p) === proto // true//返回值必须是对象或者null，否则报错 isExtensible(target) 拦截Object.isExtensible(proxy)，返回一个布尔值。123456789var p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; console.log("Owen"); return true; &#125;&#125;);Object.isExtensible(p)//返回值必须是Boolean setPrototypeOf(target, proto) 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。12345678910var handler = &#123; setPrototypeOf (target, proto) &#123; throw new Error('Changing the prototype is forbidden'); &#125;&#125;;var proto = &#123;&#125;;var target = function () &#123;&#125;;var proxy = new Proxy(target, handler);Object.setPrototypeOf(proxy, proto);// Error: Changing the prototype is forbidden apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。1234567891011121314151617/***接收三个参数 *target 目标对象*this 目标对象上下文*目标对象的参数数组*/var target = function () &#123; return 'I am the target'; &#125;;var handler = &#123; apply: function () &#123; return 'I am the proxy'; &#125;&#125;;var p = new Proxy(target, handler);p()// "I am the proxy" construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。123456789101112131415//接收两个参数/***target 目标对象*args 构造函数参数对象函数必须返回对象，否则会报错 */ let obj = &#123; construct: function(target, args) &#123; console.log('Owen: ' + args.join(', ')); return &#123; value: args[0] * 10 &#125;; // retirn '18'; error &#125; &#125; var p = new Proxy(function () &#123;&#125;, obj) new p(2).value // 20 Proxy.revocable Proxy.revocable方法返回一个可取消的 Proxy 实例。使用场景： 目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。1234567891011121314let target = &#123;&#125;let handler = &#123;&#125;let &#123;proxy, revoke&#125; = Proxy.revocable(target,handler);/* Proxy.revocable(target, handler);&#123;proxy: Proxy, revoke: ƒ&#125;*/proxy.name = 'Owen'proxy.namerevoke() //取消 proxy 实例proxy.name //error Proxy this 在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 123456 const target = new Date();const handler = &#123;&#125;;const proxy = new Proxy(target, handler);proxy.getDate();//error Proxy 实例使用123456789101112131415const service = createWebService('http://example.com/data');service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ···&#125;);function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl+'/' + propKey); &#125; &#125;);&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Extend]]></title>
    <url>%2F2019%2F03%2F19%2Fextend%2F</url>
    <content type="text"><![CDATA[String Extend被 for ... of 遍历1234567for (let val of 'abc')&#123; console.log(val); //a //b //c&#125; 查找字符12345678910let str = 'Hello Brother!';//includes 是否包含参数字符串str.includes('Br'); //true//startsWith 开头是否存在参数字符串str.startsWith('Hello') //true//endsWith 结尾是否存在参数字符串str.endsWith('er!')//true 重复字符12345678910//repeat 重复 n 次， n 为参数,返回新字符串let re = 'Hello Brother!';re.repeat(2); //"Hello Brother!Hello Brother!"re.repeat(-2); // Invalid count valuere.repeat(Infinity); // Invalid count value//小数会取整 re.repeat(1.9) // "Hello Brother!"re.repeat(-0.9) // "" 补全字符1234567891011121314//补全开头 padStart 补齐尾部 padEndlet pd = 'Brother!'; pd.padStart(14,'Hello '); //"Hello Brother!"//第一个参数为补齐的最大长度（整串字符） 第二个参数为补齐缺省的字符串//如果原始字符长度大于等于最大长度，返回原字符串pd.padStart(7,'Hello ')// 'Brother!'pd.padStart(8,'Hello ')// 'Brother!'//如果最大长度小于补齐长度，则去除超出部分pd.padStart(9,'Aay ')//'ABrother!'//如果缺省第二个参数则 默认使用空格补齐pd.padStart(9)//' Brother!' 模板字符 通过反引号 “ ” 当普通字符串使用1234567891011121314//所有换行和空格会保留，嵌入变量，须将变量包含在 `$&#123;&#125;` 中，并且可进行运算,函数调用，对象调用let num =1,obj =&#123;name:'Owen'&#125;, fn=()=&gt; 3;const str =` $&#123;num * 3 + 1 + fn() + obj.name&#125;`;console.log(str)/* " 7Owen"*///如果紧更在函数名后，函数将被调用（标签模板）alert`123` // 等同于alert(123) 转义符 \12345678//以 x 开头,会被当做 16 进制 `\x23` // # //以 u 开头,会被当做 unicode 字符 `\u004F` //"O"//如果无法编译将会报错 ES2018 放松了对标签模板里面的字符串转义的限制，无法转义的返回undefined； 123console.log`\uw`;//[undefined, raw: Array(1)]//undefined Function Extend形参指定默认值 形参 不能再次使用 let 和 const 声明形参不能重名函数 length 不包含设置默认值和后面的形参个数使用 ...arg 中的参数 length 也不包含 12345678910111213const fn = (x, y = 'Owen') =&gt;( console.log(x,y));fn(1) // 1 "Owen"//默认参数 惰性求值let x = 99;function foo(y = x + 1) &#123; console.log(y);&#125;foo() // 100x = 100;foo() // 101//调用一次计算一次 事实上 每次调用函数，如果不传递参数， 形参默认传递 undefined 12345678910111213 // 默认参数最好定义再尾部，因为使用形参默认参数，那么那个位置的形参必传function f(x, y = 5, z， ...arg) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2]//length 不包含设置默认值 和后面的形参 的个数，f().length // 1 作用域 函数中的变量无法访问 默认值函数中的形参名不能和默认名一样123456789101112131415161718192021222324//函数变量无法访问默认值function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // ReferenceError: x is not defined//函数中的形参名不能和默认名一样//参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错function f(x = x) &#123; console.log(x);&#125;f()// x is not definedvar x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 由于 var 声明的 x 和函数形参 x 不再同一个作用域 ， 因此调用 y() x值不变；如果 去掉 var , 那么 x 就指向 形参 x ,调用 y() x = 2。 reset 参数 （…） 使用形式 ...arg 实数以数组的形势赋给变量reset 参数后不能再有形参，否则报错123456789function fn (a,...arg)&#123; return arg;&#125;fn(0,2,3,4,5)//[2,3,4,5]function foo (a,...arg,b)&#123; return arg;&#125;//ught SyntaxError: Rest parameter must be last formal parameter 只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425// 报错function f(a, b = a) &#123; 'use strict'; // code&#125;// 报错const foo = function (&#123;a, b&#125;) &#123; 'use strict'; // code&#125;;// 报错const fn = (...a) =&gt; &#123; 'use strict'; // code&#125;;const obj = &#123; // 报错 fn(&#123;a, b&#125;) &#123; 'use strict'; // code &#125;&#125;;#### 箭头函数&gt;使用 () =&gt; 定义函数注意：- this 指向函数定义时所绑定的普通函数，不会被(bind,call,apply)更改,也不会被调用时的上下文改变。1234567891011121314151617181920212223let fn = () =&gt;console.log(this);let obj = &#123;name:"Owen"&#125;;fn.call(obj) //windowfn.bind(obj)fn() //windowfn.apply(obj) //window //可以通过改变宿主环境来改变 this 指向 function foo ()&#123; return () =&gt;&#123; console.log(this); return ()=&gt; &#123;console.log(this)&#125;; &#125;&#125;foo.call(obj)() //&#123;name: "Owen"&#125;foo.call(obj)()() //&#123;name: "Owen"&#125; &#123;name: "Owen"&#125;- 外层没有普通函数 ，严格模式和非严格模式下它的this都会指向window(全局对象)。- 不可以当作构造函数，也就是说，不可以使用new命令，没有prototype属性，不支持new.target,否则会抛出一个错误。- 参数和箭头之间不能换行- 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。- 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。123456789101112131415161718192021222324//定义简单函数let fn = () =&gt; 'Owen';fn()// 'Owen'let foo = r =&gt; r;foo('Owen') // 'Owen'let f = (num1,num2) =&gt; num1 + num2;f(1,2)//3//如果返回一个对象需要小括号包裹,f否则会报错let f = (name,age) =&gt; (&#123;name,age&#125;);f('Owen',18)//&#123;name: "Owen", age: 18&#125;//如果代码部分大于一条语句，那么需要 大括号包裹，使用return 返回值let fn1 = r =&gt; &#123; let a = 1; console.log(a); return r + a;&#125;#### 不推荐使用场景- 在对象中使用 this.123456var obj = &#123; gender:"man", getSex: () =&gt; &#123;console.log(this.gender)&#125;&#125;obj.getSex() //undefined//this -&gt; global- 动态使用 this.12345var lis = document.querySelector('li');lis.addEventListener('click',() =&gt; &#123; console.log(this)&#125;)// this -&gt; global- 内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数#### 双冒号运算符 ::&gt; 目前只是一个提案，用来绑定函数的 this 类似于 (bind,call,apply)&gt; 将做边的对象作为参数，绑定到右边函数上。1234567bar:: fn//等同于fn.bind(bar);bar::fn(...arguments);//等同于fn.apply(bar, arguments);#### 函数调用12345678 function f()&#123; foo()&#125; function foo()&#123; fn()&#125;function fn()&#123;&#125;f()&gt; 函数调用会在内存中形成一个 调用记录（调用帧），保存着调用位置和内部变量等信息。&gt; 函数 f内部调用 foo函数，f调用帧的上方会形成 foo的调用帧， foo运行接受并且将结果返回给 f，foo的调用帧才会消失，同理，foo函数 内部调用fn函数，还会有 fn 的调用帧，以此类推，形成一个调用栈。#### 尾调用&gt; 指某个函数的最后一步是调用另一个函数。&gt; 不一定出现在函数尾部，只要是最后一步操作即可。123456789101112131415161718192021222324252627//尾调用function f(x)&#123; return fn(x);&#125;//不属于尾调用// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; //等同于function f(x)&#123; g(x); return undefined;&#125;——### Array Extend#### 扩展运算 (…)&gt;主要用于函数调用， 将一个数组，变为参数序列。12345function add(x, y) &#123; return x + y;&#125;add(... [1,2]) // 3##### clone数组 123456789 //es5 let arr = [1,2];let arr1 = arr.concat(); //es6let [...arr2] = arr;let arr3 = [...arr];##### 合并数组1234567let arr = [1,2];let arr1 = [3,4];let arr2 = [5,6];//es5let arr3 = arr.concat(arr1,arr2);//es6let arr4 = [...arr,...arr1,...arr2];合并和clone 都是浅拷贝；##### 配合解构赋值1234567891011121314151617const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = ["foo"];first // "foo"rest // []//扩展运算符，只能放在参数的最后一位，否则会报错。const [first, ...middle, last] = [1, 2, 3, 4, 5];//error##### 将伪数组(内部实现了Iterator)转化伪数组1234567891011121314151617//内部实现Iterator//字符串， Set, Map, Generator, NodeList, htmlcollection, classList ,argument内部都实现了迭代接口let nodes = document.querySelectorAll('div');let divs = [...nodes];//内部未实现Iteratorlet objs = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr =[...objs];//error//可通过 Array.from方法转化let arr1 = Array.from(objs)#### Array.from&gt; 将伪数组转化为数组123456789101112131415161718192021222324252627let arrLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr = Array.from(arrLike)/*第二个参数 遍历每个元素并返回运算结果*/Array.from(arrLike, x =&gt; x * x);// 等同于Array.from(arrLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9]//将布尔值为false的成员转为0Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3]//获取DOM 节点的文本内容。Array.from(document.querySelectorAll('span.name');, s =&gt; s.textContent)//第三个参数 绑定第二个参数中回调函数的this#### find and findIndex&gt; 回调函数遍历所有成员，返回符合条件的值， 没有则返回 undefined&gt; find 返回值为，第一个符合条件的成员&gt;findIndex ，没有则返回 -1&gt; 回调函数接受三个参数（成员，位置，原数组）&gt; 第二个参数 绑定回调函数 this&gt; 可以识别NaN1234567[1, 4, -5, 10].find(function(v,i,arr)&#123; return v&lt;0;&#125;)// -5[1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0)// 2#### fill&gt; 填充数组,修改原数组&gt; 第一个参数为填充值，第二个参数为开始填充的位置，第三个参数为结束位置12345let arr =[1,2,3];arr.fill('Owen');//["Owen","Owen","Owen"]arr.fill(1,0,2);//[1,1,3]#### Interator&gt; keys,values,entries 对应属性遍历123456789101112131415161718// keyslet arr = ['o','w','e','n'];for (let key of arr.keys())&#123; console.log(key); //0 1 2 3&#125;for (let item of arr.values())&#123; console.log(item); //o w e n&#125;for (let [i,item] of arr.entries())&#123; console.log(i,item)//1 "w"//2 "e"//3 "n"&#125;#### includes&gt; 返回一个Boolean ,数组是否包含给定的值1234567891011[1,2,3,4].includes(3)//true//第二个参数为搜索的起始位置[1,2,3,4].includes(3,4)//false/* 是否支持 */const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false#### flat ,flatMap&gt; 将二维数组变成一位数组，并返回新数组12345678910[1,2,[3,4]].flat()//[1,2,3,4]//默认拉平1层[1,2,[3,[4]]].flat(2)//[1,2,3,4]//将所有维度变成一维array.flat(Infinty)//会忽略空位[1,,[3,4]].flat()//[1,3,4]—#### ES5 interator methods##### every- 访问每一个成员,给定某个条件，如果所有成员满足条件就返回true123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.every(function(item,key,array)&#123; return ( item&gt;2 )&#125;) n //false#### some- 访问每一个成员,给定某个条件，只要有一个成员满足条件就返回true- 有一个满足条件的成员之后的不再执行123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.some(function(item,key,array)&#123; return ( item &gt; 2 )&#125;) n //true##### filter- 访问每一个成员,给定某个条件，将满足条件的成员组成数组返回， 否则返回 []- 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用 123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.filter(function(item,key,array)&#123; return ( item &gt; 2 )&#125;) n //[3, 4, 5, 4, 3] map 访问每一个成员,将每次访问执行的结果组成数组返回，也就是说每个成员都 必须要有return返回结果，否则都是unndefined map不支持continue跳出循环 123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.map(function(item,key,array)&#123; return item * 2&#125;) n // [0, 2, 4, 4, 6, 8, 10, 6, 10] forEach 访问每一个成员,没有返回值 中途不能用常规操作跳出循环 不支持链式操作123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.map(function(item,key,array)&#123; return item * 2&#125;) n // undefined reduce and reduceRight reduce 从数组的第一项开始，逐个遍历到最后。 reduceRight 从数组的最后一项开始，向前遍历到第一项。 接收两个参数 回调函数和 回调函数第一个参数的值，默认数组第一个元素。 返回 累计处理的结果 12345678910111213141516171819 /** * @param * prev 上次调用回调时的累积值 * cur 当前数组成员 * i 数组索引 * arrary 原数组 * */var num = [0,1,2,2,3,4,5,3,5];var n = num.reduce(function(prev,cur,i,array)&#123; return prev*2 + cur&#125;) n // 431 var num = [0,1,2,2,3,4,5,3,5];var n = num.reduce(function(prev,cur,i,array) &#123; return prev*2 + cur&#125;) n // 2186 以上都不会修改原数组，除非使用第三个参数做些操作，注意数组成员是值类型，还是引用类型 sort 对数组排序 默认排序按字母升序（根据字符串Unicode ） 参数为回调函数callback(a,b) 返回值为负数 那么 a 会被排列到 b 之前 返回值为 0 位置不变 返回值为正数 b 会被排列到 a 之前12345var num = [1,3,2,7,44,2,3,4,9];num.sort(function(a,b)&#123; return a-b&#125;)num // [1, 2, 2, 3, 3, 4, 7, 9, 44] reverse 翻转数组123var num = [1,3,2,7,44,2,3,4,9];num //[9, 4, 3, 2, 44, 7, 2, 3, 1]num.reverse() 数组去重 has方法 会发生隐式转化 1 ==’1’ 123456789101112131415161718192021222324252627282930 var arr = [2,3,4,2,3,5,6,4,3,2];var unique = function(arr) &#123; var obj = &#123;&#125;; var res = []; arr.forEach(function(item,i)&#123; if(!obj[item])&#123; obj[item] = true; res.push(item) &#125; &#125;) return res&#125;unique(arr)&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD=======- map has方法 不会发生隐式转化var unique = function(arr) &#123; var m = new Map(); var res = []; arr.forEach(function(item,i)&#123; if(!m.has(item))&#123; res.push(item) &#125; m.set(item,2); &#125;) return res&#125;unique(arr)&gt;&gt;&gt;&gt;&gt;&gt;&gt; d71c39e5118389885ef986735a9a15598115e5b9 filter 1234567891011121314151617//会忽略 undefinedvar arr = [null,null,null,undefined,undefined,'','',1,1,1];var unique = function (arr) &#123; return arr.sort().filter(function(item,i,array) &#123; return item !== array[i+1]; &#125;)&#125; unique(arr) // ["", 1, null]var unique = function(arr) &#123; return arr.filter( function(item, idx ) &#123; return arr.indexOf(item) === idx; &#125;)&#125;unique(arr) //[null, undefined, "", 1] Object extend对象中的简写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//函数const obj =&#123; methode()&#123; return 'Owen' &#125;, * m() &#123; yield 'hello world'; &#125;&#125;//等同于const obj =&#123; methode:function()&#123; return 'Owen' &#125; m:function* ()&#123; yield 'hello world'; &#125;&#125;//使用变量定义对象 //默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。let lastWord = 'last word';const obj = &#123; 'first word': 'hello', [lastWord]: 'world', ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj['first word'] // "hello"obj[lastWord] // "world"obj['last word'] // "world"obj.hello() // hi//对象中 函数 name属性//对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。const key1 = Symbol('description');const key2 = Symbol();let obj = &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;, sayName() &#123; console.log('Owen'); &#125;, get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;obj[key1].name // "[description]"obj[key2].name // ""obj.sayName.name // "sayName"const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');descriptor.get.name // "get foo"descriptor.set.name // "set foo"//通过构造函数创立的函数(new Function()).name // "anonymous"//通过 bind 绑定的函数var doSomething = function() &#123; // ...&#125;;doSomething.bind().name // "bound doSomething" 枚举和遍历 Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象 12345678910let obj = &#123; name:'Owen'&#125;Objct.getOwnPropertyDescriptor(obj,'name');// &#123;// value: Owen,// writable: true,// enumerable: true, //可枚举// configurable: true// &#125; 如果 enumerable 为 false有些操作会忽略，当前属性 for…in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 (ES6) Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 共有 5 种方法可以遍历对象的属性。 for…in for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。 super this 总是指向函数所在的当前对象super 指向当前对象的原型对象。super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。12345678910111213const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // "hello" 对象扩展运算符 ES2018 将这个运算符引入了对象。解构赋值的拷贝是浅拷贝不能复制继承自原型对象的属性。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 解构//必须保证右方为对象，否则报错let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125;//与函数参数扩展运算类似，解构赋值须最后一个参数let &#123; ...x, y, z &#125; = someObject; // 句法错误let &#123; x, ...y, ...z &#125; = someObject; // 句法错误//无法继承原型let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2.__proto__ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined//扩展运算//数组是特殊的对象，所以对象的扩展运算符也可以用于数组let foo = &#123; ...['a', 'b', 'c'] &#125;;foo// &#123;0: "a", 1: "b", 2: "c"&#125;//扩展运算符后面是一个空对象，无效果&#123;...&#123;&#125;, a: 1&#125;// &#123; a: 1 &#125;//扩展运算符后面不是对象，则会自动将其转为对象 &#123;...1&#125; // &#123;&#125;//扩展运算符后面是字符串，它会自动转成一个类似数组的对象&#123;...'Owen'&#125;//&#123;0: "O", 1: "w", 2: "e", 3: "n"&#125;let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b);//完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。// 写法一 非浏览器环境不一定部署 __proto__const clone1 = &#123; __proto__: Object.getPrototypeOf(obj), ...obj&#125;;// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj);// 写法三const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj))//对象的扩展运算符后面可以跟表达式const obj = &#123; ...(x &gt; 1 ? &#123;a: 1&#125; : &#123;&#125;), b: 2,&#125;;//扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行let aWithXGetter = &#123; ...a, get x() &#123; throw new Error('not throw yet'); &#125;&#125;;// 会抛出错误，因为 x 属性被执行了let runtimeError = &#123; ...a, ...&#123; get x() &#123; throw new Error('throw now'); &#125; &#125;&#125;; New method for objectsObject.is() 比较两个值是否严格相等 和 === 的区别12345678910111213141516171819+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // truees5 实现Object.defineProperty(Object,'is',&#123; value: function(x, y) &#123; if (x === y) &#123; // 针对+0 不等于 -0的情况 return x !== 0 || 1 / x === 1 / y; &#125; // 针对NaN的情况 return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;) Object.assign() 浅拷贝对象，无法拷贝原型,也不拷贝不可枚举的属性。总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。同属性后面的覆盖前面的值 12345678Object.assign(&#123;b: 'c'&#125;, Object.defineProperty(&#123;&#125;, 'invisible', &#123; enumerable: false, value: 'hello' &#125;) )// &#123; b: 'c' &#125;Object.assign([1, 2, 3], [4, 5])//[4,5,3] Object.getOwnPropertyDescriptors() 返回目标对象所有自身属性（非继承） 的描述对象12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return 'Owen' &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; 主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。1234567891011121314151617const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target = &#123;&#125;;const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source));shallowMerge(target,source)Object.getOwnPropertyDescriptor(target, 'foo')// &#123; get: undefined,// set: [Function: set foo],// enumerable: true,// configurable: true &#125; 配合Object.create()方法，将对象属性克隆到一个新对象1234const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); 实现一个对象继承另一个对象。123456789101112131415//一const obj1 = Object.create(prot);obj.foo = 123;//二const obj2 = Object.assign( Object.create(prot), &#123; foo: 123, &#125;//三const obj3 = Object.create(prot,Object.getOwnPropertyDescriptors(&#123; name:'Owen'&#125;))); 实现Mixin1234567891011121314let mix = (obj) =&gt; ( &#123; with:(...mixins) =&gt; mixins.reduce( (c,mixin) =&gt; Object.create( c, Object.getOwePropertyDescriptors( minxin )), obj ) &#125;)let a = &#123;a: 'a'&#125;;let b = &#123;b: 'b'&#125;;let c = &#123;c: 'c'&#125;;let d = mix(c).with(a, b);d.c // "c"d.b // "b"d.a // "a" proto属性，Object.setPrototypeOf()，Object.getPrototypeOf() 设置，和 获取原型12345678910111213141516171819202122232425//setlet proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40//getfunction Rectangle() &#123; // ...&#125;const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false Object.keys()，Object.values()，Object.entries()1234567891011//keyslet obj = &#123; foo: 'bar', baz: 42 &#125;; //es5Object.keys(obj)// ["foo", "baz"]//valuesObject.values(obj)//['bar,42]Object.entries(obj)// [['foo', 'bar'], ['baz', 42]] Object.fromEntries() Object.entries 方法的逆操作12345Object.fromEntries([ ['foo', 'bar'], ['baz', 42]])// &#123; foo: "bar", baz: 42 &#125; 目前谷歌版本 Chrome/72.0.3626.121 Safari/537.36 及以下不支持]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Extend Methods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map]]></title>
    <url>%2F2019%2F03%2F19%2Fmap%2F</url>
    <content type="text"><![CDATA[Map 键值对的集合 键名的范围不限制于字符串 1234567891011121314151617const m = new Map();const obj = &#123;name: 'Owen'&#125;;const fn = function()&#123;&#125;;//设值m.set(obj,"boy"); //将 obj 作为键名， 给它赋值//可以是对象，数组，甚至是函数，任何数据类型都可以当作属性名（键名）m.set(fn,1) //对同一个键名赋值，后面的将覆盖前面的//获值m.get(obj) // 'boy'//查询m.has(obj) // true//删除m.delete(obj)//true Map 参数 任何 Iterator 接口，并且每个成员都是双元素数组的数据结构 都可以作为参数123456789101112131415161718192021222324252627282930313233343536373839let arr = [[1,2],[2,3]];const ma = new Map(arr); //Map(2) &#123;1 =&gt; 2, 2 =&gt; 3&#125;ma.get(1) //2ma.get(2) //3//如果几组双元素成员相同那么只会生成一个值arr = [[1,2],[1,2]];mss = new Map(arr); //Map(1) &#123;1 =&gt; 2&#125;ma.size//2mss.size//1// keys 键名for (let key of ma.keys())&#123; console.log(key) //1 //2&#125;//values 值for (let val of ma.values())&#123; console.log(val) //2 //3&#125;//entries 键值 等同于 遍历 ma 默认遍历的是entries for (let [key,val] of ma.entries())&#123; console.log(key,val) //1,2 //2,3&#125;//转化为数组[... ma.keys() ] //[1,2][... ma.values() ] //[2,3][... ma] //[[1,2],[2,3]]]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set]]></title>
    <url>%2F2019%2F03%2F15%2Fset%2F</url>
    <content type="text"><![CDATA[Set ES6 提供的数据结构类似于数组，值是唯一的，通过 Set 构造函数来生成 1234567891011const arr = [1,2,2,3,4,5,3,2,3,4,5];//参数可以是一个可以迭代的数据结构const set = new Set(arr); //Set(5)&#123;1,2,3,4,5&#125;[...set] //[1,2,3,4,5]const set1 = new Set('12343333433225'); //Set(5) &#123;"1", "2", "3", "4", "5"&#125;set1.size //5//数组去重const arr1 = [... new Set([1,2,3,4,3,3,3,3])];const arr2 = Array.from(new Set([1,2,3,4,3,3,3,3])); 属性和方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//属性const s = new Set() s.constructor //指向 Set 函数 s.size //成员总数/** * 操作方法 *///也可以通过 add()方法添加 只有一个参数const set2 =new Set();set2.add(1) //Set(1) &#123;1&#125;//不会发生类型转换 NaN 会 = NaN set2.add("1") //Set(2) &#123;1,"1"&#125;set2.add(NaN).add(NaN)// Set(3) &#123;1,"1",NaN&#125; 链式调用//两个对象不相等set2.add(&#123;&#125;)set2.size //4set2.add(&#123;&#125;)set2.size //5//通过 delete() 删除某个值 返回 Boolean 值 set2.delete(1) //trueset2.delete(&#123;&#125;) //false //has() 是否存在某个值 set2.has(NaN) //trueset2.has(&#123;&#125;) // false//clear() 清除所有成员set2.clear() //Set(0) &#123;&#125;/** * 遍历方法 *//** * keys 返回键名的迭代器， values 返回 键值的迭代器， 由于 Set 键名和键值 相同 所以 * keys 和 values 方法返回值相同 */ const sK = new Set([1,2,3,4,5]).keys() //SetIterator &#123;1, 2, 3, 4, 5&#125; const sV= new Set([1,2,3,4,5]).values() //SetIterator &#123;1, 2, 3, 4, 5&#125; //enters 返回键值对 for (let item of new Set([1,2,3,4,5]).entries()) &#123; console.log(item);&#125;// [1, 1]// [2, 2]// [3, 3]// [4, 4]// [5, 5]//推荐使用for of const sI = new Set([1,2,3,4,5]);for (let key of sI) &#123; console.log(key); //1 2 3 4 5&#125;// Set的遍历顺序就是插入顺序。使用 Set 保存一个回调函数列表，调用时能保证按照添加顺序调用。//forEachsI.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 2 : 2// 3 : 3// 4 : 4// 5 : 5 weakSet 和Set 类似 但是只能存储对象，不可遍历如果其他对象未应用该对象，垃圾回收机制会自动收回所占用的内存适合存储临时对象和绑定对应对象的信息 12345678910const ws = new WeakSet([[1, 2], [3, 4]]); //WeakSet &#123;[1, 2], [3, 4]&#125;//a 的成员自动成为 weakSet 的成员//add 方法let arr =[[1]];ws.add(arr);//delete 删除对应成员ws.delete(arr); //true// has 是否包含ws.has(arr) //false 由于 WeakSet 的成员都是弱引用随时可能被回收，因此可以存储DOM节点，不用担心节点移除时，发生内存泄漏。 1234567891011const foo = new WeakSet() class Foo &#123; constructor()&#123; foo.add(this) &#125; method ()&#123; if(!foo.has (this))&#123; throw new TypeError("method 只能在Foo 实例上使用"); &#125; &#125; &#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[symbol]]></title>
    <url>%2F2019%2F03%2F15%2Fsymbol%2F</url>
    <content type="text"><![CDATA[含义 ES6 引入的原始数据类型，表示独一无二的值通过 Symbol函数生成的原始值，不是对象，所以无法添加属性和方法1234567891011121314151617let s = Symbol();let s1 = new Symbol('s'); //TypeError// 不能通过 new Symbol 否则会报错s.toString()//"Symbol()"let s2 = Symbol();s == s2 // false//独一无二的特性Boolean(s) //true!s // falses + s1 //error s + 1 //error s + "1" // error //symbol 不能参与任何值的运算 对象中的 symbol 无法通过 . 点运算访问123456let sm = Symbol()const s =&#123; [sm]: 1&#125;;s.sm //undefineds[sm]//1 消除魔术字符串 代码中多次出现，与代码形成强耦合的某一个具体的字符串或者数值。123456789101112131415161718192021222324252627282930313233function getDate(num,options)&#123; let data = 1; switch (num)&#123; case 1: data = num + 1; break case 2 : data = num * 2; break &#125; return data&#125;// case 右边的 1， 2 就是魔术数值//一般把魔术字符串 变成变量来消除let obj =&#123; one:Symbol(), two:Symbol()&#125;function getDate(num,options)&#123; let data = 1; switch (num)&#123; case obj.one: data = options + 2; break case obj.two : data = options * 2; break &#125; return data&#125;getDate(obj.one,3) 作为对象属性名 for...in、for...of，Object.keys() , Object.getOwnPropertyNames(),JSON.stringify()返回。 不是私有属性，可以通过 Object.getOwnPropertySymbols()获取指定symbol名123456789let a = Symbol('a');let b = Symbol('b');const obj = &#123; a:1, [a]:'hello', [b]:'word'&#125;console.log(Object.getOwnPropertySymbols(obj)) //(2) [Symbol(a), Symbol(b)] -可以通过 Reflect.ownKeys() 返回所有类型的属性名12345678let a = Symbol('a');let b = Symbol('b');const obj = &#123; a:1, [a]:'hello', [b]:'word'&#125;Reflect.ownKeys(obj) // ["a", Symbol(a), Symbol(b)] Symbol.for()与Symbol() Symbol(‘a’) 和 Symbol.for():两种方法都会生成新的 Symbol 值Symbol(‘a’) 使用10次，会生成10个新的 SymbolSymbol.for(‘a’)，使用10次，会生成一个 Symbol 并创建一个key值Symbol.keyFor(Symbol.for(‘a’)),会返回一个全局 key 值，可以在不同的iframe 或 service worker 获取同一个key 1234567let s = Symbol('a');let s1 = Symbol.for('s');let s2 = Symbol.for('s');s == s1 //falses1 == s2 //truelet key = Symbol.keyFor(s2) //s]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Async/await]]></title>
    <url>%2F2019%2F03%2F14%2FasyncEs8%2F</url>
    <content type="text"><![CDATA[ES2017引入async 函数 Generator 的语法糖 1234567891011121314151617181920212223242526272829//generatorconst fs = require('fs');const readFile = function (path) &#123; return new Promise(function (resolve,reject) &#123; fs.readFile(path, function(err,data) &#123; if (err) return reject(err); resolve(data); &#125;); &#125;);&#125;;const g = function* () &#123; const f1 = yield readFile(url1); const f2 = yield readFile(url2);&#125;// asyncconst asyncFile = async function () &#123; const f1 = await readFile(url1); const f2 = await readFile(url2);&#125;/** * 将 g 函数的 * 变成 axync * 将 yield 变成 await */ async 对 generator 进行以下优化 不再需要调用 next 方法就能执行 更加语义化 实用性更强 await 后面可以是 Promise , 原始类型值（会自动转成立即 resolved 的 Promise 对象） 返回值为Promise 对象更加方便，当函数执行遇到 await 时暂停执行，等到异步操作完成，再执行后面的代码 async 函数 return 的返回值会成为 then 方法的参数 async 函数内部抛出错误 将会被 catch方法接收 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// examplefunction timeout(ms) &#123; return new Promise(resolve =&gt; setTimeout(resolve,ms))&#125;async function asyncPrint(val, ms ) &#123; await timeout(ms); console.log(val)&#125;asyncPrint('Owen',1000) //1s 后 "Owen"//因为 asnyc 返回 Promise 所以可以改用 asyncasync function timout(ms) &#123; await new Promise(resolve =&gt; setTimeout(resolve,ms));&#125;async function asyncPrint(val, ms ) &#123; await timeout(ms); console.log(val)&#125;asyncPrint('Owen',1000) //1s 后 "Owen"/* 定义 async 函数 *///声明async function f()&#123;&#125;//表达式const fn = async function () &#123;&#125;;// 对象const obj = &#123; async f()&#123;&#125;&#125;// class class Storage &#123; async getAvatar(name) &#123; &#125;&#125;//箭头函数const foo = async () =&gt; &#123;&#125;;/* then方法接收return 的参数 */async function foo ()&#123; return "Owen"&#125;foo().then(re =&gt;console.log(re)); //Owen/* 接收错误对象 */async function fn ()&#123; throw new Error(18)&#125;fn().catch(er =&gt;console.log(er)) //error asyn回调只有等所有 await 后面的Promise 执行完毕或者报错和return才会执行。 123456789101112async function fn() &#123; var time = + new Date() console.log(time,1) let p1 = await new Promise(resolve =&gt; setTimeout(resolve,1000)); console.log(+ new Date() - time ,2) let p2 = await new Promise(resolve =&gt; setTimeout(resolve,2000)); return +new Date() - time;&#125;fn().then(time =&gt; console.log(time,3));// 1s 1// 2s 2// 3s 3 await await 后面是 thenable 对象，会和返回 promise 对象 一样返回结果 123456789101112131415161718class Sleep &#123; constructor(timeout) &#123; this.timeout = timeout; &#125; then(resolve, reject) &#123; const startTime = Date.now(); setTimeout( () =&gt; resolve(Date.now() - startTime), this.timeout ); &#125;&#125;(async () =&gt; &#123; const actualTime = await new Sleep(1000); console.log(actualTime);&#125;)(); 如果 await 后面的Promise 状态为 rejected 那么结果将会传递给 catch 方法；并且函数会中断执行,除非使用 try..catch 或者 对应的 Pomise 使用 catch方法 。 12345678910async function ay () &#123; await Promise.reject(18).catch((err) =&gt; &#123; console.log(err) &#125;) return "Owem"&#125;ay().then(res =&gt;console.log(res))//18//Owem 多个 await 后面的异步，如果不存在继发关系，最好同时触发 1234567891011async function fn() &#123; var time = + new Date() console.log(time,1) let [p1,p2] = await Promise.all([ new Promise(resolve =&gt; setTimeout(resolve,1000)), new Promise(resolve =&gt; setTimeout(resolve,2000))]); return +new Date() - time;&#125;fn().then(time =&gt; console.log(time,2)); 只能再 async 函数中使用 await 12345678async function ay () &#123; function ()&#123; await 1 &#125; return "Owem"&#125;ay() //error async 原理 将Generator 函数和执行器包装再一个函数中 1234567891011121314151617181920212223function autoactuator (gen) &#123; return new Promise((resolve,reject) =&gt; &#123; const g = gen(); let step = (next) =&gt; &#123; let n; try&#123; n = next(); &#125;catch(err) &#123; return reject(err) &#125; if(n.done)&#123; return resolve(n.value) &#125; Promise.resolve(next.value).ten((v) =&gt;&#123; step(() =&gt; g.next(v)); &#125;,function(e)&#123; setp(() =&gt; g.throw(e)); &#125;); &#125; step(() =&gt; g.next(undefined)); &#125;)&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pormise]]></title>
    <url>%2F2019%2F03%2F14%2Fpromise%2F</url>
    <content type="text"><![CDATA[Promise 为了解决 “回调地狱”（callback hell）而提出的写法允许将 callback 变成链式调用它是一个容器，保存着某个异步操作的结果。 特点 对象的状态部受外界影响；有三种状态， 进行中( pending ) 、 成功( fulfilled ) 、 失败( rejected );只有异步操作的结果可以决定那种状态。 状态一旦改变，就不会更改（resolved 定型），状态的改变只会是两种情况 pengding -&gt; fulfilled or pengding -&gt; rejected; 一旦建立就会立即执行 , 中途无法取消，无法得知事件进展，不设置callback，内部将会抛出错误 简单实列 使用 Promise 构造函数生成实例12345678910111213141516171819//exampleconst promise = new Promise(function (resolve,reject) &#123; //... do something $.get(url,function (data) &#123; if (data) &#123; resolve(data) &#125; &#125;).fail(function(err)&#123; reject(err) &#125;) &#125;);promise.then(function(data) &#123; console.log(data)&#125;,function(err)&#123; console.log(err)&#125;) 可见 Promise 接受一个callback 作为参数， callback有两个参数，都是函数 第一个 resolve 异步操作成功时调用，将成功的信息作为参数传递出去 第二个 rejcet 异步操作失败时调用，将失败的信息传递出去 then 方法生成实例后,可以使用 then 方法 接收成功状态和失败状态的回调,在当前脚本所有同步任务执行完才会执行 第一个参数是成功后的callback (必传) 第二个参数是失败后的callback (为可选参数) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108const promise = (time) =&gt; &#123; return new Promise((resolve,reject) =&gt; &#123; console.log("promise") setTimeout(resolve,time,'Owen') &#125;)&#125;promise(1000).then((val) =&gt; console.log(val)) //"promise" 1s后 "Owen"//加载图片function loadImage (url) &#123; return new Promise((resolve,reject) =&gt; &#123; const image = new Image(); image.onload = () =&gt; resolve(image); image.onerror = () =&gt; reject(new Error(`not lad image at: $&#123;url&#125;`)) image.src = url; &#125;)&#125;//实现原生ajax(get)const getJSON = function (url) &#123; return new Promise((resolve, reject) =&gt; &#123; const handler = function () &#123; if ( this.readySate !== 4 ) return; if (this.status === 200 ) &#123; resolve(this.response) &#125;else &#123; reject( new Error(this.statusText) ) &#125; &#125;; const client = new XMLHttpRequest(); client.open("GET",url); client.onreadystatechange = handler; client.setRequestHeader("Accept", "application/json"); client.send() &#125;);&#125;getJSON('url').then((res) =&gt; &#123;console.log(res)&#125;,err =&gt; console.error(err));//---console.log(1)const p1 = new Promise(function (resolve, reject) &#123;console.log(2) resolve();&#125;); console.log(3)const p2 = new Promise(function (resolve, reject) &#123; console.log(4) resolve(p1);&#125;)setTimeout( function () &#123; console.log(5)&#125;,0)window.requestAnimationFrame(function(v)&#123; // 回调函数执行次数通常是每秒60次 // 当requestAnimationFrame() 运行在后台标签页或者隐藏的&lt;iframe&gt; 里时， // requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。 //回调函数会被传入DOMHighResTimeStamp参数 （排队的回调开始触发的时间戳） console.log(8,v) //cancel​Animation​Frame(requestId) 取消 window.requestAnimationFrame&#125;)p2.then(function()&#123; console.log(7)&#125;)p1.then(function()&#123; console.log(6)&#125;)//p1的状态决定了p2的状态//1//2//3//4// 6// 7//&#123;&lt;resolved&gt;: undefined&#125;// 8// 5//向另一个 promise 传递 promise 执行状态问题const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123;reject(new Error('fail')); console.log(1)&#125;, 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt;&#123;console.log(2); resolve(p1) &#125;, 1000)&#125;)p2.then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error)) //error fail//传入的 promise 会改变 自己 promise 的状态，变成传入的promise的状态 catch 方法 指定发生错误时的回调函数。 12345678910111213141516171819202122232425262728293031323334p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err));//状态改变后不会再接收之后的状态const promise = new Promise(function(resolve, reject) &#123; resolve('ok'); reject( new Error('test'));&#125;);promise .then(function(value) &#123; console.log(value) &#125;) //ok .catch(function(error) &#123; console.log(error) &#125;);// promise 内部错误不会影响外部的代码，不会退出进程、终止脚本执行const promise = new Promise(function(resolve, reject) &#123; resolve(Owen); &#125;);promise.catch(function(error)&#123;console.log(error)&#125;).then(function(v)&#123;console.log('Owen:' + v)&#125;)console.log(18)//18//error//Owen:undefined //如果将 then 放到第一个将不会执行 //因为 then 接收的是 promise变量 的状态 //而放到末尾则接收的是 catch 返回的 Promise 函数的状态 finally不管 promise 的状态怎么变都会执行的方法 （ES2018) 12345678910111213141516//finally方法的回调函数不接受任何参数promise.finally(() =&gt; &#123; // 语句&#125;);// 等同于promise.then( result =&gt; &#123; // 语句 return result; &#125;, error =&gt; &#123; // 语句 throw error; &#125;); all 用于将多个 Promise 实例，包装成一个新 Promise 实例 参数是一个数组或者具有 Interator的接口（返回成员必须是promise)，如果成员不是 Promise 实例，会将其包装成一个porimse 实例 等待所以成员的状态都变成 resolved 状态， Promise.all 才变成 resolved 状态，并且成员返回值将以数组形式传递给 then 数组成员中只有又一位成员为rejectd 状态，Promise.all 就会变成 rejected , 并将第一个变为rejectd的成员返回值传递给 catch 如果成员自己定义了 then 或者 catch 对应成员的返回值不会传递到 all 的回调当中 123456789101112//exampleconst p1 = new Promise((resolve,reject) =&gt; setTimeout(resolve,1000,'Owen')) //.then(result =&gt;console.log(result)) // .catch(err =&gt;console.log(err));const p2 = new Promise(res =&gt; &#123; throw new Error('报错了');&#125;) .then(re =&gt; console.log(re)) .catch(err =&gt; console.log(err));//error const promise = Promise.all([p1,p2]) .then(res=&gt;console.log(res)) //1s 后 ["Owen",undefined] .catch(err =&gt; console.log(err)); race 和 all 方法一样 只是成员状态发生改变的情况不同 数组中只要有一个成员改变状态， race 就改变状态，并将返回值传递给 race方法 123456789101112//exampleconst p1 = new Promise((resolve,reject) =&gt; setTimeout(resolve,1000,'Owen')) //.then(result =&gt;console.log(result)) // .catch(err =&gt;console.log(err));const p2 = new Promise(res =&gt; &#123; throw new Error('报错了');&#125;) .then(re =&gt; console.log(re)) .catch(err =&gt; console.log(err));//error const promise = Promise.race([p1,p2]) .then(res=&gt;console.log(res)) //undefined .catch(err =&gt; console.log(err)); resolve 将对象转化为Promise对象123Promise.resolve('Owen')// 等同new Promise(resolve =&gt; resolve('Owen')) 传参情况 Promise实例 返回出入的实例 传入 thenable对象 具有 then方法的对象,将其转化为 Promise 对象 12345678910var obj = &#123; then: function(resolve,reject)&#123; resolve("Owen") &#125;&#125;var p = Promise.resolve(obj);p.then(function(res)&#123; console.log(res) //"Owen"&#125;) 不是对象或者没有 thenable方法 返回一个新的Promise，状态为 resolved1234const p = Promise.resolve(18);p.then(function(re)&#123; console.log(re) //18&#125;) reject 返回一个新的Promise，状态为 rejectd123456789101112131415const p = Promise.reject('出错了');// 等同 const p = new Promise((resolve, reject) =&gt; reject('出错了'))const thenable = &#123; then(resolve, reject) &#123; reject('出错了'); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable) //true&#125;) 结合 Generator 使用12345678910111213141516171819202122232425262728293031323334const g = function* () &#123; try &#123; const foo = yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function getFoo () &#123; return new Promise(function (resolve, reject)&#123; resolve('foo'); &#125;);&#125;function run (generator) &#123; const it = generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(g); Promise/A+ 规范 实现者为开发者提供开放的 Promise标准，实现可靠，可互操作的JavaScript承诺。 术语（Terminology） promise 是一个对象或函数，其then 方法 的行为符合此规范 thenable 定义 then 方法的对象或函数 value 是任何合法的 JavaScript 值 （包括 undefined 、thenable 和 promise） exception 是使用 throw 语句抛出的值 reason 是一个值（拒因），表明承诺被拒绝的原因（拒绝回调的值） 要求（Requirements）Promise states Promise 只有三种状态：pending 、 fulfilled（resolved） 和 rejected 状态 pending（等待状态）：可以过渡到 resolved 或 rejected 状态 fulfilled (执行状态）：无法再改变状态，且只有一个无法改变的value rejected （拒绝状态）：无法再改变状态，必须有一个 reason 这里的 ‘无法再改变’ 意味着不可改变的身份 使用 === 判断 value 或 reason then 方法（The then method） 一个 Promise 必须提供一个 then 方法来访问当前 或 最终value 或 reason此方法接收两个参数： onFulfilled,onRejected 必须忽略其中不是函数是参数 onFulfilled：必须在 promise 执行状态（fufilled ）结束后调用，其第一个参数为 value，只能调用一次 onRejected： 必须在 promise 拒绝状态（rejected ）结束后调用, 其第一个参数为 reason，只能调用一次 onFulfilled or onRejected 在执行上下文 (作用域)堆栈仅包含平台代码之前不得调用意味着调用 onFulfilled,onRejected 须在新一轮 event loop 中执行， 可用 macro-task（setTimout,setInterval,I/O,UI rendering, script主线程) 或 micro-task（Promise, Object.observe,process.nextTick,MutationObserver） 机制来实现 onFulfilled or onRejected 必须作为函数调用，在 use strict 下 this 为 undefined then在同一个 promise 中可以链式调用，按照对应注册顺序一次回调 then返回一个Promise对象 1promise2 = promise1.then(onFulfilled, onRejected); 任一 onFulfilled或onRejected返回一个值x ,则执行 Promise 解决过程 onFulfilled或onRejected 抛出异常 e, 则 promise2 必须拒绝执行，并返回 reason 如果onFulfilled 不是函数且 Promise1 为执行 fulfilled状态，那么 promise2 必须返回和 Promise1 相同的value 如果onRejected不是函数且 Promise1 为 rejected状态，那么 promise2 必须返回和 Promise1 相同的reason Promise 解决过程 (The Promise Resolution Procedure) Promise 解决过程是一个抽象的操作，作为输入一个Promise,和一个值，用 [[Resolve]](Promise2,x) 表示；如果 x 有 then 方法并且看上去像一个Promise,Promise 解决过程程序会尝试promise采用状态 x，否则用 x 的 value执行Promise;对thenables的这种处理使promise的实现进行互操作，只要它们暴露出一个遵循 Promise/A+规范 兼容then方法即可。它还允许Promise/A+规范来“吸收”与合理不符合标准的实现then方法。 运行 [Resolve] 需遵循以下步骤： 如果promise和x指向同一个对象，以TypeError为理由拒绝执行promise。 如果 x 是 promise，则接收其状态： 2.1 如果 x 为 pending， 则 Promise 保持等待直至 x改变状态 2.2 如果 x 为 resolved，则 用相同的 value 执行 promise 2.3 如果 x 为 rejected，则 用相同的 reason执行 promise 如果 x 是 Object or Function: 3.1 把 x.then 赋值给 then 3.2 如果 xthen 抛出异常 结果 e，promise 状态变为 rejected，reason 为 e 3.3 如果 then是一个函数，将x作为函数作用域 this 调用，传递两个回调函数作为参数，第一个为 resolvePromise, 第二个参数为 rejectPromise3.3.1 如果 `resolvePromise` 以值 `y`为参数被调用，以 `r`为 `reason` ，则运行 `[[Resolve]](promise, y)` 3.3.2 如果 `rejectPromise` 用`r`为参数调用 ，则以 `r`拒绝 promise 3.3.3 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用第一次调用并忽略剩下的调用 3.3.4 如果调用then抛出异常`e`，resolvePromise或rejectPromise已被调用，请忽略它；否则以 `e` 为`reason`(据因)拒绝 promise 3.4 如果then不是一个函数, 则以x为参数执行 promise 如果 x不为Object or Function，以 x 为参数执行 promise 如果一个 promise 被一个循环的 thenable 链中的对象解决，而[[Resolve]](promise, thenable) 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为reason(据因)来拒绝 promise 手写简版 Promise 1234567891011121314151617181920212223242526272829303132333435363738// 常用变量大写const PENDING ='pending'const RESOLVEd = 'resolved'const REJECTEd = 'rejected'class myPromise &#123; constructor(callback) &#123; const that = this that.state = PENDING; that.resolveCallback = []; that.rejectCallback = []; const resolve = value =&gt;&#123; if (that.state === PENDING)&#123; that.state = RESOLVED; that.value = value that.resolveCallback.map(cb =&gt; cb(that.value)) &#125; &#125; const reject = value =&gt;&#123; if (that.state === PENDING)&#123; that.state = REJECTED; that.value = value that.rejectCallback.map(cb =&gt; cb(that.value)) &#125; &#125; try &#123; callback(resolve,reject) &#125;catch(e)&#123; reject(e) &#125; &#125; then(onResolved,onRejected)&#123; const that = this &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步操作原理（二）]]></title>
    <url>%2F2019%2F03%2F13%2FeventLoop%2F</url>
    <content type="text"><![CDATA[事件循环(eventLoop) 详解并行和并发： 并行性是指两个或多个事件在同一时刻发生；并发性是指两个或多个事件在同一时间段内发生。 任务队列 和 事件循环 JS 将变量存储在 堆 heap 和 栈 stack中堆中存放对象比如 ：数组，对象，函数栈中存放变量和对象的指针运行时同步任务会排好队，依次执行，而排队的地方就叫执行栈（先进后出） JS运行时，除了有一个主线程运行，引擎还提供任务队列 task queue , 里面是各种需要当前程序处理的异步任务。（不止一个任务队列） 异步任务通常是一个回调函数；如果一个异步任务没有回调函数，是不会放入异步任务队列中，同样也不会进入主线程中执行。 执行过程： 主线程会先执行完所有同步任务 同步任务结束，查看任务队列（先进先出的数据结构，排在前面的事件，优先被主线程读取。）里面的异步任务 查看所有满足执行条件的异步任务，放入主线程中变成同步任务，执行对应的回调函数。 执行完毕再将下一个满足执行条件的异步任务放入主线程中执行。 不断重复前三步操作 只要同步任务执行完毕，JS引擎会不停的监测检查任务队列中的异步任务，将满足执行条件且最先进入的任务加入到执行栈中去执行，如此往复。这种检查机制就叫事件循环 Event Loop 微任务与宏任务异步任务还会分两层： 微任务(micro task) 宏任务(macro task) 主线程会先查看微任务 micro task；如果没有满足条件的任务，再去宏任务中查找；如果有则将所有满足条件的微任务按顺序依次加入到主进程中；执行完毕后再去红任务队列中查找，往复循环。常见宏任务： 定时器 I/O（输入/输出）操作 微任务(jobs)： Promise async/awaitnodeJSnodeJS 中任务队列 加入了 process.nextTick 和 setImmediate。前者比后者先执行123456789101112131415161718192021process.nextTick(function A() &#123; console.log(1); process.nextTick(function B()&#123;console.log(2);&#125;);&#125;);setImmediate(function ()&#123; setImmediate(function A() &#123; console.log(3); setImmediate(function B()&#123;console.log(4);&#125;); &#125;); setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED'); &#125;, 0);&#125;);// 1// 2// 3// TIMEOUT FIRED// 4//这个结果是不确定的可能是 1234 TIMEOUT FIRED || 12 TIMEOUT FIRED 34 其二者的调用顺序取决于当前event loop的上下文，如果他们在异步i／o callback之外调用，其执行先后顺序是不确定的。123456789101112var fs = require('fs')fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout') &#125;, 0) setImmediate(() =&gt; &#123; console.log('immediate') &#125;)&#125;)//immediate//timeout 这是因为fs.readFile callback执行完后，程序设定了timer 和 setImmediate，因此poll阶段不会被阻塞进而进入check阶段先执行setImmediate，后进入timer阶段执行setTimeout。setTimeout和setImmediate的差异 process.nextTick在最新版nodejs中不被推荐使用，推荐使用setImmediate ，原因在于nextTick是在当前帧介绍后立即执行，会阻断I/O并且有最大数量限制；而setImmediate不会阻断I/O，更像是setTimeout(func, 0)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步操作原理(一)]]></title>
    <url>%2F2019%2F03%2F11%2Fasync%2F</url>
    <content type="text"><![CDATA[单线程 javascript 只再一个线程上运行，同时只能执行一个任务，一行一行执行。 javascript 运行在单线程上，并不代表 JavaScript引擎就是单线程的，其实它有多个线程，单个脚本只能在一个线程上运行（主线程），其他线程在后台配合运行。 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 这种模式好处在于， 实现起来简单，环境单纯。 但是 耗时较长，后面的任务必须等待前面的任务执行完毕。 同步和异步任务 同步未被引擎挂起、在主线程上排队执行的任务。需要前面的任务执行完后才能执行。 异步 被引擎挂起，暂不处理的任务,不进入主线程、而进入任务队列; 只有达到某个条件，异步任务才会进入主线程，不会堵塞异步任务后面的代码 （ajax 是最具代表性的异步任务） 异步操作模式回调函数 Callback 将函数传递进一个方法中，函数不会立即执行，等待出来结果之后在执行。回调函数是异步操作最基本的方法 容易出现回调地狱（Callback hell)比如多个 ajax 嵌套请求123456789ajax(url, () =&gt; &#123; // 处理逻辑 ajax(url1, () =&gt; &#123; // 处理逻辑 ajax(url2, () =&gt; &#123; // 处理逻辑 &#125;) &#125;)&#125;) 这种方式容易理解和简单，但是不利于维护和阅读；耦合度高，结构混乱，错误较难追踪，而且每个任务只能指定一个回调。 事件监听 采用事件驱动。W3C规范中定义3个事件阶段：捕获(Netscape)，目标，冒泡（IE）。事件冒泡：在目标元素上发生click事件的顺序 目标元素 -&gt; 父级元素 -&gt; body -&gt; html -&gt; document事件捕获： 与冒泡相反，document -&gt; html -&gt; body -&gt; 父级元素 -&gt; 目标元素 123456789101112131415161718// 原生事件委托 var parent = document.getElementById('parent'); parent.addEventListener('click',showColor,false); function showColor(e)&#123; var son = e.target; if(son.nodeName.toLowerCase() === 'li')&#123; console.log('The color is ' + son.innerHTML); &#125; &#125; //类似 jQuery写法 fn.on('click',function()&#123;&#125;); //等同于 function fn ()&#123; setTimeout(function()&#123; //do someing fn.trigger('done') &#125;,1000) &#125; 这种方法比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，可以去“耦合”(decoupling),便于实现模块化。 但是整个程序都会变成事件驱动，流程不清晰。 发布/订阅 消息的发送者（称为发布者） 不会将消息直接发送给特定的接收者（称为订阅者），而是将不消息分为不同的类别，不需要了解哪些订阅者；订阅者,只接收感兴趣的消息，不需要了解哪些发布者可以把事件理解成“信号”,如果存在一个“信号中心”； 某个任务执行完成，就向信号中心“发布” (publish) 一个信号，其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己开始执行 1234567891011121314var obj = $(&#123;&#125;);obj.on("aaa", function () &#123; console.log(111111111111); &#125;)obj.on("aaa", function () &#123; console.log(222222222222); &#125;)$(dom).click(function() &#123; obj.trigger("aaa"); &#125;); 当 foo 执行完毕后，想消息纵向发布 done信号，引发执行fn 消息过滤订阅者通常接收信号中心中(消息代理)的一个子集，选择接受和处理的消息过程叫过滤过滤形式 基于主题 消息被发布到主题或命名通道上；订阅者将受到所有信息，并且所有订阅同一主题的订阅者都将收到同样的信息；发布者赋值定义订阅者所订阅的消息类别 基于内容 订阅者定义感兴趣的条件，只有当消息的属性或内容满足订阅者的条件，消息才投递到该订阅者。订阅者负责堆消息分类。 拓扑发布者 发布消息到一个消息代理，订阅者向其注册订阅，由消息代理来过滤 优缺点： 松耦合，发布者和订阅者只需要关注主题内容，相互独立地运行。 扩展性强，通过并行操作，消息缓存，基于树或网路路由等技术，比传统客户端具有更好的扩展性。 缺点： 发布者解耦订阅者，问题难以跟踪，无法知道消息传送是成功的还是失败的 异步操作的流程控制（多个异步操作如何确定异步操作的执行顺序，如何保证这种顺序执行）串行执行 一个任务执行完毕后，再执行另一个 123456789101112131415161718 let arr = [1,2,3,4,5]; let results = [];const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res);const series = item =&gt;&#123; if(item)&#123; async(item,result=&gt;&#123; results.push(result); return serise(items.shift();) &#125;) &#125;else&#123; return final(results[results.length-1]); &#125;&#125;series(items.shift()); 上面代码 series 就是一个串行函数； 类似与同步任务 并行执行 所有异步任务同时执行，全部执行完毕，再执行 最终 (final) 函数 12345678910111213141516 let arr = [1,2,3,4,5]; let results = [];const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res); for (let item of items)&#123; async(item,(result) =&gt;&#123; results.push(result) &#125;) if(results.length == items.length)&#123; final(results[results.length-1]); &#125; &#125; 上面代码，for 循环会同时执行5异步任务，等他们执行完毕再执行 final 函数。 过个并行任务较多，容易耗尽系统资源，拖慢运行 并串结合 限制并行执行任务的数量，避免占用过多系统资源 1234567891011121314151617181920let items = [1,2,3,4,5];let results = [];let running = 0,limit = 2;const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res);const launcher = () =&gt; &#123; while (running &lt; limit &amp;&amp; items.length&gt;0)&#123; let item = items.shift()； async (item,(res)=&gt;&#123; results.push(result); running--; items.length? launcher(): final(results); &#125;) running++ &#125;&#125; 上面代码，最多只能运行两个异步任务，当前 running 记录运行的任务数量，低于门槛 limit 就会新增一个任务，直到任务执行完毕。 轮询12345678let hash = window.location.hash;const hashWatcher = () =&gt;&#123; if(window.location.hash != hash)&#123; updatePage() &#125;&#125;setInterval(hashWatcher,1000) setInterval 时间 间隔是” 开始执行 “ 之间的间隔,不会考虑每次执行的任务时间，所以两次执行间隔会小于指定时间。比如 指定 100ms 任务本身消耗 105 ms，那么第一次执行完毕后，第二次会立即执行。 如果要固定间隔，可以使用 setTimeout12345678let hash = window.location.hash;const hashWatcher = () =&gt;&#123; if(window.location.hash != hash)&#123; updatePage() &#125; setTimeout(hashWatcher,1000)&#125;setTimeout(hashWatcher,1000) 注意： HTML标准规定 setTimeout 最小间隔 4ms 由于定时器每执行一次,会返回一个整数，连续执行，返回值比上一次大1 123456789101112131415161718 (function() &#123; // 每轮事件循环检查一次 var gid = setInterval(clearAllTimeouts, 1000); function clearAllTimeouts() &#123; var id = setTimeout(function() &#123; console.log("g:"+gid) &#125;,0); while (id &gt; 0) &#123; if (id !== gid) &#123; clearTimeout(id); &#125; id--; &#125; &#125;&#125;)(); 防抖（debounce） 在某些场景下不希望事件执行太频繁，我们可以设置一个阀门临界值，再一段时间内只执行一次,或者一段时间过后执完所有任务 123456789101112131415161718192021222324252627282930//一段时间只执行一次let perform = (fn,time) =&gt; &#123; let flag = true; return function () &#123; let self = this,arg = arguments; if(flag)&#123; flag = false; fn.apply(self,arg); setTimeout(() =&gt; &#123; flag = true &#125;,time) &#125; &#125;&#125;let fn = () =&gt; console.log(1);setInterval(perform(fn,2000),500); // 经过一段时间再执行所有要执行的任务 let debounce = (fn,delay) =&gt;&#123; let timer = null; return function ()&#123; let self = this,arg = arguments; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(self,arg) &#125;,delay) &#125; &#125;setInterval(perform(fn,2500),500); 参考原文链接： http://wangdoc.com]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发(二)]]></title>
    <url>%2F2019%2F03%2F07%2Fmodularization%2F</url>
    <content type="text"><![CDATA[ES6 详解 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。 顶层的this指向undefined，即不应该在顶层代码使用this。 严格模式主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface）上面这些限制，模块都必须遵守。 export命令 export除了输出变量，还可以输出函数或类（class）,还可以通过 as 更改输出名。 12345678let age = 18;let obj =&#123;name: "Owen"&#125;;let multiply = (x, y) =&gt; x * y;export &#123; age, obj as monicker, //改变量名 multiply&#125; 导出的对象必须是对外的接口 1234let num =2;export num ; //error 因为实际输出的是一个值，须放在对象中 &#123;num&#125;exprot 2 //error 输出的是值 而不是一个对外接口 =&gt; 须改成 export let num =2； 不能放到局部作用域中导出， 因为导出的对象是动态绑定的12let foo = (r) =&gt; r++;let fn = () =&gt; export default foo; //error export default 全局只能有一个 export default export default 后面不能有 变量声明的关键字 使用 export default ，import 就不需要使用 {},只需要自定义一个变量即可 123456export default var a=1; //errorexport default obj =&#123;name:'Owen'&#125;;//orlet num = 1;let obj1 = &#123;name:"Owen"&#125;;export default &#123;num, obj1&#125; import 配合 from 导入模块, 通过 as 修改导入接口, 接口不能重新赋值，但对象可以修改内部属性或方法。 12345import &#123;age, monicker as obj, multiply&#125; from './preson.js'; age = 0 ; //error obj.feature = "handsome Owen"; console.log(age, obj。name, multiply(1,2)) import * as preson from "./preson.js" //引入所有接口 import 具有提升的效果，会提升到作用域顶部执行，同一个模块多次引入只执行一次，并且不能再局部作用域中引入。 12345678multiply(2,2); //4import &#123;age, monicker as obj, multiply&#125; from './preson.js';if (true)&#123;import &#123;age, monicker as obj, multiply&#125; from './preson.js'; //error&#125; import() 因为require是运行时加载模块，import命令无法取代require的动态加载功能。因此，有一个提案，引入import()函数，完成动态加载。 import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。 和 require类似，不同之处在于 import()是同步加载 require()是异步加载 1const path =import('path'); 我们可以利用 import() 进行按需加载,动态加载，按条件加载: 12345678910import('./a.js') .then(r =&gt; &#123; r.fn(); &#125;) .catch(error =&gt; &#123; /* Error handling */ &#125;)if( x == 1)&#123; const path =import('path');&#125; 如果想同时加载多个模块，可以采用下面的写法 123456789 Promise.all([ import('./a.js'), import('./b.js'), import('./c.js'),]) .then(([a,b,c]) =&gt; &#123; // ... &#125;).catch(error =&gt; &#123; /* Error handling */ &#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>moduleDevelop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 升级 webpack4 配置]]></title>
    <url>%2F2019%2F03%2F07%2Fwebpack%2F</url>
    <content type="text"><![CDATA[升级webpack4 先删除之前的webpack1npm i -D webpack webpack-cli webpack-dev-server build/base.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119const os = require('os') //node OS模块 可查看主机系统相关信息const path = require('path') //node path模块 c处理文件路径const utils = require('./utils') //vue-cli封装的公用模块const webpack = require('webpack')const config = require('../config')//vue-cli封装的配置const HappyPack = require("happypack")//开启多个子进程去并发执行const HtmlWebpackPlugin = require('html-webpack-plugin')//webpack主要插件，可以简化HTML文件的创建const CleanWebpackPlugin = require('clean-webpack-plugin');//清空打包好的文件const ProgressBarPlugin = require('progress-bar-webpack-plugin')//查看进度const vueLoaderConfig = require('./vue-loader.conf')// 处理less,sass等样式配置文件 const VueLoaderPlugin = require('vue-loader/lib/plugin');const argv = require("yargs-parser")(process.argv.slice(2))//获取运行 scripts 里面的指令 --mode 后面参数 const isPro = argv.mode == "production"const resolve = dir =&gt; path.resolve(__dirname, "..", dir)module.exports = &#123; context: path.resolve(__dirname, '../'), entry: &#123; app: "./src/main.js" &#125;, output: &#123; path: config.build.assetsRoot, filename: '[name].js', publicPath: isPro ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue': 'vue/dist/vue.esm.js', 'src': path.resolve(__dirname, '../src/common'), '@': resolve('src'), '~': resolve('src/components/common'), 'static': path.resolve(__dirname, '../static'), &#125; &#125;, module: &#123; rules: [&#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loaders: 'happypack/loader?id=babel',//配合 happypack插件使用 exclude: /(node_modules|bower_components)/, include: [resolve('src'), resolve('test')] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;, node: &#123; setImmediate: false, dgram: 'empty', fs: 'empty', net: 'empty', tls: 'empty', child_process: 'empty' &#125;, plugins: [ new ProgressBarPlugin(), new CleanWebpackPlugin(), new HappyPack(&#123; id: 'babel', loaders: [&#123; loader: 'babel-loader', options: &#123; babelrc: true, cacheDirectory: true, &#125;, publicPath: "/" &#125;], //共享进程池 threadPool: HappyPack.ThreadPool(&#123; size: os.cpus().length //cpu nunbers &#125;), //允许 HappyPack 输出日志 verbose: true, &#125;), new webpack.DefinePlugin(&#123; 'process.env': &#123; 'NODE_ENV': JSON.stringify(argv.mode) &#125; &#125;), new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true, favicon: './src/assets/img/favicon.ico' &#125;), new webpack.ProvidePlugin(&#123;//引入全局变量 $: 'jquery', jQuery: 'jquery', // 加上这个 &#125;), new VueLoaderPlugin() ]&#125; build/dev.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566'use strict'const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')//可以合并 base.conf 配置文件const baseWebpackConfig = require('./webpack.base.conf')const HtmlWebpackPlugin = require('html-webpack-plugin')const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')//让日志更加友好const portfinder = require('portfinder') //查找开放端口或域接字的简单工具 const HOST = process.env.HOSTconst PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)const devWebpackConfig = merge(baseWebpackConfig, &#123; mode:'development', module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, devtool: config.dev.devtool, devServer: &#123; clientLogLevel: 'warning', historyApiFallback: true, hot: true, compress: true, host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll, &#125;, disableHostCheck: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125;)module.exports = new Promise((resolve, reject) =&gt; &#123; portfinder.basePort = process.env.PORT || config.dev.port portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; process.env.PORT = port devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`], &#125;, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) pluguin1npm i -D happypack html-webpack-plugin clean-webpack-plugin progress-bar-webpack-plugin yargs-parser friendly-errors-webpack-plugin portfinder webpack-merge extract-text-webpack-plugin@next optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin chalk rimraf babel-loader1npm i babel-loader @babel/cli @babel/core @babel/ @babel/preset-env plugin-proposal-class-properties @babel/ plugin-proposal-decorators @babel/ plugin-syntax-dynamic-import @babel/plugin-transform-classes @babel/plugin-transform-runtime -D 1npm i --save @babel/runtime @babel/runtime-corejs2 .babelrc123456789101112131415161718&#123; "presets": [ ["@babel/preset-env", &#123; "useBuiltIns": "usage" &#125;] ], "plugins": [ ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;], "@babel/proposal-class-properties", ["@babel/plugin-transform-runtime", &#123; "corejs": 2 &#125;], "@babel/plugin-syntax-dynamic-import", "@babel/plugin-transform-classes" ]&#125; build/prod.conf.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394'use strict'const path = require('path')const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const CopyWebpackPlugin = require('copy-webpack-plugin')//复制文件和目录const HtmlWebpackPlugin = require('html-webpack-plugin')const ExtractTextPlugin = require('extract-text-webpack-plugin')//提取样式文件，只有extract-text-webpack-plugin@^4.0.0-beta.0 才支持webpack4 //或者使用 mini-css-extract-plugin 用法详见 ![GitHub](https://github.com/search?q=mini-css-extract-plugin)const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin') //用于优化\最小化 CSSconst UglifyJsPlugin = require('uglifyjs-webpack-plugin') // 压缩JS资源const webpackConfig = merge(baseWebpackConfig, &#123; mode: 'production', module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true, usePostCSS: true &#125;) &#125;, devtool: config.build.productionSourceMap ? config.build.devtool : false, output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[chunkhash].js'), chunkFilename: utils.assetsPath('js/[id].[chunkhash].js') &#125;, optimization: &#123; splitChunks: &#123; chunks: 'all', // initial、async和all minSize: 30000, // 形成一个新代码块最小的体积 maxAsyncRequests: 5, // 按需加载时候最大的并行请求数 maxInitialRequests: 3, // 最大初始化请求数 automaticNameDelimiter: '~', // 打包分割符 name: true &#125;, minimizer: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true &#125;), // extract css into its own file new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[hash].css'), allChunks: true, &#125;), new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), new HtmlWebpackPlugin(&#123; filename: config.build.index, template: 'index.html', inject: true, favicon: './src/assets/img/favicon.ico', minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, chunksSortMode: 'dependency' &#125;), new webpack.optimize.ModuleConcatenationPlugin(), new CopyWebpackPlugin([&#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125;]) ] &#125;&#125;)module.exports = webpackConfig build.js123456789101112131415161718192021222324252627282930313233343536'use strict'require('./check-versions')()process.env.NODE_ENV = 'production'const rm = require('rimraf')//删除文件const path = require('path')const chalk = require('chalk')//终端字符串样式const webpack = require('webpack')const config = require('../config')const webpackConfig = require('./webpack.prod.conf')rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; if (err) throw err webpack(webpackConfig, (err, stats) =&gt; &#123; if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, chunks: false, chunkModules: false &#125;) + '\n\n') if (stats.hasErrors()) &#123; console.log(chalk.red(' 构建失败，错误.\n')) process.exit(1) &#125; console.log(chalk.cyan(' Build success.\n')) console.log(chalk.yellow( ' 打包文件应该通过HTTP服务器启用.\n' )) &#125;)&#125;)]]></content>
      <categories>
        <category>package</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发(一)]]></title>
    <url>%2F2019%2F03%2F07%2Fmodule%2F</url>
    <content type="text"><![CDATA[什么是模块化 将一组模块（及其依赖项）以正确的顺序拼接到一个文件（或一组文件）中的过程。 传统的模块化做法。 模块是实现特定功能的一组属性和方法的封装。 将模块写成一个对象，所有的模块成员都放到这个对象里面。1234567var module1 = new Object(&#123; _count:0, f1:function()&#123;&#125;, f2:function()&#123;&#125;&#125;)module1.f1()module1.f2() 上面的对象可以改变里面的属性和方法，不安全 123456789var module1 = （function()&#123; var count=0; return &#123; f1:function()&#123;&#125;, f2:function()&#123;&#125;&#125;&#125;());module1.f1()module1.f2()module1.count //undefined 使用立即执行函数 将相应的方法和属性封装在函数中,这样就不会暴露私有成员 利用构造函数封装对象12345678910111213function Father ()&#123; var arr =[]; this.add = function (val)&#123; arr.push(val) &#125; this.toString = function()&#123; return arr.join(''); &#125;&#125;var a = new Father();a.add(1);//[1]a.toString();//"1"a.arr // undefined 上面的函数将 arr 变成私有变量，在函数外部无法访问，但是形成了闭包，非常耗费内存；违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。12345678910111213function ToString() &#123; this._buffer = [];&#125;ToString.prototype = &#123; constructor: ToString, add: function (str) &#123; this._buffer.push(str); &#125;, toString: function () &#123; return this._buffer.join(''); &#125;&#125;; 虽然上面的构造函数未生成闭包，但是外部可以修改方法和属性，不安全 放大模式如果一个模块很大或者一个模块需要继承另一个模块可以利用立即执行函数的特效来封装123456var module1 = (function(m1)&#123;mod1.col=function()&#123; console.log(this)&#125;;return mod1;&#125;(window.modlue2 ||&#123;&#125;)) //有些模块可能是null 确保函数正常执行 采用兼容模式 window.modlue2 ||&#123;&#125; 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。123var module1 = (function ($, Swiper) &#123; //...&#125;(jQuery, Swiper)); 上面的 module1 引入 jQuery 和 Swiper 当做两个参数传入模块中，保证了模块的独立性，还使得模块之间的依赖关系变得明显。 立即执行函数还可以起到命名空间的作用。123456789101112131415161718192021(function($, window, document) &#123; function go(num) &#123; &#125; function handleEvents() &#123; &#125; function initialize() &#123; &#125; function dieCarouselDie() &#123; &#125; //attach to the global scope window.finalCarousel = &#123; init : initialize, destroy : dieCarouselDie &#125;&#125;( jQuery, window, document )); 以上都有一个共同点:使用单个全局变量箭头代码包装在函数中，使用闭包建立私有空间但是都有缺点： 不知道模块(库) 的加载顺序 还是有可能引起命名冲突，比如两个库都有相同的名称，或者使用哪个版本有几种良好实施的方法：CommonJS、AMD和CMD。可以解决以上的缺陷 CommonJS CommonJS 是一种思想, 本质上是可复用的JavaScript,它导出特定的对象，提供其它程序使用。 由于 JavaScript 没有模块系统、标准库较少、缺乏包管理工具,因此CommonJS是为它的表现来制定规范。 每个JavaScript 文件 都将模块存储在自己独有的作用域中。 需要使用 module.exports 和 exports.obj 来导出对象，并在需要它的程序中使用 require(&#39;module&#39;) 加载 1234567891011121314151617181920 //文件1 function myModule() &#123; this.hello = function() &#123; return 'hello!'; &#125; this.goodbye = function() &#123; return 'goodbye!'; &#125;&#125;module.exports = myModule; //文件2 var myModule = require('myModule');var myModuleInstance = new myModule();myModuleInstance.hello(); // 'hello!'myModuleInstance.goodbye(); // 'goodbye!' 实现原理 123456789101112var module1 = &#123; export1:&#123;&#125;&#125;;(function (module,exports)&#123; exports.add = functon(val)&#123; return val *10 &#125;&#125;(module1,module1.export1));var fn = module1.export1.add;fn(2)//20 利用立即执行函数 接受两个参数 module 和 exports， 模块就通过立即执行函数赋值，然后导出模块，即可实现模块的加载这种方法的好处： 避免全局污染 明确依赖项目 语法清晰缺点： 由于 CommonJS 采用服务器优先方法并且同步加载模块，因此在浏览器中使用它会阻止浏览器运行其他内容，直到加载完成。 我们可以使用 AMD 来异步加载 AMD(Asynchromous Module Definition) 定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。 AMD模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 定义了一个函数 define，通过 define 方法定义模块。 1234 define(['myModule', 'myOtherModule'], function(myModule, myOtherModule) &#123; console.log(myModule.hello());&#125;); 上面的 define 函数将每个模块的依赖项，以数组的形式作为参数。 这些依赖项会在后台异步加载，一旦加载完成，define 函数就调用模块给出的回调函数myModule 可能像下面一样定义： 1234567891011 define([], function() &#123; return &#123; hello: function() &#123; console.log('hello'); &#125;, goodbye: function() &#123; console.log('goodbye'); &#125; &#125;;&#125;); CMD(Common Module Definition) CMD由玉伯大佬提出并用于SeaJS CMD 和 AMD 很相似，都有 define 函数， 通过 require 加载 CMD和AMD 不同点： 对于依赖的模块 CMD 延迟执行， AMD 提前执行(requireJS 高版本也开始延迟执行) CMD使用依赖就近原则（按需加载）： 12345678910111213141516 define(function(require, exports, module) &#123; var near = require('./a') near.doSomething() // 此处略去 100 行 var nearOne = require('./b') // 依赖可以就近书写 nearOne.doSomething() // ... &#125;) ``` - AMD使用依赖前置原则（必须先加载完依赖）： ```javascript define(['./a', './b'], function(nearTow, nearThree) &#123; // 必须一开始加载 nearTow.doSomething() // 此处略去 100 行 nearThree.doSomething() ... &#125;) CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。 AMD 和 CommonJS 不同点：AMD： 采用浏览器优先的方法，异步加载，主要用于浏览器 先加载依赖项 依赖项可以说 对象、函数、构造函数、字符串等等其他JS类型 CommonJS: 采用服务器优先的方法，同步加载，主要用于服务器 支持对象作为模块共同点： 先加载依赖项 通用模块定义 UMD 同时支持 AMD和 CommonJS本质 创建了一种方法来使用两者的任何一种，同时支持全局变量定义，(JS兼容性的常用思想)所以 UMD 可以在客户端和服务器上工作1234567891011121314151617181920(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['myModule', 'myOtherModule'], factory); &#125; else if (typeof exports === 'object') &#123; // CommonJS module.exports = factory(require('myModule'), require('myOtherModule')); &#125; else &#123; root.returnExports = factory(root.myModule, root.myOtherModule); &#125;&#125;(this, function (myModule, myOtherModule) &#123; function notHelloOrGoodbye()&#123;&#125;; function hello()&#123;&#125;; function goodbye()&#123;&#125;; return &#123; hello: hello, goodbye: goodbye &#125;&#125;)); ES6模块（即 ES2015/ECMAScript 6、ES6） 使用 import 关键字引入模块，通过 export 关键字导出模块 ES6目前无法在浏览器中执行,只能通过babel将不被支持的import编译为当前受到广泛支持的 require。 12345678910111213141516171819//a.jsexport let cun =1; export function add() &#123; cun++;&#125;//----------------import &#123; cun, add &#125; from './a.js';console.log(cun); // 1incCounter();console.log(cun); // 2export var fo ='a';setTimeout(() =&gt; fo ='b',500);import &#123;fo&#125; from './a.js';console.log(fo);//'a'setTimeout(()=&gt; console.log(fo),500)//'b'//ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。fo = 's' //error ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。CommonJS、AMD和CMD相比: ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 ES6 对外接口只是一种静态定义，在代码静态解析阶段就会生成。 ES6 module编译时输出接口(加载)，输出的是值的引用。(静态编译) CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。 CommonJS 模块运行时加载，输出的是一个值的拷贝。(动态编译)一旦输出一个值，模块内部的变化就影响不到这个值。12345678910111213141516171819202122232425// lib/counter.jsvar counter = 1;function increment() &#123; counter++;&#125;function decrement() &#123; counter--;&#125;module.exports = &#123; counter: counter, increment: increment, decrement: decrement&#125;;// src/main.jsvar counter = require('../../lib/counter');counter.increment();console.log(counter.counter); // 1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>moduleDevelop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(三)]]></title>
    <url>%2F2019%2F03%2F05%2Foop3%2F</url>
    <content type="text"><![CDATA[对象继承A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。 JavaScript 语言的继承不通过 class，而是通过“原型对象”prototype实现 传统原型链式继承 过多的继承属性 比如一个函数用不到某个原型方法或属性，那么方法或属性就过剩了123456789101112function Grand()&#123;&#125;;Grand.prototype.name="grand";let grand = new Grand();Father.prototype=grand;function Father()&#123;&#125;let father = new Father();Son.prototype=father;function Son()&#123;&#125;let son = new Son(); 借用构造函数 使用call/appply 不是真正继承，因为不能调用原型上的方法，而且每调用一次都会调用多次函数，实际上步骤没有变少 工业级推荐使用 缺点无法添加私有原型 123456789101112 function Father() &#123; &#125;function Son() &#123; Father.call(this); // 调用父类构造函数&#125;Son.prototype.print = function() &#123; Father.prototype.print.call(this);//只使用单个方法&#125;// 子类继承父类的原型Son.prototype = Object.create(Father.prototype);Son.prototype.constructor = Son; 共有原型1234567891011Father.prototype =&#123; name:"common"&#125;function Father()&#123;&#125;Son.prototype = Object.create(Father.prototype)function Son()&#123;&#125;function inherit (Target,Origin)&#123;//继承源 Target.prototype = Origin.prototype;&#125; 圣杯模式 隐式附加的东西就私有化，可以公共定义的东西提取出来公有化1234567891011let inherit =(function()&#123; let Interim =function Interim() &#123;&#125;; return function (Target,Origin)&#123;//继承源 Interim.prototype =Object.create(Origin); Target.prototype = Interim.prototype; //现在 可以 制定自己的私有属性，但是 constuctor 不是 原函数所一手动赋值回来，如果想要知道函数真正继承那个原型需要保存它 Target.prototype.constuctor = Target; Target.prototype.yliluokka =Origin; &#125; &#125;()) 多重继承JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过Object.assign，实现这个功能。这种模式称之为 Mixin (混入)123456789101112function Fn1()&#123; &#125;function Fn2()&#123; &#125;function Son()&#123; F1.call(this); F2.call(this); &#125;//继承F1Son.prototype =Object.create(Fn1.prototype);//继承F2Object.assign(Son.prototype,Fn2.prototype);Son.prototype.constructor =Son;let a =new Son(); call，apply and bind 都可改变函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 call and apply1234567function test() &#123;&#125; //test() == test.call()let obj =&#123;&#125;;Object.prototype.toString.call(obj) //"[object Object]"//因为call 和 apply 会将函数中的this指向第一个参数//相当于 obj.toString() call and apply 二者区别在于传参： call 第二个参数开始单个单个参数传 apply 第二个参数为数组或类数组123456//返回数组中最大的数let a = [1, 2, 4, 1, 15];Math.max.apply(null, a) // 15//将数组的空元素变为undefinedArray.apply(null, [1,,3,,4])//[1,undefined,3,undefined,4]; 空元素与undefined的差别 forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 转换类似数组的对象 12let obj=&#123;0: 1, length: 2&#125;Array.protetype.slice.apply(obj);//[1,undefined] 被处理的对象必须有length属性，以及相对应的数字键。 参数为空、null和undefined，则默认传入全局对象。 bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 1234567891011121314151617181920212223let counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;let func = counter.inc.bind(counter);func();counter.count // 1let add = function (x, y) &#123; return x * this.m + y * this.n;&#125;let obj = &#123; m: 2, n: 2&#125;;let newAdd = add.bind(obj, 5); //将x 绑定为 5 newAdd(5) // 20newAdd(1,5)//12 第一个参数是null或undefined，等于将this绑定到全局对象 bind方法使用注意点 bind方法每运行一次，就返回一个新函数 需要一个变量接收 结合回调函数使用 1234567891011121314let counter = &#123; count: 0, inc: function () &#123; 'use strict'; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 结合call方法使用 1234567891011121314151617181920[1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1]//将Array.prototype.slice变成Function.prototype.call方法所在的对象//调用时就变成了Array.prototype.slice.call。let slice = Function.prototype.call.bind(Array.prototype.slice);Function.prototype.slice.call([1, 2, 3], 0, 1) // [1]//slice([1, 2, 3], 0, 1) let push = Function.prototype.call.bind(Array.prototype.push);let pop = Function.prototype.call.bind(Array.prototype.pop);let a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 将Function.prototype.bind方法变成Function.prototype.call的方法，就意味着bind的调用形式也可以被改写 1234567function f() &#123; console.log(this.v);&#125;let o = &#123; v: 123 &#125;;let bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123 Object 系统默认方法 getPrototypeOf 获取对象原型,只有一个参数 12345678910function Foo ()&#123;&#125;let obj = new Foo ();Object.getPrototypeOf(obj) // Foo.prototype//空对象原型 Object.getPrototypeOf(&#123;&#125;) // Object.prototype// Object.prototype 原型 Object.getPrototypeOf(Object.prototype) //null// FooObject.getPrototypeOf(Foo) // Function.prototype setPrototypeOf 设置对象原型有两个参数： 现有对象 继承的原型对象12345let now = &#123;&#125;;let pro = &#123;name:"Owen"&#125;;Object.setPrototypeOf(now,pro);now.name //"Owen" Object.create() 生成实例对象的常用方法 参数必须为对象 或 null 参数为 null 会生成一个不会继承任何属性和方法的对象12345678910111213141516171819202122232425262728293031let obj = Object.create(null);obj.toString()// Error //会继承第二个参数的属性和方法let obj = Object.create(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true, configurable: true, writable: true, &#125;, p2: &#123; value: 'Owen', enumerable: true, configurable: true, writable: true, &#125; &#125;);// 等同于let obj = Object.create(&#123;&#125;);obj.p1 = 123;obj.p2 = 'Owen';//生成的对象会继承它的原型对象的构造函数。function Foo() &#123;&#125;let f = new Foo();let b = Object.create(f);b.constructor === Foo // trueb instanceof Foo // true object.isPrototypeOf 判断对象是否再参数对象的原型链上 123function F()&#123;&#125;let f = new F()F.prototype.isPrototypeOf(f) //true 获取原型的三种方法 obj.__proto__ obj.constructor.prototype Object.getPrototypeOf(obj) 前两种不可靠，都个一手动修改， 而且 __proto__ 只有浏览器才需要部署 getOwnPropertyNames 和 keys 以数组形式返回参数对象所有属性名(不包含继承属性) 1234//不管可不可遍历都会返回出来Object.getOwnPropertyNames(Date);//["length", "name", "prototype", "now", "parse", "UTC"]//返回可遍历属性Object.keys(Date)// [] hasOwnProperty 判断参数是否是自身的属性，唯一一个不会遍历原型链的方法1Array.hasOwnProperty('length')//true 拷贝对象拷贝对象需要确保两件事情： 与原对象具有同样的原型。 与原对象具有同样的实例属性。 1234567891011121314151617function copyOwn (target,origin)&#123; Object.getOwnPropertyNames(origin).forEach((key)=&gt;&#123; let desc =Object.getOwnPropertyDescriptor(origin,key); Object.defineProperty(target,origin,desc); &#125;) return target&#125;function copy(origin)&#123; let clone = Object.create (Object.getPrototypeOf(origin)); copyOwn(clone,origin) return clone&#125;//es8const copyTwo = origin =&gt;Object.create( Object.getPropertyOf(origin),Object.getOwnPropertyDescriptor(origin) );]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(二)]]></title>
    <url>%2F2019%2F03%2F05%2Fopp2%2F</url>
    <content type="text"><![CDATA[原型对象 prototype 原型对象的所有属性和方法,都能被实例对象共享 JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。123456789function Cat (name, color) &#123; this.name = name; this.color = color;&#125;var cat1 = new Cat('小明', '白色');cat1.name // '小明'cat1.color // '白色' 构造函数缺点： 一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。 解决方法，就是 JavaScript 的原型对象 prototype，因为原型对象的所有属性和方法，都能被实例对象共享。 123456789function Cat (name, color) &#123; this.name = name;&#125;Cat.prototype.color ="白色";&#125;var cat1 = new Cat('巧克力');var cat2 = new Cat('布丁');cat1.color //白色cat2.color//白色 JavaScript规定，每个函数都有一个prototype属性，指向一个对象。 对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。 实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。 12function f() &#123;&#125;typeof f.prototype // "object" 每个 JS 对象都有 __proto__ 属性，这个属性可以访问到 原型（[[prototype]]） 内部属性。这个属性在现在来说已经不推荐直接去使用它了。 原型链 任何对象，都可以充当其他对象的原型；原型对象也有自己的原型。对象到原型，再到原型的原型，一层层向上找到Object.prototype。 可以说 基本上所有对象都继承了Object.prototype的属性；而 Object.prototype 的原型是 null通过 getPrototypeOf 方法返回参数对象原型1Object.getPrototypeOf(Object.prototype) //null 读取对象属性时，引擎会先在自身属性上查找，没有就查找原型，一级级向上查找，如果到Object.prototype还是没有，则返回undefined。 一级级向上，对性能有影响，寻找的层级越多，性能影响越大 原型链： 实例 F1 通过__proto__ 访问对应构造函数的原型 -&gt; FOO.prototype 函数原型再通过__proto__ 访问Object的原型 -&gt; Object.prototype Object的原型的__proto__ 指向 null 构造函数 Foo.prototype 通过constructor访问构造函数本身 Object.constructo 指向 Function Function.constructo 指向 本身 Function.__proto__ 指向一个匿名函数 每个构造函数通过 prototype 访问原型 只有函数才拥有prototype属性,基本上所有函数都有这个属性 1let fun = Function.prototype.bind() 当声明一个函数时自动创建 prototype 属性，这个属性的值是一个对象（也就是原型），且只有一个属性 constructor constructor prototype 有一个属性 constructor，默认指向原型所在的构造函数 12345678function Fn ()&#123;&#125;var f = new Fn ();f.constructor == Fn //truef.constructor == Function //false//可以从实例对象新建另一个实例var b =new f.constructor();b.constructor == Fn //true constructor是一个公有且不可枚举的属性。一旦我们改变了函数的 prototype ，那么新对象就没有这个属性了,如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。 1234function A()&#123;&#125;console.log(A.prototype) // &#123;constructor: ƒ&#125;constructor: ƒ A()__proto__: ObjectA.prototype="a"console.log(A.prototype) //"a" constructor作用： 让实例对象知道是什么函数构造了它 可以得知某个实例对象，是哪一个构造函数产生的。 如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 xx.constructor.method 来扩展 __proto__基本上每个对象都有的隐式原型属性，指向创建该对象的构造函数的原型，实际指向[[prototype]]， 内部属性，我们并不能访问到，所以使用 proto 来访问。12console.log(&#123;&#125;)//__proto__: Objectconstructor: ƒ Object()hasOwnProperty: .... 当我们使用 new 操作符时，生成的实例对象拥有了 __proto__属性。1234567function Foo() &#123;&#125;// 这个函数是 Function 的实例对象// function 就是一个语法糖// 内部调用了 new Function(...)const a =1;const fn = new Function("console.log(a)") // Function 的this始终指向 全局对象，除非手动改变this指向fn()//1 所有对象都可以通过原型链最终找到 Object.prototype ，虽然 Object.prototype 也是一个对象，但是这个对象却不是 Object 创造的，而是引擎自己创建了 Object.prototype 。可以这样说，所有实例都是对象，但是对象不一定都是实例。 -首先引擎创建了 Object.prototype ，然后创建了 Function.prototype ，并且通过proto 将两者联系了起来。 Function.prototype 以后才有了 function Function() ，然后其他的构造函数都是 function Function() 生成的。 函数通过 new Function() 生成, 不是所有函数都是 new Function()产生的。 Object 是所有对象的爸爸，所有对象都可以通过proto 找到它 Function 是所有函数的爸爸，所有函数都可以通过proto 找到它 Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎来创建 除了以上两个特殊对象，其他对象都是通过构造器 new 出来的 函数的 prototype 是一个对象，也就是原型对象的proto 指向原型，proto将对象和原型连接起来组成了原型链]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(一)]]></title>
    <url>%2F2019%2F03%2F04%2Fopp1%2F</url>
    <content type="text"><![CDATA[什么是对象对象是单个实物的抽象，通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。 面向对象编程的第一步，就是要生成对象。 对象是一个容器，封装了属性（property）和方法（method），属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。 JavaScript 语言的对象体系，不是基于“类”的，而是基于构造数constructor和原型链prototype；所以JS 专门使用构造函数作为对象模板；一个构造函数，可生成多个实列对象，它们有相同的结构 构造函数与普通函数区别 构造函数就是一个普通的函数，但是有自己的特征和用法。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。123456789101112//constructor var Bird = function () &#123; this.name = 'lai fu';&#125;;var bird1 = new Bird(); // 也可以使用 new Bird; 推荐使用前者console.log(bird1.name) // "lai fu"//ordinaryvar a =Bird();console.log(a) // undefinedconsole.log(a.name) // typeErrorname // 'laifu' 防止把构造函数constructor当普通函数使用1234567891011121314151617 //使用 严格模式function Fubar(foo, bar)&#123; 'use strict'; this._foo = foo; this._bar = bar;&#125;Fubar()// TypeError//判断 this 不是构造函数（constructor）的实列对象 那么手动返回自身constructorfunction Far(a)&#123; if (!(this instanceof Far)) return new Far(a); this._a=a;&#125;Far(1)._a new命令的原理 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 12345678910111213141516171819202122/***新生成一个空对象*链接到原型*绑定 this*返回新对象**/function _new(constuctor,param) &#123; // 获得构造函数 let Con = [].shift.call(arguments); // 创建一个空对象，继承构造函数的 prototype 属性 链接到原型 let obj = Object.create(Con.prototype); // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return (typeof(result) === 'object' &amp;&amp; result != null) ? result : obj&#125; var fn = _new( function Person (name,age)&#123; this.name = name; this.age = age &#125;, 'Owen', 28);fn.name // 'Owen' new.target12345678910111213141516function f() &#123; console.log(new.target === f);&#125;f() // falsenew f() // true //可利用 它来判断是否使用 new 命令function f() &#123; if (!new.target) &#123; throw new Error('请使用 new 命令调用！'); &#125; // ...&#125;f() // Uncaught Error: 请使用 new 命令调用！ this实质 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。 1var obj = &#123; a: 1 &#125;; JavaScript 存储变量实际上是以下面的形式保存的。 12345678&#123; a: &#123; [[value]]: 1 //函数的地址 [[writable]]: true //是否可赋值 [[enumerable]]: true//是否可枚举 [[configurable]]: true//是否可配置 &#125;&#125; 属性的值保存在属性描述对象的value属性里面。 如果 a 属性的值是引用值 那么属性将以下面的形式保存的：1234567891011var obj = &#123; fn: function () &#123;&#125; &#125;;/*&#123; fn: &#123; [[value]]: [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125;*/ 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f n= function () &#123;&#125;;var obj = &#123; f: fn &#125;;// 单独执行 fn()// obj 环境执行obj.f() JavaScript 允许在函数体内部，引用当前环境的其他变量。 由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 下面这几种用法，都会改变this的指向。1234567891011121314151617181920(obj.fn = obj.fn)() // window// 等同于(function () &#123; console.log(this);&#125;)()(false || obj.fn)() // window// 等同于(false || function () &#123; console.log(this);&#125;)()(4, obj.fn)() // window// 等同于(4, function () &#123; console.log(this);&#125;)() 数组调用forEach 方法时函数内部this 指向window ，将父级上下文传递给forEach 改变this指向1234567891011var o = &#123; v: 'hello', p: [ 'Owen', 18 ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + '-' + item); &#125;, this); //将外层的this传递给forEach方法 &#125;&#125;o.f() // hello-Owen hello-18 end]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
</search>
