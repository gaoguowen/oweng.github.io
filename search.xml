<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高阶函数]]></title>
    <url>%2F2019%2F07%2F12%2FdesignPatterns3%2F</url>
    <content type="text"><![CDATA[什么是高阶函数 函数可以作为参数被传递，也可以作为返回值输出 函数作为参数传递 将函数作为参数传递，我们就可以抽离以部分容易变化的业务逻辑，这样可以分离业务代码中变与不变的部分 回调函数： 将函数传进一个方法中，函数不会立即执行，等待出来结果之后在执行。123456789let func = function (callback)&#123; if(n === 'owen')&#123; callback() //回调函数 &#125;&#125; function say ()&#123; console.log('Hello Word') &#125; func(say) Array 对象常用的方法 1234[1,2,3,4].forEach(iteration) function iteration(v)&#123; console.log(v) &#125; 作为返回值输出 让函数继续返回一个可执行的函数，意味着运行过程是可延续的。 判断数据类型1234567891011121314151617let type = type =&gt;&#123; return obj =&gt; Object.prototype.toString.call(obj) === `[object $&#123;type&#125;]`&#125;let isArray = type('Array'),isString = type('String'),isNumber = type('Number'),isObject = type('Object');// orlet Type = (function()&#123; let type = &#123;&#125;,types = ['Object','Array','Number','String'] for (let val of types) &#123; (function(str)&#123; type[`is$&#123;str&#125;`] = (obj) =&gt; Object.prototype.toString.call( obj ) === `[object $&#123;str&#125;]` &#125;(val)) &#125; console.log(type) return type&#125;())Type.isNumber(2) // true 实现AOP（面向切片编程） AOP 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。JAVA 语言中 AOP 将一些跟核心业务逻辑模块无关的功能抽离出来，通常包括日志统计、安全控制、异常处理灯。再通过“动态织入”的方式掺入业务逻辑中。好处： 可以保持业务逻辑模块的纯净和高内聚，方便复用日志统计等功能模块。 JavaScript中实现AOP是指把一个函数“动态织入”到另一个函数之中具体实现：123456789101112131415161718192021222324252627Function.prototype.before = function(beforeFn)&#123; let that = this; // 谁调用指向谁 下面是由 func 函数调用所以是指向 func return function( ...args)&#123; beforeFn.apply(this,args) // 执行回调函数 beforeFn return that.apply(this,args) // 执行原函数 &#125;&#125;Function.prototype.after = function(afterFn)&#123; let that = this; // 谁调用指向谁 下面是由befor函数调用所以是指向 befor return function( ...args)&#123; let ret = that.apply(this,args) // 执行并接收原对象 afterFn.apply(this,args) // 执行回调函数 beforeFn return ret &#125;&#125;var func = function ()&#123; console.log(2)&#125;func = func.before(function ()&#123; console.log(1)&#125;).after(function ()&#123; console.log(3)&#125;)func()// 1 2 3 函数柯里化 （function currying） 在数学和计算机科学中，柯里化是将多个参数的函数转换成一系列使用一个参数的函数，且返回接受余下的参数的新函数 curring 又称部分求值；一个 curring 函数首先会接收一些参数，该函数并不会立即求值，而是继续返回另外一个函数，而刚传入的参数会被保存在形成的闭包中，待函数真正需要求值的时候，之前的所以参数都会被一次性用于求值 简单示例：1234567function add(a,b) &#123; return a + b&#125;add(1,2) // 3// 如果柯里化add(1)(2) // 3 接下来使用 currying 实现一个几天之内消费总和的函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 普通方法var cost = (function() &#123; var args = []; return function()&#123; if(!arguments.length)&#123; let money = 0 for (let val of args )&#123; money += val; &#125; return money &#125;else&#123; [].push.apply(args,arguments) &#125; &#125;&#125;)()cost(100);cost(100);cost(100);cost(); // 300cost(100)(100)(100)// currying/** * 保存原函数参数返回到新函数中使用 */// func(100,100,100) //300function count (...args)&#123; let num = 0; if(args.length&gt;1)&#123; for (let v of args)&#123; num +=v &#125; return num &#125;else&#123; return args[0] &#125;&#125;var curry = function(func)&#123; let args = [] return function fn(...Args)&#123; if (Args.length)&#123; [].push.apply(args,Args) return fn &#125;else&#123; return func.apply(this,args) &#125; &#125;&#125;cost = curry(count);cost(100);cost(100);cost(100);cost(); // 300 函数节流JavaScript 中大多数情况都是用户主动出发函数，除非函数本身的实现不合理，否则一般不会遇到跟性能相关的问题，少数情况下，函数不是由用户直接触发控制，可能被频繁调用造成严重的性能问题。比如：12345678910111213141516window.addEventListener('resize', function(e) &#123; // do something...&#125;);window.addEventListener('scroll', function(e) &#123; // do something...&#125;);Dom.addEventListener('mousemove', function(e) &#123; // do something...&#125;);// progressxhr.upload.addEventListener("progress", function(result) &#123; // do something...&#125;, false);// ... 上述事件1秒种触发很多次，并且常常操作DOM节点，非常损耗性能，浏览器会因此吃不消而卡顿；实际我们不需要触发如此高的频率因此我们可以在一段时间内忽略掉一些执行次数 节流原理： 如果持续触发事件，可每隔一段时间只执行一次。 使用定时器实现节流 将即将被执行的函数用 setTimeout 函数延迟一段时间执行，如果该定时器未执行完成则忽略接下下来的需被执行的函数。1234567891011121314151617181920 function throttle(func,wait) &#123; let timer, firstFlag = true; //第一次立即执行 return function(...args) &#123; if(timer) return false; // 如果存在定时器这不执行 let that = this; if(firstFlag)&#123; firstFlag = false; return func.apply(that,args); &#125; timer = setTimeout(function()&#123; clearTimeout(timer); timer = null; func.apply(that,args); &#125;,wait) &#125; &#125; window.addEventListener('scroll', throttle(function(e) &#123; console.log(e) &#125;,1000)); 函数防抖 和节流一定时间段内只调用一次事件处理函数不同，防抖是一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。（用户不再触发对应事件才执行一次事件）12345678910111213function debounce(func,wait) &#123; let timer; return function(...args) &#123; let that = this; clearTimeout(timer); timer = setTimeout(function()&#123; func.apply(that,args) &#125;,wait) &#125;&#125; window.addEventListener('scroll', debounce(function(e) &#123; console.log(e) &#125;,1000));]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式基础（二）]]></title>
    <url>%2F2019%2F07%2F09%2FdesignPatterns2%2F</url>
    <content type="text"><![CDATA[原型模式在以类为中心的面向对象编程语言中，类和对象的关系就像铸模和铸件的关系，对象总是从类中创建。而原型编程中，类不是必须的，对象未必从类中创建而来，可以拷贝另一个对象而变成新对象 从设计模式角度讲，原型模式是用于创建对象的一种模式，找到一个对象，不需要关心对象的具体类型，通过克隆来创建一个一模一样的对象。 原型不单是一种设计模式，也被称为编程泛型 原型模式实现的关键是语言本身是否提供了 clone 方法， ECMAScript 5 提供了 Object.create 方法123456789101112function Plane (propertys)&#123; //工厂方法 this.blood = propertys.blood; this.attackLevel = propertys.attackLevel; this.defenseLevel = propertys.defenseLevel;&#125;var plane = new Plane(&#123; blood :100, attackLevel :10, defenseLevel :10&#125;);var clonePlane = Object.create(plane);console.log(clonePlane.__proto__) // Plane &#123;blood: 100, attackLevel: 10, defenseLevel: 10&#125; 通过克隆 plane 对象得到 clonePlane 对象,那么 plane 就被称为 clonePlane 的原型；而 plane 中所有的属性和方法都将挂载到__proto__ 原型属性上 每个 JS 对象都有 __proto__ 属性(隐式原型属性)，指向创建该对象的构造函数的原型,这个属性可以访问到原型（[[prototype]]） 内部属性。这个属性在现在来说已经不推荐直接去使用它了。 由于 JavaScript 作为一门基于原型的语言，没有类的概念，每一个对象都是基于另一个对象的克隆，因此语言最初只有一个根对象 Object.prototype,如果A对象是从B对象克隆而来，那么B就是A的原型，如果C又是B的原型。它们之间就形成了一条原型链 原型编程中有一个重要特性：访问对象中某个属性或方法，而对象本身没有对应属性和方法，那么它会从自己的原型链上查找，一直查到根对象为止一级级向上，对性能有影响，寻找的层级越多，性能影响越大123456console.log(clonePlane) // Plane &#123;&#125;console.log(clonePlane.blood) // 100console.log(clonePlane.color) // undefinedconsole.log(clonePlane.__proto__) //原型 Plane &#123;blood: 100, attackLevel: 10, defenseLevel: 10&#125;上述代码中的clonePlane 对象 本身是没有 blood 和 color 属性，却能访问到blood的值而访问不到color的值，是因为 clonePlane 对象 原型链中有 blood 属性而没有color属性。原型编程基本规则：1. 所有数据都是对象2. 对象会记住它的原型（类似于继承）3. 要得到一个对象，需要将另一个对象作为原型并克隆它4. 访问不到对象的某个属性或方法，那么它会从自己的原型链上查找，一直查到根对象为止## 原型继承在JavaScript中我们遇到的每一个对象都是从 Object.prototype克隆而来，通过Object.getPrototypeOf来判断对象的原型从属关系。12345let obj = new Object();let obj1 = &#123;&#125;;console.log(Object.getPrototypeOf(obj) === Object.prototype) // trueconsole.log(Object.getPrototypeOf(obj1) === Object.prototype) // true由于引擎内部会自动实现对 Object.prototype 的克隆，所有我们执行显示的使用let obj = new Object(); let obj1 = {}; prototype 有一个属性 constructor，默认指向原型所在的构造函数,constructor是一个公有且不可枚举的属性。一旦我们改变了函数的 prototype ，那么新对象就没有这个属性了,如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。下面我们来看new 运算符 JavaScript中没有类的概念，所以 Object 是一个构造函数，JavaScript 中的函数即可作为普通函数调用，又可作为构造器调用,当使用 new 运算调用函数时，函数就是构造器。 new命令的原理 创建一个空对象，作为返回的对象实例 将构造函数指向原型prototype属性（继承构造函数） 绑定作用域（ this 指向空对象 ） 执行构造函数,如果构造函数return 为对象则使用该对象，否则 return 创建的空对象 模拟 new 运算12345678910111213141516function __new (fun,args)&#123; // 获取构造函数 let arr =[...arguments] let Con = arr.shift() // 创建对象，将构造函数的原型指向它 let obj = Object.create(Con.prototype) // 绑定 this let ret = Con.apply(obj,arr) return (typeof ret === 'object' &amp;&amp; ret !== null )? ret : obj&#125;let person = __new(function Person(&#123; name,sex,age &#125;)&#123; this.name = name; this.sex = sex this.age = age&#125;,&#123;name:'owen',sex:'man',age:18&#125;)console.log(person) // Person &#123;name: "owen", sex: "man", age: 18&#125; new.target： 可利用 它来判断是否使用 new 命令 12345678function func() &#123; if (!new.target) &#123; throw new Error('请使用 new 命令调用！'); &#125; // ...&#125;func() // Uncaught Error: 请使用 new 命令调用！ call，apply and bindJavascript 编程中 call，apply 和 bind 方法被广泛运用，在学习设计模式前先理解这几个概念 三者都可改变函数内部this的指向（即函数执行时所在的作用域） call and apply 都是在改变this 指向后调用该函数。1234567function test() &#123;&#125;//test() == test.call()let obj =&#123;&#125;;Object.prototype.toString.call(obj) //"[object Object]"//因为call 和 apply 会将函数中的this指向第一个参数//相当于 obj.toString() call and apply 二者区别在于传参： call 第二个参数开始单个单个参数传 apply 第二个参数为数组或类数组 123456//返回数组中最大的数let arr = [1, 2, 4, 1, 15];Math.max.apply(null, arr) // 15//将数组的空元素变为undefinedArray.apply(null,[1,,3,,4])//[1,undefined,3,undefined,4]; 空元素与undefined的差别 forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 转换类似数组的对象 12let obj=&#123;0: 1, length: 2&#125;Array.protetype.slice.apply(obj);//[1,undefined] 被处理的对象必须有length属性，以及相对应的数字键。 参数为空、null和undefined，则默认传入全局对象。 bindbind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 1234567891011121314151617181920212223let counter = &#123; count: 0, func: function () &#123; this.count++; &#125;&#125;;let func = counter.func.bind(counter);func(); // 相当于 count++counter.count // 1let add = function (x, y) &#123; return x * this.m + y * this.n;&#125;let obj = &#123; m: 2, n: 2&#125;;let newAdd = add.bind(obj, 5); //将x 绑定为 5newAdd(5) // 20newAdd(1,6)//12 6为起作用 相当于 5*2+1*2 第一个参数是null或undefined，等于将this绑定到全局对象 bind方法使用注意点 bind方法每运行一次，就返回一个新函数 需要一个变量接收 模拟 bind1234567891011Function.prototype.bind = function (...Args) &#123; if (typeof this !== "function") &#123; throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); &#125; let that = this, //保存原函数 target = Args.shift(), //提取须绑定的对像 func = (...args) =&gt;that.apply(target ? this : target || window, aArgs.concat(args)); // aArgs.concat(args) 合并参数 func.prototype = Object.create(this.prototype); // 继承原函数的原型 return func;&#125;; 结合回调函数使用 1234567891011121314let counter = &#123; count: 0, inc: function () &#123; 'use strict'; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 结合call方法使用 1234567891011121314151617181920[1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1]//将Array.prototype.slice变成Function.prototype.call方法所在的对象//调用时就变成了Array.prototype.slice.call。let slice = Function.prototype.call.bind(Array.prototype.slice);Function.prototype.slice.call([1, 2, 3], 0, 1) // [1]//slice([1, 2, 3], 0, 1)let push = Function.prototype.call.bind(Array.prototype.push);let pop = Function.prototype.call.bind(Array.prototype.pop);let a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 将Function.prototype.bind方法变成Function.prototype.call的方法，就意味着bind的调用形式也可以被改写 1234567function f() &#123; console.log(this.v);&#125;let o = &#123; v: 123 &#125;;let bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123]]></content>
      <categories>
        <category>design patterns</category>
      </categories>
      <tags>
        <tag>Pattern intro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式基础（一）]]></title>
    <url>%2F2019%2F07%2F08%2FdesignPatterns1%2F</url>
    <content type="text"><![CDATA[什么是设计模式？ 模式 起源于建筑学。20世纪70年代，哈佛大学建筑学博士Christopher Alexander和他的团队花大约20年，来研究为解决同一个问题而设计出的不同建筑结构，从中发现那些高质量设计中的相似性，并且用模式来指代这种相似性； 受Christopher Alexander观点的启发，Erich Gamma, Richard Helm, Ralph Johnson和 John Vlissides(人称Gang Of Four, GoF),将这种 模式 观点应用于面向对象的软件设计中，并总结了23种常见的软件开发设计模式， 于 1995 年发布一本名叫《Design Patterns: Elements Of Reusable Object-Oriented Software》的书 设计模式的定义：在面向对象软件设计过程种针对特定的问题的简洁而优雅的解决方案。就是给面向对象软件开发中一些 好的设计取个名。 为什么要给好设计取名？在开发中，一些稍有经验的程序员也许在不知不觉中使用过设计模式，于是他向别人描述它时会遇到困难，沟通成本高、效率低。而 GoF 将这些好的设计从面向对象中挑选出来，这些都是久经考验的反应了开发者的经验和见解的使用模式来定义的技术，给它们一个好听又好记的名字，这样就方便我们更好的传播和学习，当遇到一个问题时，知道这是哪种设计模式，就能很快想出几种解决方案，提高工作效率。 好处： 提供固定的解决方法来解决在软件开发中出现的问题。 很容易地重用，防止在应用程序开发过程中出现的一些可能导致重大问题的小问题，提高工作效率。 避免重复代码来减小我们文件大小。 模式善于表达，交流更快速，降低沟通成本。 所有设计模式的实现都遵循一条原则：找出程序中变化的地方，将变化封装起来。一个程序的设计总是可以分为 可变部分和不变的部分；找出可变部分，将其封装，剩下的不变和稳定部分就非常容易复用。作用： 让人写出可复用和可维护的程序。JavaScript是一门面向对象语言[1][2][3]，设计模式通过对面向对象的特征封装、继承、组合、多态等技术的反复使用，提炼出可复用的面向对象设计技巧。 设计模式基础 JavaScript 在语言层面没有抽象类和接口的支持，没有类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。 编程语言类型编程语言按数据类型大体可分两大类：静态类型语言和动态类型语言 。静态类型语言在编译时就已经确定变量的类型，动态类型语言只有在程序运行的时候才能确定变量的类型。而JavaScript就是动态类型语言。 静态语言优点： 编译时就能发现类型不匹配的错误，可以避免程序运行时有可能发生的错误。 编译器可针对对应变量的类型进行优化，提高程序运行速度。 静态语言缺点： 迫使程序员按照对应的规则来写程序，为每个变量规定数据类型分散程序员注意力，增加代码量。 动态语言优点： 代码简洁，程序员可以把更多精力放在业务逻辑处理上，更加专注 无需类型检测，灵活性高，只关注须对象的行为，无需关注对象本身 不必借助超类型来实现”面向接口编程” 动态语言缺点： 无法保证变量的类型，程序可能发生意想不到的bug. 面向对象的特征(参考JAVA)多态、继承、封装 多态 定义：同一操作作用于不同对象，产生不同的解释和不同的执行结果 给不同对象发送同一个消息时，这些对象会根据这个消息分别给出不同的回应。 123456789101112var sendInfo = target =&gt; &#123; if ( target instanceof ObjOne) &#123; console.log(new ObjOne) &#125;else if (target instanceof ObjTwo) &#123; console.log(new ObjTwo) &#125;&#125; function ObjOne () &#123;&#125; function ObjTwo () &#123;&#125; sendInfo(new ObjOne()) sendInfo(new ObjTwo()) 上述代码段就体现了多态性,当发送 sendInfo 消息时每个对象做出不同的回应，但是这样的多态性很糟糕，如果再这个家一个对象 ObjThere 就得改动代码，对象越来越多时，修改的代码越多，出错的可能性越大。 多态背后的思想是将 做什么 和 谁去做以及怎样做分开，也就是将 不变的事物和可能变化的事 分开。上述代码段中，每个对象都会打印日志,这是不变的，而各个对象输出哪些信息是变化的，将不变的隔离出来，把变化的封装起来，这样程序就又了扩展能力，是可生长的，这样就符合 开发-封闭 原则。下面是修改后的代码： 1234567891011let sendInfo = target =&gt; &#123; target.log()&#125; function ObjOne () &#123;&#125;ObjOne.prototype.log = function()&#123;console.log(this)&#125;;function ObjTwo () &#123;&#125;ObjTwo.prototype.log = function()&#123;console.log(this)&#125;; sendInfo(new ObjOne()) sendInfo(new ObjTwo()) 现在我们增加一个对象就不需要修改 sendInfo里的代码了 123function ObjThere () &#123;&#125;ObjThere.prototype.log = function()&#123;console.log(this)&#125;;sendInfo(new ObjThere()) 类型检查和多态类型检查是再表现出对象多态性之前一个绕不开的话题，JavaScript 是一门不必进行类型检查的动态类型语言，为了真正了解多态的目的，须从静态语言说起。 以JAVA为例，由于在编译时会进行类型检查，所有不能给变量赋予不同类型的值。1234String str;str = 'ab'str =2 // error 将之前的例子换成 Java 123456789101112131415161718192021222324public class ObjOne &#123; public void log () &#123; System.out.println('a') &#125;&#125;public class ObjTwo &#123; public void log () &#123; System.out.println('b') &#125;&#125;public class SendInfo &#123; public void log (ObjOne objOne) &#123; objOne.log() &#125;&#125;public class Test &#123; public static void main (String args[] ) &#123; SendInfo sendInfo = new SnedInfo(); ObjOne objOne = new ObjOne() sendInfo(objOne) // 'a' ObjTwo objTwo = new objTwo() sendInfo(objTwo) // error &#125;&#125; 上述代码段中 sendInfo(objOne) 可以顺利输出，而sendInfo(objTwo)因为传入的类不同而报错，为了解决这一问题，静态类性的面向对象通常被设计为可向上转型：当给一个类变量赋值时，这个变量的类型既可以用这个类本身，也可以用这个类的超类 就像描述一只咖啡猫在跑、一只波斯猫在跑，如果忽略它们具体类型，可以说 一只猫在跑。 同理，当 ObjOne 和 ObjTwo 对象的类型都被隐藏在超类 Objects 身后时， ObjOne 和 ObjTwo就能被交换使用，这就让对象表现出多态性，这种表现正是实现众多设计模式的目标。要实现多态归根结底得先要消除类型之间的耦合关系。一个JavaScript对象即可表示ObjOne又可表示ObjThere,这意味着JavaScript对象的多态性是与生俱来的 多态在面向对象程序设计中的作用Martin Fowler 在重构一书中写到： 多态的最根本好处在于，你不必再向对象询问“你是什么类” 而后根据得到的答案调用对象的某个行为————你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。 多态最根本的作用就是把过程化的条件分支语句转化为对象的多态性，从而消除条件分支语句 就好比如在电影拍摄现场，导演喊出“action”时，每个人都做自己应该做的事，而不用导演走到每个人面前确认他们的职责，然后告诉他们该做什么。对象应该做什么并不是临时决定的，而是事先约定排练好的，每个对象该做什么，已经成为该对象的一个方法，被安装在对像内部，每个对像负责自己的行为，然后这些对象通过同一个消息，有条不紊的工作将行为分布在各个对象中，让他们各自负责自己的行为，这便是面向对象设计的优点。 继承使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”,被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。 使用继承来得到多态效果,是让对象表现出多态性最常用的手段。继承通常包括实现继承(使用基类的属性和方法而无需额外编码的能力)和接口继承( 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力)和可视继承(子窗体（类）使用基窗体（类）的外观和实现代码的能力) 注意： 使用继承时,两个类之间的关系应该是“属于”关系。 将上述JAVA例子进一步封装 1234567891011121314151617181920212223242526272829public abstract class Objects &#123; //抽象出一个超类 abstract void log();&#125;public class ObjOne extends Objects &#123; public void log () &#123; System.out.println('a') &#125;&#125;public class ObjTwo extends Objects &#123; public void log () &#123; System.out.println('b') &#125;&#125;public class SendInfo &#123; //让 log 方法接收 Objects 类 public void log (Objects objects) &#123; objects.log() &#125;&#125;public class Test &#123; public static void main (String args[] ) &#123; SendInfo sendInfo = new SnedInfo(); Objects objOne = new ObjOne(); Objects objTwo = new objTwo(); sendInfo(objOne) // 'a' sendInfo(objTwo) // 'b' &#125;&#125; 上述代码段中 ObjOne 和 ObjTwo 继承自 Objects 类即可通过这个桥梁来使用对应的方法。 封装封装是实现面向对象程序设计的第一步，将数据或函数等集合在一个个单元中（在java中称之为类，JavaScript中就是一个函数对象） 封装是隐藏数据、实现细节、设计细节以及对象的类型等，是代码模块化；是把过程和数据包围起来，只能通过已定义的方法访问数据。把客观事物封装成抽象的类，并且只对可信的类或对象来操作这个类的数据和方法，而对不可信的对象进行信息隐藏 封装的意义： 保护数据成员，不然其他对象或类直接访问或修改，只能通过提供的接口访问，防止用户无意破坏（数据封装） 方法的细节对外是隐藏的，只要接口不变，内容的修改不会影响到外部的调用这（封装实现） 封装数据在许多语言的对象系统中，封装数据是由语法解析来实现的比如 JAVA 提供了 public 、private、protected等关键字来设置不同的访问权限。 JavaScript 中并没有提供这些关键字，只能依赖作用域来实现封装特性，而且只能模拟出 public、和private1234567891011121314let myObject=(()=&gt;&#123; let __name = "owen"; // private return &#123; // publice 对象 getName()&#123; return __name &#125;, setName(value)&#123; return __name = value &#125; &#125;&#125;)()myObject.getName() // "owen"myObject.setName('gao')myObject.getName() // "gao" ES6 中除了 let 、const 外还可使用 Symbol 类型建立私有属性 封装实现封装使对象内部的变化对其他对象或类而言是透明不可见的，对象对他自己的行为负责，其他对象或类不用关心他内部的实现，对象之间只通过暴露 API接口来通信。 比如 Array中的forEach 方法遍历一个聚合对象，我们不用关心 forEach 内部是争议实现的，只要它提供的功能正确就行，即使修改它内部的代码，只要调用方式没有变化就不用关系它内部实现的改变 12let arr = [1,2,3]arr.forEach(val =&gt; console.log(val)) 封装在更重要的层面体现为封装变化《设计模式》一书曾提到： 考虑你的设计中哪些地方可能变法，这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变，而是考虑你怎么样才能够在不重新设计的情况下进行改变。这里的关键在于封装发送变化的概念，这是许多设计模式的主题 《设计模式》一书中归纳总结了23种设计模式，从意图上可将这些模式划分为 创建型模式、结构型模式和行为型模式。 通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统演变过程中，只需替换哪些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易；这样可以很大程度的保证程序的稳定性或可扩展性。 面向对象基本原则单一职责原则（Single Responsibility Prunciple） 一个类只允许有一个职责，即只有一个导致该类变更的原因。 简单来说一个类只专注做一件事。并不是说一个类只有一个函数，而是说这个类中的函数所做的工作必须高度相关（高内聚） 不过这个原则很容易违背，因为可能由于某种原因，原来功能单一的类需要被细化成颗粒更小的职责1跟职责2，不过这个拆的粒度可能因人而已，有时候并不需要拆的过细，不要成了为设计而设计。所以在每次迭代过程中可能需要重新梳理重构之前编写的代码，将不同的职责封装到不同的类或者模块中。 优点： 类的复杂性降低，实现什么职责都有清晰明确的定义,可读性提高，可维护性提高； 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。 开发关闭原则（Open Closed Principle） 一个软件实体应该是可以扩展的，但是不可修改。 在软件开发过程中，永远不变的就是变化。因此当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象。优点： 增加稳定性。 可扩展性高。 里氏替换原则 （Liskov Substitution Principle） 子类必须能够替换掉它们的基类，而程序执行效果不变。 所有使用基类代码的地方，如果换成子类对象的时候还能够正常运行，则满足这个原则，否则就是继承关系有问题，应该废除两者的继承关系，这个原则可以用来判断我们的对象继承关系是否合理。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法. 优点： 提高代码的重用性； 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性； 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，很多开源框架的扩展接口都是通过继承父类来完成的； 可以用来判断我们的对象继承关系是否合理,约束继承在使用上的泛滥。 缺点： 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束； 增强了耦合性。当父类的常量、变量和方法被修改时，必需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大片的代码需要重构。 依赖倒置原则 （Dependence Inversion Principle） 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 我们经常说“针对接口编程”，这里的接口就是抽象，我们应该依赖接口，而不是依赖具体的实现来编程。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖 高低应该是从开发者当前的角度来看的，不过DIP原则从不同角度来看它都适合且需要被遵守。假如我们高层模块直接依赖于底层模块，带来的后果是每次底层模块改动，高层模块就会受到影响，整个系统就变得不稳定，这也违反了开放关闭原则。 通常我们会通过引入中间层的方式来解决这个问题，这个中间层相当于一个抽象接口层，高层模块和底层模块都依赖于这个中间层来交互，这样只要中间抽象层保持不变，底层模块改变不会影响到高层模块，这就满足了开放关闭原则；而且假如高层模块跟底层模块同时处于开发阶段，这样有了中间抽象层之后，每个模块都可以针对这个抽象层的接口同时开发，高层模块就不需要等到底层模块开发完毕才能继续了。 优点： 通过抽象来搭建框架，建立类和类的关联，以减少类间的耦合性。而且以抽象搭建的系统要比以具体实现搭建的系统更加稳定，扩展性更高，同时也便于维护。 接口隔离原则 （Interface Segregation Principle） 多个特定的客户端接口要好于一个通用性的总接口。 应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。 需要注意的是：接口的粒度也不能太小。如果过小，则会造成接口数量过多，使设计复杂化。优点： 避免同一个接口里面包含不同类职责的方法，接口责任划分更加明确，符合高内聚低耦合的思想。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 迪米特法则 （Law Of Demeter） 或 最少知识原则（Least Knowledge Principle） 一个对象应该对其他对象有最少的了解;一个类应该对自己需要耦合或调用的类知道得最少。类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。优点： 降低复杂度；降低耦合度；增加稳定性。 减少类与类之间的关联程度，让类与类之间的协作更加直接。]]></content>
      <categories>
        <category>design patterns</category>
      </categories>
      <tags>
        <tag>Pattern intro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 学习]]></title>
    <url>%2F2019%2F07%2F05%2Fnginx%2F</url>
    <content type="text"><![CDATA[什么是 Nginx Nginx 是一款轻量级高性能的web 和 反向代理服务器，类似于Apache，也是一个 IMAP/POP3/SMTP （电子邮件）代理服务器。，由俄罗斯程序设计师 Igor Sysoev开发；在高连接并发的情况下，Nginx能够支持高达 50000 个并发连接数的响应，是 Apache 服务器不错的替代品。 nginx做为HTTP服务器，有以下几项基本特性： 1. 处理静态文件，索引文件以及自动索引；打开文件描述符缓冲． 2. FastCGI和反向代理加速(无缓存)，简单的负载均衡和容错． 3. 模块化的结构。包括gzipping, byte ranges, chunked responses,以及 SSI-filter等filter。如果由FastCGI或其它代理服务器处理单页中存在的多个SSI，则这项处理可以并行运行，而不需要相互等待。 4. 支持SSL 和 TLSSNI． Nginx支持热部署。它的启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。nginx是异步的，多个连接（万级别）可以对应一个进程。 apache是同步多进程模型，一个连接对应一个进程；nginx的优势是处理静态请求，cpu内存使用率低，apache适合处理动态请求，所以现在一般前端用nginx作为反向代理抗住压力，apache 作为后端处理动态请求。 正向代理： 服务器代理客户端向服务端发送请求，并将数据分发给客户端，服务端无法知道客户端的信息反向代理： 服务器代理服务端接收客户端的请求，并分发给服务器（分布式部署），反向代理隐藏了服务器的信息。负载均衡： 客户端发送的、Nginx反向代理服务器接收到的请求数量，就是负载量。请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则，即代理服务器将请求按一定的规则分发的过程就是负载均衡。 安装下载点击进入官网下载 Windows版本,解压至 C盘 启动双击 nginx.exe 或者 打开 CMD 进入 nginx 目录 输入 start nginx,如果启用防火墙，允许访问即可 常用命令须使用CMD 进入跟目录才能使用 nginx12345nginx -h //查看帮助nginx -v // 查看版本nginx -s stop //停用nginx -s reload //重载配置，重启进程nginx -s reopen //重启日志 代理配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#user nobody;#开启进程数 &lt;=CPU数 worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#进程号保存文件 #pid logs/nginx.pid;events &#123; #每个进程最大连接数（最大连接=连接数x进程数）每个worker允许同时产生多少个链接，默认1024 worker_connections 1024; &#125;http &#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #日志文件输出格式 这个位置相对于全局设置 #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #请求日志保存位置 #access_log logs/access.log main; #打开发送文件 sendfile on; #tcp_nopush on; #keepalive_timeout 0; #连接超时时间 keepalive_timeout 65; #打开gzip压缩 #gzip on; server &#123; #监听端口，默认是80端口 listen 80; #监听域名 server_name localhost; #charset koi8-r; #nginx访问日志放在logs/host.access.log下，并且使用main格式（可以自定义格式） #access_log logs/host.access.log main; #如果没有location更明确的匹配访问路径的话，访问请求都会被该location处理 location / &#123; #root指定nginx的根目录为/usr/local/nginx/html root html; #默认访问文件，欢迎页先去html目录下找index.html，如果找不到再去找index.htm index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # #错误页面及其返回地址，错误码为500、502、503、504都会返回50.html错误页面 error_page 500 502 503 504 /50x.html; #location后面是"="的话，说明是精确匹配 location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 要监听多个端口和域名 可配置多个 server。 参考文章:Nginx 中文文档Nginx 相关介绍深入浅出Nginx]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[performance]]></title>
    <url>%2F2019%2F07%2F03%2Fperformance%2F</url>
    <content type="text"><![CDATA[for,for…of, for…in, array iteration 运行速度 由于不同浏览器，不同版本性能不一，且控制台本质是是套用了一大堆eval，沙盒化程度高,所以需使用node环境测试来提高准确性12345678910111213141516171819// 准备待测数组const NUM = 1e7;let arr = new Array(NUM).fill(1);// for 测试let arr1 =[];console.time('for');for (let i = 0; i &lt; arr.length; i++) &#123; arr1.push(arr[i])&#125;console.timeEnd('for');// Chrome/75.0.3770.100 Safari/537.36 环境//VM1324:10 for: 576.733154296875ms// node v10.11.0 环境 // for: 412.087ms for 几种写法 常规写法 123456let arr1 = []console.time('one')for (let i = 0; i &lt; arr.length; i++ )&#123; arr1.push(arr[i])&#125;console.timeEnd('one') 数组长度是会动态变化，每次循环会重新计算length长度，可能会出现死循环 cache arr.length 123for (let i = 0, len = arr.length; i &lt; len; i++ )&#123; arr1.push(arr[i])&#125; 缓存length 值，无需重新计算length 倒序 123for (let i = arr.length-1; i &gt;= 0; i--)&#123; arr1.push(arr[i])&#125; 比第二种方法更简洁 倒叙简洁版 123for (let i = arr.length-1; i--;)&#123; arr1.push(arr[i])&#125; 两个分号之间的表达式为 true 会一直执行直到 判断为 false (i = 0) 正序简洁版 123for (let i = 0, len;len = arr[i++]; )&#123; arr1.push(arr[i])&#125; 当 i 大于等于数组长度或arr[i++]值为false时 将停指循环，同时由于arr.length动态变化时可能会造成死循环 for…of123for (let value of arr)&#123; arr1.push(value)&#125; es6推出的迭代器，最简洁，可以是用 break，continue和return 终止循环 for…in123for (let key in arr)&#123; arr1.push(arr[key])&#125; for…in 一般用于遍历对象，他会将本身属性和原型链上的属性（除系统内置属性）全部遍历出来即便是不可枚举属性（enumerable:false), 可以通过 items.hasOwnProperty来遍历本身属性,由于查询到自己的原型链上，所以性能方面比较差 forEach123arr.forEach(function(value)&#123; arr1.push(value)&#125;) 数组的迭代方法，没有返回值 map123arr.map(function(value)&#123; return arr1.push(value)&#125;) 浅拷贝原数组，并且返回一个新数组 性能测试 测试次数 常规for cache for 倒序 for 倒叙简版 for 正序简版 for for..of for..in forEach map 1 542.121ms 573.618ms 764.181ms 755.961ms 571.464ms 945.199ms 4077.020ms 625.859ms 3573.946ms 2 430.008ms 541.933ms 524.474ms 668.276ms 553.475ms 897.442ms 4402.246ms 605.271ms 2732.859ms 3 409.531ms 661.765ms 534.167ms 655.481ms 600.939ms 1141.093ms 3806.704ms 584.712ms 2779.192ms 4 412.972ms 643.868ms 536.026ms 674.081ms 725.149ms 930.655ms 3201.387ms 599.780ms 3152.499ms 5 417.034ms 624.323ms 520.674ms 799.568ms 574.713ms 943.449ms 3261.512ms 587.182ms 2954.195ms 6 525.771ms 955.737ms 526.208ms 771.443ms 531.962ms 954.199ms 4351.009ms 608.264ms 2888.752ms 7 498.039ms 602.703ms 555.588ms 531.464ms 541.599ms 916.678ms 3264.334ms 596.168ms 2834.663ms 8 431.694ms 523.381ms 544.974ms 527.472ms 517.833ms 1049.283ms 3744.972ms 600.286ms 3467.499ms 9 417.521ms 518.093ms 547.404ms 611.024ms 594.503ms 767.059ms 4979.348ms 601.420ms 3638.023ms 10 424.806ms 557.961ms 535.541ms 837.561ms 541.882ms 772.686ms 3284.424ms 602.443ms 3599.642ms 11 409.402ms 521.131ms 534.265ms 517.709ms 551.397ms 752.101ms 3228.123ms 629.625ms 3535.545ms 12 425.362ms 532.882ms 406.637ms 522.287ms 570.259ms 914.135ms 3449.256ms 800.857ms 3429.123ms 平均值 439.2738ms 578.3565ms 553.1468ms 651.7057ms 507.8718ms 909.0785ms 3,686.96ms 605.6298ms 3,221.5056ms 堆值差 357245536 Byte 357245808 Byte 357245624 Byte 357245872 Byte 357246824 Byte 199268080 Byte 757187208 Byte 357244456 Byte 437247640 Byte 测试总结 运行效率: 常规for &gt; 正序简版 for&gt; 倒序 for &gt; cache for &gt; 倒叙简版 for&gt; forEach &gt; for..of &gt; map &gt; for..in 几种普通 for 循环占用内存相差不大, 而 for..of 占用运行内存最小 for..in 性能最差，内存占用高，速度很慢]]></content>
      <categories>
        <category>JavasSript</category>
      </categories>
      <tags>
        <tag>Iteration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[timer]]></title>
    <url>%2F2019%2F06%2F28%2Ftimer%2F</url>
    <content type="text"><![CDATA[什么是定时器 在一段时间间隔后执行一个函数或执行一段代码的方法 JavaScript 原生提供几种定时器 setInterval、setTimeout 、requestAnimationFrame 执行函数中的作用域未全局作用域this指向全局，可通过 bind 方法给执行函数传递参数或指定作用域 (严格模式下，setTimeout( )的回调函数里面的this仍然默认指向window对象， 并不是undefined) setInterval 每相隔一段时间间隔执行一个函数或执行一段代码的方法 通过clearInterval方法来取消定时器12let timerInterID = window.setInterval(callback,delay[,param...]) setTimeout( clearInterval.bind(null,timerInterID),1000) 参数 callback 重复执行的函数或代码段（不推荐使用一段字符串构成的代码，应为这样做不安全，会被不法分子利用） delay 时间间隔，单位为毫秒（ms）实际间隔可能会稍长（最小间隔是4ms） timerInterID 每次调用setInterval方法返回的唯一 ID，可通过调用 clearInterval方法来清除setInterval方法 param1, …, paramN 传递给执行函数（callback）的参数 (IE9 及更早的 IE 浏览器不支持向回调函数传递额外参数。如果你想要在IE中达到同样的功能,你必须使用一种兼容代码 ) setTimeout 在一段时间间隔后执行一个函数或执行一段代码的方法 通过clearTimeout方法来清除定时器1let timerTimeID = setTimeout(callback,delay[,param1, ..., paramN ]) 参数 callback 重复执行的函数或代码段（不推荐使用一段字符串构成的代码，应为这样做不安全，会被不法分子利用） delay 时间间隔，单位为毫秒（ms），默认为0实际间隔可能会稍长（最小间隔为 4ms ） timerTimeID 每次调用setTimeout方法返回的唯一 ID，可通过调用 clearTimeout方法来清除setTimeout方法 param1, …, paramN 传递给执行函数（callback）的参数 (IE9 及更早的 IE 浏览器不支持向回调函数传递额外参数。如果你想要在IE中达到同样的功能,你必须使用一种兼容代码 ) requestAnimationFrame 类似于setInterval方法，执行动画时推荐使用 会在浏览器下次重绘前执行函数 执行间隔通常是每秒60次，当运行在后台标签页或隐藏在 iframe时，会暂停调用12let frameID = window.requestAnimationFrame(callback)setTimeout(cancelAnimationFrame.bind(null,FrameID),1000) 参数 callback 更新动画帧所调用的函数 一帧大约 16.7ms 兼容性]]></content>
      <categories>
        <category>JavasScript</category>
      </categories>
      <tags>
        <tag>timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包（closure）]]></title>
    <url>%2F2019%2F06%2F27%2Fclosure%2F</url>
    <content type="text"><![CDATA[什么是闭包（closure）？在理解闭包前，须理解变量作用域。作用域分全局和局部作用域，是指代码中定义变量的区域。(变量有效访问的范围。) 静态作用域 静态作用域又叫做词法作用域，采用词法作用域的变量叫词法变量。词法变量有一个在编译时静态确定的作用域。(JavaScript 采用的是词法作用域) 词法变量的作用域可以是一个函数或一段代码，该变量在这段代码区域内可见（visibility）；在这段区域以外该变量不可见（或无法访问）。词法作用域里，取变量的值时，会检查函数定义时的文本环境，捕捉函数定义时对该变量的绑定。 动态作用域 动态作用域的变量叫做动态变量。程序正在执行定义了动态变量的代码段，那么在这段时间内，该变量一直存在；代码段执行结束，该变量便消失。(函数的作用域在函数调用时才决定。)动态作用域里，取变量的值时，会由内向外逐层检查函数的调用链，并打印第一次遇到的那个绑定的值。显然，最外层的绑定即是全局状态下的那个值。 变量无权访问子作用域，只能访问自己和父级以上的作用域 12345678910var name = "Owen"; // 全局变量var sex = "Man";function person()&#123; console.log(name) // "Owen" var age = "18" var sex = "man"; console.log(sex) // "man" 优先访问 局部变量 sex&#125;person()console.log(age) // age is not defined 无法访问 person 中的 age 局部变量 预编译当函数执行时，会创建一个执行期上下文(即作用域)的对象AO(存储在[[scope]]中), 一个新的AO指向 定义了一个函数执行时的环境。函数执行时对应的AO, 是独一无二的，每次调用函数就创建一个OA， 函数执行完毕 AO的指向就会销毁 [[scope]]: 每个函数都是对象，对象中有些属性可访问，有些不可以，[[scope]]就不可访问，它存储了运行期上下文的集合([GO,AO])。作用域链：就是[[scope]]中所存储的AO对象集合，呈链式链接 查找变量：函数刚定义就存储了 所在环境的执行期上下文,执行时 创建自己的AO 123456789101112131415161718192021222324252627function fun (a)&#123; console.log(a);// function var a=123; function a ()&#123;&#125;; console.log(a)// 123 函数声明已提升所以不用管 var b =function()&#123;&#125;; console.log(b);//function 因为是函数表达式，只提升了 变量b， 这样的函数体不会提升&#125;fun(1); //函数 123 123 函数/*代码执行1. 会创建 一个（全局为GO）AO(Activation Object)对象（执行期上下文/作用域）一个存储空间库2. 找形参和变量声明，将形参和变量名作为AO的属性名，值为undefined,重复的只用写一个3. 将实参值和形参统一4. 在函数体里找函数声明，值为函数体5. if/return 不用管 声明还是会提升AO&#123; a:function a ()&#123;&#125;; b:undefined&#125;记住函数是一等公民权限最高*/ 函数内部声明变量的时候，一定要使用var，let or const命令。如果不用的话，你实际上声明了一个全局变量！ 变量的生命周期内存生命周期： 分配你所需要的内存 使用分配到的内存（读, 写） 不需要时将其释放/归还 全局变量可永久访问，除非主动销毁，而局部变量在函数运行结束时就会随之销毁，当局部变量还能被外界访问时，将会保留，不被销毁 闭包简单理解：在Javascript语言中，只有函数内部的子函数才能访问该函数的变量，而定义在一个函数内部的函数并且外部能接收到这个函数，那么这个函数就是闭包。(能够读取其他函数内部变量的函数。) 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。 特点： 函数套函数，并且外部能访问嵌套函数。 父函数被销毁 的情况下，子函数的[[scope]]中仍然保留着父级的变量对象和作用域链，因此可以继续访问父级的变量对象,进而改变父作用域内部的变量值 占用内存，过多使用会产生性能问题，在IE中可能会导致内存泄漏。（可在销毁函数前，将无用的变量删除） 1234567891011121314151617// 例一function A() &#123; let a = 1 B = function () &#125;&#125;A()B() // 1//例二function A() &#123; let a = 1 return function () &#123; console.log(a) &#125;&#125;A()()//1 闭包与内存泄漏 内存泄漏是指，页面随着时间的延长使用的内存越来越多而没有及时释放。 javascript中 不需要开发人员像C语言一样手动使用 malloc()分配内存，也不需要用完后使用free()回收；而是使用垃圾回收策略来自动管理内存，即找出那些不再使用的值，然后释放所占用的内存。 垃圾回收只针对局部变量进行回收销毁，全局变量只有网页关闭才会消除。垃圾回收有两种方法引用计数和标记清除垃圾回收算法主要依赖于引用的概念 什么是引用：在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。 引用计数 引用计数是跟踪记录每个值被引用的次数。即看一个对象是否有指向它的引用。如果没有其他对象指向它（零引用），说明该对象已经不再需要了。123456let obj = &#123; name:'owen'&#125;// 此时 对象 &#123; name:'owen' &#125; 被创建并引用一次obj = null// 此时 对象引用次数为零，将被回收机制销毁 引用计数有一个循环引用的问题：如果两个对象互相引用，它们的引用次数永远不会为零，将永远不会被回收，从而占据内存12345678910111213function obj()&#123; let obj1 = &#123; name:'owen'&#125;// 此时 对象 &#123; name:'owen' &#125; 被创建并引用一次let obj2 = &#123;&#125;obj2.name = obj1obj1.name = obj2// 此时 两个对象相互引用 ，俩个对象引用次数为二，永远也不会被收回&#125;obj() 标记清除 现代浏览器常用的方法，当变量进入环境时（例如，在函数中声明一个变量），这个变量标记为“进入环境”；而当变量离开环境时，则将其标记为“离开环境”。 把”对象是否不再需要”简化定义为”对象是否可以获得”。如把JavaScript想象一个树，每个JS都存在一个根(浏览器中为window对象,Node中为global对象 )，每当一个函数执行，就会生成一个节点。嵌套的函数调用就会有子节点。当函数执行完时，内部的变量都是无法被其他代码访问的，所以它就被标记为“无法被访问”。GC 时，JS 引擎统一对所有这些状态的对象进行回收。当进行一轮垃圾回收时，主线程会被阻塞，各个浏览器的时间不同可能是10ms、50ms、1s 应用封装变量将不需要暴露在全局的变量封装成”私有变量”。 1234567891011121314151617181920212223// 乘积let mult = (...args) =&gt;&#123; let num = 1; for (let val of args )&#123; num *= val; &#125; return num;&#125;// 由于每次运行函数都会完全遍历所以形参，效率较低下，我们可以加入缓存机制提供函数性能let mult1 = (()=&gt;&#123; let cache = &#123;&#125;; return (...args) =&gt; &#123; if(cache[args.join(',')]) return cache[args.join (',')]; let num = 1; for (let val of args )&#123; num *= val; &#125; return cache[args.join(',')]= num; // 缓存数值 &#125;&#125;)()// 我们看到 cache 变量仅仅在 mult 函数中使用，我们可以将它封装在函数内部，减少全局变量，变量发生不必要的错误 如果一个大函数中有些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里并有个良好的命名，将有助于复用，和注释作用；如果小函数不需要在其他程序中使用，最好使用闭包封装起来123456789101112131415let mult1 = (()=&gt;&#123; let cache = &#123;&#125;; let calculate = (...args)=&gt; &#123; let num = 1; for (let val of args )&#123; num *= val; &#125; return num &#125; return (...args) =&gt; &#123; let property = args.join(',') if(cache[property]) return cache[property]; return cache[property]= calculate.apply(null,args); // 缓存数值 &#125;&#125;)() 延续变量12345678910111213141516171819// img案例let imgSrc = (src) =&gt; &#123; let img = new Image(); img.src = src;&#125;imgSrc('http://xxxx.com/img')// 在一些低版本浏览器中使用 imgSrc 函数，会丢失一些数据，因为当函数调用结束后 img变量会随之销毁，此时可能未及时发出HTTP请求// 使用闭包解决数据丢失问题let imgSrc = (function ()&#123; let imgs = []; return function (src)&#123; let img = new Image(); imgs.push(img) img.src = src;&#125;&#125;)()imgSrc('http://xxxx.com/img') 三种方法解决循环中 var 定义函数的问题123456789101112131415161718192021//one 利用闭包for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)(i);&#125;//two 设置第三个参数for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer(j) &#123; console.log(j) &#125;, i * 1000,i)&#125;//three 利用 letfor (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer(i) &#123; console.log(i) &#125;, i * 1000)&#125; 因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候i 就是 固定了，所以会输出一堆 固定值。 函数中的this对象普通函数this 指向取决于 调用它时处在的执行上下文 对于new 的方式来说，this 被永远绑定在了赋值变量上面，不会被任何方式改变 this箭头函数箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this 否则指向全局。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fetch]]></title>
    <url>%2F2019%2F06%2F24%2Ffetch%2F</url>
    <content type="text"><![CDATA[fetch 一个获取资源的接口，类似于ajax 是基于 Promise之上设计，旧版本IE 完全不支持，须借助 polyfill来兼容 提供了对 Request 和 Response （以及其他与网络请求有关的）对象的通用定义 发送请求或者获取资源，需要使用 window.fetch or WindowOrWorkerGlobalScope.fetch 方法。 参数资源路径（url string） 他必须接收一个需要请求的资源路径，返回一个promise对象，请求成功的数据返回到Responese回调中，请求失败的信息返回到 Request中。 当接收到一个代表错误的 HTTP状态码时，fetch返回的promise不会被标记为 reject而会被标记为resolve，比如状态码为 404，500.只有网络故障或请求被阻止时才被标记为reject 1234567fetch('https://api.apiopen.top/musicDetails1') .then(function(response) &#123; return response.json(); &#125;) .then(function(myJson) &#123; console.log(myJson); //&#123;code: 400, message: "404 Not Found", result: "https://api.apiopen.top/musicDetails1"&#125; &#125;) fetch 默认是不会从服务端发送接收或发送任何 cookie,如果需要则必须设置 credentials,自 2017/8 起默认的credentials政策变更为same-originFirefox也在61.0b13中改变默认值 [, config] 配置项对象，包括所有对请求的设置 method: 请求使用的方法，如 GET、POST。 headers: 请求的头信息，形式为 Headers 的对象或包含 ByteString值的对象字面量。 body: 请求的 body信息： 可能是: Blob（ 表示一个不可变、原始数据的类文件对象）、BufferSource （ 用于表示自身为ArrayBuffer或者TypedArray提供对象的对象ArrayBufferView。）、 FormData（表示表单数据的键值对的构造方式，经过它的数据可以使用XMLHttpRequest.send() 方法送出，本接口和此方法都相当简单直接。如果送出时的编码类型被设为 “multipart/form-data”，它会使用和表单一样的格式。）、 URLSearchParams （接口定义了一些实用的方法来处理 URL 的查询字符串） 或者 USVString 对象。 注意GET 或HEAD方法的请求不能包含 body 信息。 mode: 请求的模式，如 cors、 no-cors 或者 same-origin。 credentials: 请求的 credentials，如 omit、same-origin 或者 include。为了在当前域名内自动发送 cookie ， 必须提供这个选项， 从 Chrome 50 开始， 这个属性也可以接受 FederatedCredential 实例或是一个 PasswordCredential 实例。 如果需要跨域请求需设置为 “include” 如果只在同域内发送cookie 则设置为 “same-origin” 如果任何情况都不发送cookie 则设置为 “omit” cache: 请求的 cache 模式: default 、 no-store 、 reload 、 no-cache 、 force-cache 或者 only-if-cached 。 redirect: 可用的redirect 模式:follow(自动重定向), error (如果产生重定向将自动终止并且抛出一个错误), 或者manual (手动处理重定向). 在Chrome中，Chrome 47之前的默认值是 follow，从 Chrome 47开始是manual。 referrer: 一个USVString 可以是 no-referrer、client或一个URL。默认是client。 referrerPolicy:指定引用HTTP头的值。可能是一个 no-referrer、 no-referrer-when-downgrade、 origin、 origin-when-cross-origin、 unsafe-url 。 integrity: 包括请求的subresource integrity值（例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=）。 12345678910111213141516171819202122232425262728293031const Fetch = function (url,config)&#123; if(typeof(config) !== 'object' || config === null) return throw `Config needs to pass an object type` let data = config || &#123;&#125; ; let &#123;method = 'GET', param = null, mode = "cors", cache = "no-cache",headers = &#123;'Access-Control-Allow-Origin': '*', 'content-type': 'application/json'&#125;, redirect = "follow", credentials = "include", referrer = "no-referrer"&#125; = data; /* // 传输 JSON 数据 需将 param 转换 JSON.stringify(param) //上传文件 需传输 formData 格式 let formData = new FormData() let fileField = document.querySelector("#myFile") formData.append('title',"My File") formData.append('fileField ',fileField .files[0]) */ return fetch(url,&#123; method:method.toUpperCase(), body:param, mode, cache, headers, redirect, credentials,&#125;).then(res =&gt;&#123; if(res.ok) return res.json() throw new Error("Network response fail："+res.status)&#125;).catch(err=&gt;console.error(err))&#125;Fetch('https://api.apiopen.top/musicDetails1',&#123;credentials:'omit'&#125;).then(res =&gt;console.log(res)).catch(err=&gt;console.error(err)) Headers constructor 创建一个 headers 对象 一个 headers 对象是一个简单的多名值对：12345let content = "Hello World";let myHeaders = new Headers();myHeaders.append("Content-Type", "text/plain");myHeaders.append("Content-Length", content.length.toString());myHeaders.append("X-Custom-Header", "ProcessThisImmediately"); 可以传一个多维数组或者对象字面量：123456789101112131415161718let content = "Hello World";let myHeaders = new Headers(&#123; "Content-Type": "text/plain", "Content-Length": content.length.toString(), "X-Custom-Header": "ProcessThisImmediately",&#125;);//获取和设置console.log(myHeaders.has("Content-Type")); // trueconsole.log(myHeaders.has("Set-Cookie")); // falsemyHeaders.set("Content-Type", "text/html");myHeaders.append("X-Custom-Header", "AnotherValue"); console.log(myHeaders.get("Content-Length")); // 11console.log(myHeaders.getAll("X-Custom-Header")); // ["ProcessThisImmediately", "AnotherValue"] myHeaders.delete("X-Custom-Header");console.log(myHeaders.getAll("X-Custom-Header")); // [ ] 如果使用了一个不合法的HTTP Header属性名，那么Headers的方法通常都抛出 TypeError 异常。如果不小心写入了一个不可写的属性，也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。 检查 content type 是否正确123456789fetch(myRequest).then(function(response) &#123; if(response.headers.get("content-type") === "application/json") &#123; return response.json().then(function(json) &#123; // process your JSON further &#125;); &#125; else &#123; console.log("Oops, we haven't got JSON!"); &#125;&#125;); Response 对象 fetch 返回的对象 对象中常用的属性 status： 响应状态码 如 200 404 等 statusText：返回和状态码对应信息 ok 检查状态码是否 在 200-299之间，返回true or false 检查环境支持度12345if(this.fetch) &#123; // run my fetch request here&#125; else &#123; // do something with XMLHttpRequest?&#125; 兼容性 Fetch规范]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[filter]]></title>
    <url>%2F2019%2F06%2F21%2Ffilter%2F</url>
    <content type="text"><![CDATA[filter 将模糊或者颜色偏移等图像效果用于元素，通常用于调整图像，背景和边框的渲染 css 标准中已内置一些预定义效果的函数，也可通过url使用SVG滤镜 语法12345678910111213141516171819202122/* URL to SVG filter */filter: url(filter.svg#id);/* &lt;filter-function&gt; values */filter: blur(5px);filter: brightness(0.4);filter: contrast(200%);filter: drop-shadow(16px 16px 20px blue);filter: grayscale(50%);filter: hue-rotate(90deg);filter: invert(75%);filter: opacity(25%);filter: saturate(30%);filter: sepia(60%);/* Multiple filters */filter: contrast(175%) brightness(3%);/* Global values */filter: inherit;filter: initial;filter: unset; 滤镜属性 需要设定某一函数的值。如果该值无效，函数返回“none“。 url() url 函数接收一个XML文件，该文件是一个SVG filter，并且包含一个ID值 来指定哪一个滤镜1filter:url(resources.svg#c1) blur() 定义模糊度 可以接受css长度单位，不接受百分比1filter:blur(5px) brightness() 定义亮度 默认为1， 1-0 逐渐变暗，1以上逐渐变亮 可以是百分比， 不能为负数 contrast() 定义对比度 1-0 逐渐变成灰黑 1以上颜色逐渐变艳丽 可以是百分比， 不能为负数 drop-shadow() 定义阴影效果，合成在图像下面， 参数 和 shadow, box-shadow 相似 和shadow, box-shadow属性不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。 传参顺序从左至右： 水平偏移距离正值右偏，负值左偏（offset-x）。必传 垂直偏移距离正值向下偏，负值上偏（offset-y）。必传 一个length值(表示距离尺寸的一种css数据格式) 值越大，越模糊阴影会变得更大更淡.）不允许负值 默认为0 （blur-radius）可选 一个length值，正值会使阴影扩张和变大，负值会是阴影缩小，默认 0 color 色值，在Gecko (Firefox), Presto (Opera)和Trident (Internet Explorer)中， 会应用color 属性的值,颜色值省略，WebKit中阴影是透明的。 1filter:drop-shadow(16px 16px 10px black) grayscale() 定义灰度 取值0 - 1的数值之间，可设置百分比，不可为负数1filter:grayscale(50%); hue-rotate() 定义颜色，色相旋转调整 单位 deg 可为负值 1filter: hue-rotate(90deg) invert() 反向输入图，定义转换比例 默认0 0%和100%之间，则是效果的线性乘子。1filter: invert(100%) opacity() 转化图像的透明程度 类似于css的opacity属性 1-0 逐渐变透明，支持百分比 ，不能为负数 和opacity属性不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。1filter: opacity(50%) saturate() 定义图像饱和度 1-0 至完全不包和，1为正常， 1以上饱和度更高，更艳丽，支持百分比 1filter:saturate(369%) sepia() 定义深褐色的色度 0 - 1 逐渐变为深褐色 支持百分比，不支持负数 1filter: sepia(100%) 组合函数 可以将任意数量的函数一起控制渲染，其中有一个不符合规范将全部失效1filter:sepia(100%) saturate(369%) opacity(50%) 兼容性]]></content>
      <tags>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setProperty]]></title>
    <url>%2F2019%2F06%2F18%2FsetProperty%2F</url>
    <content type="text"><![CDATA[css3 原生 var 变量 可以降低维护成本，有更高性能，文件更高压缩率。 语法 声明 --* * 表示变量名称，对于命名不能包含特殊字符（ $，[，^，(，% ）等等 必须在块级（{}）区域内声明,且只能给属性名的值，设值，不能给属性设置123:root &#123; --color: purple; &#125; 使用 通过var(x,y)函数调用 函数的可选第二个参数用作回退值。如果第一个参数引用的自定义属性无效，则该函数将使用第二个值。123div &#123; color: var(--color);&#125; CSS变量不合法的缺省特性 CSS变量，只要语法是正确的，就会作为正常的声明解析 如果发现变量值是不合法的，就让默认值代替123456789body &#123; --color: 20px; background-color: #fff; background-color: var(--color, #000);&#125;/* 等同于 */body &#123; background-color: transparen;&#125; CSS变量不合法的空格尾随特性 变量值后面会尾随空格,所以变量值最好加单位123456789body &#123; --width: 20; width: var(--width)px;&#125;/* 等同于 */body &#123; /* 宽度失效 */ width: 20 px; &#125; CSS变量的相互传递特性 声明CSS变量时候可以引入其他变量12345body &#123; --width: 20px; --width: var(--width); --height: calc( var(--width) / 10);&#125; 兼容性 setProperty 给一个样式设置新值 dom.style.setProperty(propertyName, value, priority); 参数 propertyName 必须是一个字符串，代表被更改的CSS属性。 value 对应 propertyName css 属性值。如果未传，则为空字符串 priority 设置css 的权重 “important” ,”undefined”, “” 如果不设置权重 则可简写为 dom.style.propertyName = &quot;value&quot; getPropertyPriority 获取一个样式属性的权重 dom.getPropertyPriority(&#39;property&#39;) 返回值 ‘important’ 或 ‘’ removeProperty 删除属性 dom.getPropertyPriority(&#39;property&#39;) 返回被删除的属性值 多个单词组成的属性要用连字符连接各个单词，不接收驼峰命名法的形式。 getComputedStyle 兼容 IE9及以上 获取当前元素所以最终使用的 CSS属性值 返回一个实时的 CSSStyleDeclaration 对象，当元素的样式更改时，它会自动更新本身。 语法 let styles = window.getComputedStyle(element, [pseudoElt]); element: Dom 元素 [pseudoElt]: 可选指定一个伪元素 （在Gecko2.0 (Firefox 4 / Thunderbird 3.3 / SeaMonkey 2.1)之前版本，参数pseudoElt是必要的。如果为null，则不指定其他主要浏览器必须指定此参数。Gecko已经更改为匹配其他浏览器的行为。） getComputedStyle 和 style 区别 element.style 同样可以获取 css 对象，可读写，而getComputedStyle(el) 只能读 element.style返回已设置的样式属性,而 getComputedStyle(el) 会将所有属性给返回getComputedStyle(el)element.style defaultView 此属性只读。 在浏览器中，document.defaultView 返回window与文档关联的对象，或者null如果没有可用的对象。 getComputedStyle 不仅挂载在 window对象上，而且还挂载在 defaultView对象上 因为在firefox3.6上访问（iframe)必须 defaultView对象上访问 css属性解析值（resolved value），计算值（computed value） 和 应用值（used value） 属于 getComputedStyle方法返回的值，大多数属性是一个计算值，有些是应用值 计算值（computed value） 子元素继承父元素的值，通过指定值计算出来 处理特殊的值 inherit(元素获取其父元素的计算值),initial(属性的初始默认值),unset(优先用 inherit 的样式，其次会应该用initial的样式) 进行计算，达到对应属性值的要求 计算值所需要的计算通常包括将相对值（em,rem %,)转换成绝对值（px） 应用值（used value） 完成所有计算后最终使用的值 计算出CSS属性的最终值有三个步骤 指定值（Specified value） 从样式表中接收（按权重规则来接收）未设置将使用继承值或者默认值 按规范算出计算值（span 指定 position: absolute 后display 变为 block） 计算布局（尺寸比如 auto 或 百分数 换算为像素值） 最后就是应用值， 只能使用 getComputedStyle来获取最终的应用值]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>setProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoomAndScale]]></title>
    <url>%2F2019%2F06%2F17%2FzoomAndScale%2F</url>
    <content type="text"><![CDATA[zoom 不是标准属性 对文字最小缩到 12pX 缩放位置相对于左上角缩放 调整时改变了元素占据的空间大小、尺寸，等比例缩放元素 *zoom:1 用来给老版本IE浏览器（IE6/7）清除浮动 由于缩小改变原来的空间尺寸，所以整个页面会重新渲染单位 百分比 zoom:50% 缩小到原来的一半 数值 zoom:0.5 等同 zoom:50%，不能为负数 zoom:normal 等同于 zoom:1 scale 等比例缩放元素 transform: scale(1) 对文字等比缩放 改变时不会从新渲染页面 默认居中缩放,原始尺寸不变 属于 w3c 规范 IE9以上都支持此属性 使用 transform 会覆盖以前的 transform 属性，即 以前 transform 对应的属性将被全部替换 可控制方向 transform:scale(x,y), transform:scaleX(x) or transform:scaleY(y)单位 只能是数值 可以为负数 chrome 中 同时使用两者效果会叠加transform 变换 支持 3D 变换 可以 拉伸，压缩，旋转，偏移目标元素 只能转换由盒子模型定位的元素。根据经验，如果元素具有display: block，则由盒模型定位元素。（转换行内元素，须设置display样式属性） 支持 IE10以上 IE9 需加私有前缀 -ms-（IE） -webkit-(chrome，safari) -o-（opera）-moz- （Firefox)类型skew 对目标对象进行歪斜变换 transform: skew() 参数 X,Y transform: skew(X,Y) 表示沿着 X轴和 Y轴 扭曲角度 默认为0 单位 degress (度) transform: skew(100deg,100deg) grad (百分度) transform: skew(10grad,10grad) rad（弧度） 一个完整的圆 为2π transform: skew(10rad,10rad) turn (圈数) 一个完整的圆 为1turn transform: skew(0.25turn，1.2turn) 可以为负数 scale 等比例缩放元素 transform: scale(1)单位 只能是数值 可以为负数 rotate 旋转元素 transform: rotate(x,y) 默认以目标对象中心为圆点转动单位同 skew translate 平移目标元素 transform: translate(x,y) 单位同 skew transition 平滑的改变CSS的值 只要CSS 属性值发生改变都会实现过渡效果 支持IE10 以上类型 transition-property 指定过度属性 transition-property:height height 就会参与过渡 transition-duration 指定持续时间 transition-duration:2s 指过渡持续 2S 单位 s (秒) ms(毫秒)transition-delay 过渡开始作用之前需要等待的时间。 transition-delay:0.2s 等待0.2S 后执行过渡单位 s (秒) ms(毫秒)transition-timing-function 指定动画运动时的节奏 transition-timing-function:ease 匀速运行 参数 ease ease-in 由慢到快 ease-out 由快到慢 ease-in-out 由慢到快在到慢 linear 线性过度 step-start step-end steps(5,end) 其它参数设置 transition 简写 transition: property-color duration timing-function; transition: height 0.3s ease; animations 用来指定一组或多组动画，每组之间用逗号相隔 支持IE10以上类型 -webkit-animation-name; 指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列 值 none 默认静止 定义 @keyframes 后的 名字 由大小写不敏感的字母a-z、数字0-9、下划线(_)和/或横线(-)组成。第一个非横线字符必须是字母，数字不能在字母前面，不允许两个横线出现在开始位置。举个栗子12345.cylon_eye &#123; -webkit-animation-name: resize;&#125;@-webkit-keyframes resize &#123; from &#123; margin-left: -20%; &#125; to &#123; margin-left: 100%; &#125; &#125; @keyframes resize &#123; from &#123; margin-left: -20%; &#125; to &#123; margin-left: 100%; &#125; &#125; -webkit-animation-duration 指定一个动画周期的时长 默认为 0 无动画 单位 s , ms -webkit-animation-duration: 1.5s; -webkit-animation-iteration-count 定义动画运行的次数 -webkit-animation-iteration-count:4 属性 默认运行一次 infinite 无限循环 播放的次数 不可为负值. 可以用小数定义循环(0.5 将播放动画到关键帧的一半 -webkit-animation-direction 指示动画是否反向播放 -webkit-animation-direction: alternate; 属性 normal 默认 每个动画循环结束，动画重置到起点重新开始 alternate 动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向 计数取决于开始时是奇数迭代还是偶数迭代 reverse 反向运行动画，每周期结束动画由尾到头运行。 alternate-reverse 动画第一次运行时是反向的，然后下一次是正向，后面依次循环。决定奇数次或偶数次的计数从1开始。 -webkit-animation-timing-function: ease-in-out;animation-timing-function 每一个动画周期中执行的节奏，作用于一个关键帧周期而非整个动画周期值同 transition-timing-function 简写语法 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写属性形式12345678910111213141516.cylon_eye &#123; background-color: red; background-image: linear-gradient(to right, rgba(0, 0, 0, .9) 25%, rgba(0, 0, 0, .1) 50%, rgba(0, 0, 0, .9) 75%); color: white; height: 100%; width: 20%;/* 调用动画 指定对应 持续时间 运动时的节奏 延迟时间 循环次数 对应动画 */ -webkit-animation: 4s linear 0s infinite alternate move_eye; animation: 4s linear 0s infinite alternate move_eye;&#125;/* 定义动画 */@-webkit-keyframes move_eye &#123; from &#123; margin-left: -20%; &#125; to &#123; margin-left: 100%; &#125; &#125; @keyframes move_eye &#123; from &#123; margin-left: -20%; &#125; to &#123; margin-left: 100%; &#125; &#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>zoom and transform:scale</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vueNotes]]></title>
    <url>%2F2019%2F06%2F13%2FvueNotes%2F</url>
    <content type="text"><![CDATA[初始渲染的钩子函数 created mounted 等 可以取到 data 中的数据，取不到 props 中的数据，可以通过 computed 或者 watch 属性监听变化 如果想要组件或者原生HTML节点重新渲染可以使用 v-if 使用 prototype 挂载自定义方法或插件 123Vue.prototype.$bus = Bus; // orVue.use(bus); 获取本机 IP 地址 12345678910111213141516171819202122const os = require('os');const ip = showObj(os.networkInterfaces());function showObj(obj)&#123;/* for (let devName in obj)&#123; let iface = obj[devName]; for (let i = 0;i &lt; iface.length;i++)&#123; let alias = iface[i]; if (alias.family === 'IPv4' &amp;&amp; alias.address !== '127.0.0.1' &amp;&amp; !alias.internal)&#123; return alias.address; &#125; &#125; &#125; */ for (let devName in obj)&#123; let iface = obj[devName]; for (let alias of iface )&#123; if ( alias.family === 'IPv4' &amp;&amp; alias.address !== '127.0.0.1' &amp;&amp; !alias.internal) return alias.address; &#125; &#125;&#125;]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>vue question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[array method]]></title>
    <url>%2F2019%2F05%2F20%2Farray%2F</url>
    <content type="text"><![CDATA[js 内置 7种类型 基本类型: string number boolean null undefined symbol 引用类型: object Array es3/es5:12345678910111213141516171819202122232425262728293031323334353637383940//改变原数组//push :向数组尾部添加数据 可添加多位//自定义pushArray.prototype.push =function()&#123; &#125;//pop :剪切尾部一项数据//unshift : 向数组前方添加数据//revesre : 翻转数组//splice : 第一个参数从第几位开始，第二个参数，截取几位，第三个参数覆盖截取的数据，返回截取的数据/* sort :排序一个函数为参数 ，同时 函数必须有两参数(a,b)1. 函数返回值为正时 b在a前面2. 为负数时 a在b前面3. 0 时 不动原理冒泡排序 */ var obj = [&#123;age:18,name:'1'&#125;,&#123;age:38,name:'1'&#125;,&#123;age:14,name:'1'&#125;,&#123;age:28,name:'1'&#125;], arr.sort(function(a,b)&#123; return a.age - b.age;//升序&#125;)//打乱有序的数组arr.sort(function(a,b)&#123; return Math.random() - 0.6;&#125;)//不改变原数组需要变量接收concat ： 拼接数组并返回 join : 将数组每一位以传进的参数链接slice : 第一个参数 开始截取为，第二个参数 截取到的位置//将类数组转化为数组 var arr=[].slice.call(arguments) string methods1234567891011121314151617var str ='123'str.split('');//camelize: 连字符转驼峰const camelizeRE = /-(\w)/gexport const camelize = cached((str: string): string =&gt; &#123; return str.replace(camelizeRE, ( _, c) =&gt; c ? c.toUpperCase() : '')&#125;)//变量的值转换为 string 类型并返回export function toString (val: any): string &#123; return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val)&#125; interation method12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 const inventors = [ &#123; first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 &#125;, &#123; first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 &#125;, &#123; first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 &#125;, &#123; first: 'Marie', last: 'Curie', year: 1867, passed: 1934 &#125;, &#123; first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 &#125;, &#123; first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 &#125;, &#123; first: 'Max', last: 'Planck', year: 1858, passed: 1947 &#125;, &#123; first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 &#125;, &#123; first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 &#125;, &#123; first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 &#125;, &#123; first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 &#125;, &#123; first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 &#125; ];// Array.prototype.filter()// 1. Filter the list of inventors for those who were born in the 1500'slet Filters= inventors.filter(el =&gt; el.year&lt;1600 ) console.table(Filters)// Array.prototype.map()// 2. Give us an array of the inventors' first and last nameslet maps = inventors.map(el =&gt;`$&#123;el.first&#125; $&#123;el.last&#125;`) console.log(maps)// Array.prototype.sort()// 3. Sort the inventors by birthdate, oldest to youngest inventors.sort((a,b) =&gt; a.year-b.year) console.table(inventors)// Array.prototype.reduce()// 4. How many years did all the inventors live? let lives = inventors.reduce((first,second)=&gt;(first+(second.passed - second.year)), 0) console.table(lives)// 5. Sort the inventors by years lived inventors.sort((a,b) =&gt; -((a.passed-a.year)-(b.passed-b.year))) console.table(inventors) const people = [ &#123; name: 'Wes', year: 1988 &#125;, &#123; name: 'Kait', year: 1986 &#125;, &#123; name: 'Irv', year: 1970 &#125;, &#123; name: 'Lux', year: 2015 &#125; ];const coms = [ &#123; text: 'Love this!', id: 523423 &#125;, &#123; text: 'Super good', id: 823423 &#125;, &#123; text: 'You are the best', id: 2039842 &#125;, &#123; text: 'Ramen is my fav food ever', id: 123523 &#125;, &#123; text: 'Nice Nice Nice!', id: 542328 &#125;];// Some and Every Checks// Array.prototype.some() // is at least one person 19 or older?let isNineOld = people.some(el=&gt; (new Date()).getFullYear() - el.year&gt;=19)// Array.prototype.every() // is everyone 19 or older?let everyone=people.every(el=&gt; (new Date()).getFullYear() - el.year&gt;=19)// Array.prototype.find()// Find is like filter, but instead returns just the one you are looking for// find the comment with the ID of 823423let comment = coms.find(el=&gt;el.id ===823423 )// Array.prototype.findIndex()// Find the comment with this IDlet i = coms.findIndex(el=&gt;el.id ===823423 )// delete the comment with the ID of 823423let newcoms = [...coms.slice(0,i),coms.slice(i+1)]coms.splice(i,1) Label123456789101112131415161718192021222324// 举一个比较典型的例子，看完后即明白 Label 的应用：（未添加 Label） var num = 0; for (var i = 0 ; i &lt; 10 ; i++)&#123; for (var j = 0 ; j &lt; 10 ; j++)&#123; if( i == 5 &amp;&amp; j == 5 )&#123; break; &#125; num++; &#125; &#125; alert(num); // 循环在 i 为5，j 为5的时候跳出 j循环，但会继续执行 i 循环，输出 95// 对比使用了 Label 之后的程序：（添加 Label 后） var num = 0; outPoint: for (var i = 0 ; i &lt; 10 ; i++)&#123; for (var j = 0 ; j &lt; 10 ; j++)&#123; if( i == 5 &amp;&amp; j == 5 )&#123; break outPoint; &#125; num++; &#125; &#125; alert(num); // 循环在 i 为5，j 为5的时候跳出双循环，返回到outPoint层继续执行，输出 55]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algorithm]]></title>
    <url>%2F2019%2F04%2F21%2Falgorithm%2F</url>
    <content type="text"><![CDATA[术语 时间复杂度: 一个算法执行所耗费的时间。 一个算法花费的时间与算法中语句的执行次数成正比例,一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化，要知道变化时呈现什么规律就引入了时间复杂度概念算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 空间复杂度: 运行完一个程序所需内存的大小。 一个算法所需的存储空间用f(n)表示。S(n)=O(f(n)) 其中n为问题的规模，S(n)表示空间复杂度。 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 更多信息 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素(自己不能跟自己加起来等于target)。 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解答：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */// 方法一 嵌套循环 时间复杂度：O(n^2) 空间：O(2)var twoSum = function(nums, target) &#123; for (let [i,k] of nums.entries())&#123; for (let j = i+1; j&lt; nums.length; j++) &#123; if( (target - k) === nums[j]) &#123; return [i,j]; &#125; &#125; &#125;&#125;;// 方法二 嵌套循环 比 方法一 更快 var twoSum = function(nums, target) &#123; let len = nums.length; for (let i = 0; i&lt;len; i++)&#123; for (let j = i+1; j&lt;len; j++) &#123; if( (target - nums[i]) === nums[j]) &#123; return [i,j]; &#125; &#125; &#125;&#125;;// 方法三 has表 时间复杂度：O(n) 空间：O(n)/** * 存储对应的值 和 索引 */var twoSum = function(nums, target) &#123;userManage const m = new Map(); const len = nums.length； for (let i = 0; i &lt; len; i++ ) &#123; if(m.has(nums[i]) &amp;&amp; m.get(nums[i]) !== i)&#123; return [m.get(nums[i]),i] &#125; m.set((target - nums[i]),i); &#125; &#125;;//orvar twoSum = function(nums, target) &#123; const m = new Map(); const len = nums.length； for (let i = 0; i &lt; len; i++ ) &#123; let res = target - nums[i]; if(m.has(res) &amp;&amp; m.get(res) !== i)&#123; return [m.get(res),i] &#125; m.set(nums[i],i); &#125;&#125;; 整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 12345678910111213141516171819202122/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123; let res =( x+'' ).split(""); if(res[0] !== '-')&#123; let num = parseInt(res.reverse().join(''),10); if( num&gt; Math.pow(2,31) -1)&#123; return 0 &#125; return num; &#125;else&#123; res.reverse().pop(); let num = parseInt(res.join(''),10); if( num&gt; Math.pow(2,31) -1)&#123; return 0 &#125; return '-' + num; &#125;&#125;; 回文数 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数 。 输入: 121 输出: true输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。注意 0 是回文数 进阶: 不将整数转为字符串来解决这个问题 123456789101112131415161718192021222324/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */ // 方法 一 转化未字符串var isPalindrome = function(x) &#123; return x &lt; 0? false: (parseInt((x+'').split('').reverse().join('')) === x ? true : false);&#125;;/** * 方法二 中间数的右边反转后 等于 左边 * 提取中间数的右边 通过 *10 、 %10 来提取 * */ var isPalindrome = function(int) &#123; if(int &lt; 0 || (int%10 === 0 &amp;&amp; int !== 0)) return false; let num = 0; while (int &gt; num )&#123; num = num * 10 + int % 10; int = parseInt(int/10); &#125;console.log(int,num) return int === num || int === parseInt(num/10);&#125;;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Sum of two numbers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios]]></title>
    <url>%2F2019%2F04%2F17%2Faxios%2F</url>
    <content type="text"><![CDATA[原生Ajax 异步的JavaScript与XML技术（ Asynchronous JavaScript and XML ） Ajax 不需要任何浏览器插件，能在不更新整个页面的前提下维护数据，但需要用户允许JavaScript在浏览器上执行。XMLHttpRequest 对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 创建 构造函数function Ajax(obj) &#123; this.url = obj.url ||''; this.type = obj.type || 'get'; this.data = obj.data ||&#123;&#125;; this.success = obj.success || null; this.error = obj.error || null;&#125;// 再原型上创建方法Ajax.prototype.send = function()&#123; var self = this; var toStr = Object.prototype.toString; if (self.data === null &amp;&amp; typeof self.data !== 'object' &amp;&amp; Array.isArray(obj)) return; return (function()&#123; // 实例化 XML对象 var xhr = new XMLHttpRequest(); var data = ''; // 序列化参数 for (var k in self.data)&#123; data += k + '=' + self.data[k] + '&amp;'; &#125; data = data.substr(0,data.length - 1); // 接收回调函数 xhr.onreadystatechange = function()&#123; if (xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; isFunction(self.success) &amp;&amp; self.success(xhr.responseText) &#125;else&#123; isFunction(self.error) &amp;&amp; self.error(xhr) &#125; &#125; &#125; // 初始化请求 if(self.type.toLocaleLowerCase() === 'post')&#123; xhr.open ('post',self.url,true) // 设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); //发送请求 xhr.send(data) &#125; else &#123; xhr.open('get', self.url + "?" + data,true) xhr.send(null) &#125; &#125;());&#125;;function isFunction(obj)&#123; return toStr.call(obj) === "[object Function]"&#125;var ajax = new Ajax(&#123; type:'post', url:"/login", data:&#123; loginname:"admin", password:"admin" &#125;, success:function(e)&#123; console.log(e) &#125;, error:function(err)&#123; console.log(err) &#125;, &#125;).send(); XMLHttpRequest Level 2 相比于 老版本的 XMLHttpRequest 新增以下内容：可以设置 HTTP 请求超时时间 123456789var xhr = XMLHttpRequest();xhr.open('GET','url');// 超时 2sxhr.timeout = 2000;// 超时处理xhr.ontimeout = function(e) &#123; console.log(e)&#125;xhr.send(null) 可以通过 FormData 发送表单数据 1234567 // 实例化 FormDatavar formData = new FormData(); // 添加数据 formData.append(key,value); xhr.open('POST','url'); xhr.send(formData); 可以上传文件 FormData 除了可以添加字符串数据，也可以添加 blob、file 类型的数据，因此可以用于上传文件。 在浏览器中，一般是通过文件上传输入框来获取 file 对象，比如： 1&lt;input type="file" name='uploadFile' id="upload-file" /&gt; 12345678document.getElementById('upload-file') .addEventListener('change', function () &#123; var formData = new FormData(); // 获取数据 formData.append('uploadFile', this.files[0]) xhr.send(formData) &#125;) 支持跨域请求 浏览器默认是不允许跨域请求的，有时候又是必要的，在以前通常使用JSONP来解决（IE10 以下不支持） 为了标准化跨域请求， W3C提出 跨域资源共享（CORS）前端无须修改代码，只需 服务器返回 Access-Control-Allow-Origin 响应头，指定允许对应的域 CORS 默认不发送 cookie 如果需要发送，前端需要设置 withCredentials属性，同时服务器需要 返回 Access-Control-Allow-Credentials: true,1xhr.withCredentials = true; 可以获取服务端二进制数据 使用 overrideMimeType 方法覆写服务器指定的 MIME 类型，从而改变浏览器解析数据的方式123456// 参数 MIME 类型// 告诉浏览器，服务器响应的内容是用户自定义的字符集 xhr.overrideMimeType('text/plain; charset=x-user-defined');// 浏览器就会将服务器返回的二进制数据当成文本处理，我们需要做进一步的转换才能拿到真实的数据 // 获取二进制数据的第 i 位的值 var byte = xhr.responseText.charCodeAt(i) &amp; 0xff “&amp; 0xff” 运算 参考 阮一峰的文章 xhr.responseType 用于设置服务器返回的数据的类型,将返回类型设置为 blob 或者 arraybuffer，然后就可以从 xhr.response 属性获取到对应类型的服务器返回数据。12345xhr.responseType = 'arraybuffer'xhr.onload = function () &#123;var arrayBuffer = xhr.response// 接下来对 arrayBuffer 做进一步处理...&#125; 可以获取数据传输进度信息 参考资料 使用 onload 监听了一个数据传输完成的事件。1234567// 上传进度监听xhr.upload.addEventListener('progress', onProgressHandler, false);// 传输成功完成xhr.upload.addEventListener('load', onLoadHandler, false);// 传输失败信息xhr.upload.addEventListener('error', onErrorHandler, false); 兼容性 更多资料参考:阮一峰的文章MDN Axios 基于 Promise 的 Http 库 可以在客户端 和 nodeJs中使用 在客户端创基 XMLHttpRequests 在nodeJs 创建 HTTP 请求 支持Promise 可拦截转化请求和响应数据 取消请求 自动转化JSON数据 支持客户端 XSRF 兼容性 安装1npm install axios methodsGet123456789101112131415161718192021const axios = require('axios')axios.get('url?id=xxx') .then(res =&gt; &#123; console.log(res) &#125;) .catch(err =&gt;&#123; console.log(err) &#125;)//oraxios.get('url',&#123; params:&#123; id:'xxxxx' &#125; &#125;) .then(res =&gt;&#123; console.log(res) &#125;) .catch(err =&gt;&#123; console.log(err) &#125;) 同样的传参方法有 delete post1234567axios.post('url',&#123;name:'Owen'&#125;) .then(res =&gt;&#123; console.log(res) &#125;) .catch(err =&gt;&#123; console.log(err) &#125;) 同样的传参方法有 put patch concurrent requests1axios.all([axios.get('url1'),axios.get('url2')]) API axios(config)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180axios(&#123; method:'get', // default is get url:'url', // request url data:&#123; // 仅支持post，put和patch方法，数据作为请求主体发送 ( Only the post,put and patch methods are supported, and the data is sent as the request body ) /* 浏览器仅支持传递 FormData, File, Blob （The browser only supports passing FormData, File and Blob) Node 仅支持传递 Stream, Buffer (The Node only supports passing Stream, Buffer) */ name:'owen' &#125;, baseURL:'base/url', // 除非url是绝对路径，否则将baseURL添加到url的前面 (Add baseURL to then front of the url unless the url is an absolute path) transformRequest: [function (data, headers) &#123; // 可以修改发送的请求数据和请求头，只支持put，post和patch，回调函数必须返回Buffer，ArrayBuffer，FormData或Stream数据 // Can modify the sent request data and request header,only support put, post and patch. // Callback must return Buffer, ArrayBuffer, FormData or Stream data // Do whatever you want to transform the data return data; &#125;], transformResponse: [function (data) &#123; // 修改响应数据，再传递给 then或catch 方法 （Modify the response data and pass it to the then or catch method) // Do whatever you want to transform the data return data; &#125;], headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // 自定义请求头 (Custom request header) params:&#123; // 添加到url尾部的参数，一般用于get 和 delete（ Parameters addde to the end of the url,generally used for get and delete ) id:'xxx' &#125;, paramsSerializer: function (params) &#123; //序列化 [params] (https://www.npmjs.com/package/qs) return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, timeout:1000,// default is 0 , 设置请求超时时间，单位毫秒 （ Set request timeout in milliseconds ) withCredentials: true, // default is false, 跨域时是否携带cookie（ Whether to carry cookies when crossing domains ) adapter: function (config) &#123; /*拦截响应数据*/ // At this point: // - config has been merged with defaults // - request transformers have already run // - request interceptors have already run // Make the request using config provided // Upon response settle the Promise return new Promise(function(resolve, reject) &#123; var response = &#123; data: responseData, status: request.status, statusText: request.statusText, headers: responseHeaders, config: config, request: request &#125;; settle(resolve, reject, response); // From here: // - response transformers will run // - response interceptors will run /** * Resolve or reject a Promise based on response status. * * @param &#123;Function&#125; resolve A function that resolves the promise. * @param &#123;Function&#125; reject A function that rejects the promise. * @param &#123;object&#125; response The response. */ function settle(resolve, reject, response) &#123; var validateStatus = response.config.validateStatus; if (!validateStatus || validateStatus(response.status)) &#123; resolve(response); &#125; else &#123; reject(createError( 'Request failed with status code ' + response.status, response.config, null, response.request, response )); &#125; &#125;; /** * Create an Error with the specified message, config, error code, request and response. * * @param &#123;string&#125; message The error message. * @param &#123;Object&#125; config The config. * @param &#123;string&#125; [code] The error code (for example, 'ECONNABORTED'). * @param &#123;Object&#125; [request] The request. * @param &#123;Object&#125; [response] The response. * @returns &#123;Error&#125; The created error. */ function createError(message, config, code, request, response) &#123; var error = new Error(message); return enhanceError(error, config, code, request, response); &#125; /** * Update an Error with the specified config, error code, and response. * * @param &#123;Error&#125; error The error to update. * @param &#123;Object&#125; config The config. * @param &#123;string&#125; [code] The error code (for example, 'ECONNABORTED'). * @param &#123;Object&#125; [request] The request. * @param &#123;Object&#125; [response] The response. * @returns &#123;Error&#125; The error. */ function enhanceError(error, config, code, request, response) &#123; error.config = config; if (code) &#123; error.code = code; &#125; error.request = request; error.response = response; error.isAxiosError = true; error.toJSON = function() &#123; return &#123; // Standard message: this.message, name: this.name, // Microsoft description: this.description, number: this.number, // Mozilla fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, // Axios config: this.config, code: this.code &#125;; &#125;; return error; &#125; &#125;); &#125;, auth:&#123; // 表示应使用HTTP Basic身份验证，并提供凭据 ( indicates that HTTP Basic auth should be used, and supplies credentials. ) user:'xxx', password:'***' &#125;, responseType: 'json',/* 服务器响应的数据类型（ The server response data type ） 支持 arraybuffer, blob, document, json, text, stream */ responseEncoding:'utf8', // 用于解码响应的编码 (Encoding for decoding the response ) xsrfCookieName: 'XSRF-TOKEN', // default is XSRF-TOKEN , csrf令牌Cookie 名称 xsrfHeaderName: 'X-XSRF-TOKEN', //default is X-XSRF-TOKEN, xsrf标记值的http标头的名称onUploadProgress: function (progressEvent) &#123; //上传进度事件 （handling of progress events for uploads ） console.log(progressEvent) &#125;,onDownloadProgress: function (progressEvent) &#123; // 下载进度事件 （ handling of progress events for downloads） console.log(progressEvent) &#125;,maxContentLength: 2000, // 允许响应内容的最大字节 （defines the max size of the http response content in bytes allowed）validateStatus: function (status) &#123; // 返回给定HTTP状态范围, 如果状态在给定范围内，响应数据传给`then` ，否则传给 `catch` ( Returns the given HTTP status range, if the status is within the give range, the respones data is passed to `then`, otherwise passed to `catch` ) return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, maxRedirects: 5, // default is 5 // 定义Node 中最大重定向数 ( defines the maximunn number of redirects in Node ) socketPath: null, // default is null 定义要在node.js中使用的 UNIX socket httpAgent: new http.Agent(&#123; keepAlive: true &#125;), // node 中 http 和 https 的代理 httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),// http://nodejs.cn/api/http.html proxy: &#123; // 代理配置 host: '127.0.0.1', port: 9000, auth: &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, cancelToken: new CancelToken(function (cancel) &#123; // 取消请求的 token &#125;) &#125;) .then(res =&gt;&#123; console.log(res) &#125;) .catch(err =&gt;&#123; console.log(err) &#125;) 全局配置 通过 axios.create 方法来替换全局配置 123const instance = axios.create(&#123; baseURL: 'base/url'&#125;); 通过axios.defaults 对象替换全局默认配置 12instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 拦截器 拦截请求前的数据 12345axios.interceptors.request.use(function (config) &#123; return config; &#125;, function (error) &#123; return Promise.reject(error); &#125;); 拦截响应数据 1234567axios.interceptors.response.use(function (response) &#123; // Do something with response data return response; &#125;, function (error) &#123; // Do something with response error return Promise.reject(error); &#125;); 删除拦截器 12const myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 二次封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/** * @desc: axios封装 * @author: ggw * @module: axios * @description: 配合使用 饿了么的 Message和Loading * @Date: 2018 */import axios from 'axios';import qs from 'qs';import &#123; Message, Loading&#125; from 'element-ui';import router from '../router'; let loading;let headerNone = &#123; 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'&#125;;let headerTwo = &#123; 'Content-Type': 'application/json; charset=UTF-8'&#125;;let baseURL = window.location.origin ;/** * @description: 定义初始化Loading * @method: startLoading */ const startLoading = () =&gt; &#123; loading = Loading.service(&#123; target: '.content-box', background: 'rgba(220, 220, 220, 0.51)' &#125;);&#125;;let count = 0;/** * @description: 显示Loading 同时多个发送请求 只开启一次Loading * @method: showLoading &amp;&amp; hideLoading */ const showLoading = () =&gt; &#123; if (count === 0) startLoading(); count++;&#125;; const hideLoading = () =&gt; &#123; if (count &lt;= 0) return; count--; if (count === 0) &#123; setTimeout(() =&gt; &#123; loading.close(); &#125;, 300); &#125;&#125;;export let filiter = r =&gt; &#123; for (let item of Object.keys(r)) &#123; if (r[item] === ' ' || r[item] === '') &#123; delete r[item]; &#125; &#125;&#125;;/** * @description: 出口 * @exports api * @param:options 必须是对象 * options 对象为 axios对应参数 */export default (options) =&gt; &#123; /** * @description: 用来初始化承诺的回调。 * 这个回调被传递了两个参数： * 一个解析回调用一个值或另一个承诺的结果来解析承诺， * 以及一个拒绝回调，用来拒绝承诺的原因或错误。 * @constructor: Promise */ return new Promise((resolve, reject) =&gt; &#123; const instance = axios.create(&#123; withCredentials: true, headers: headerNone, baseURL &#125;); // 请求拦截器 instance.interceptors.request.use(config =&gt; &#123; let &#123;load = true&#125; = config.data || config.params || &#123;&#125; ; if (load) showLoading(); // 过滤无值参数 if (config.params) &#123; delete config.params.load; filiter(config.params); &#125; else if (config.data) &#123; filiter(config.data); delete config.data.load; &#125; if ( config.method.toLocaleLowerCase() === 'post' || config.method.toLocaleLowerCase() === 'put' ) &#123; // json 格式传递 if (config.json) &#123; config.headers = headerTwo; &#125; else &#123; config.data = qs.stringify(config.data); config.data = config.data + '&amp;t=' + Date.now(); &#125; &#125; return config; &#125;, error =&gt; &#123; hideLoading(); return Promise.reject(error); &#125;); // 响应拦截器 instance.interceptors.response.use(response =&gt; &#123; setTimeout(hideLoading,0); let data; // IE9时response.data是undefined，因此需要使用response.request.responseText(Stringify后的字符串) if (!response.data ) &#123; data = response.request.responseText; &#125; else &#123; data = response.data; &#125; switch (data.code) &#123; // 接口定义字段 case '001': Message(&#123; showClose: true, message: data.msg || '未知错误,请联系管理员', type: 'error' &#125;); router.push(&#123; path: '/login' &#125;); break; default: &#125; return data; &#125;, err =&gt; &#123; hideLoading(); if (err &amp;&amp; err.response) &#123; let msg = &#123; 400: '请求错误', 401: '未授权，请登录', 403: '拒绝访问', 404: `请求地址出错: $&#123;err.response.request.responseURL&#125;`, 408: '请求超时', 500: '服务器内部错误', 501: '服务未实现', 502: '网关错误', 503: '服务不可用', 504: '网关超时', 505: 'HTTP版本不受支持' &#125;; let status = parseInt(err.response.status,10); Message(&#123; showClose: true, message: msg[status] || '', type: 'error' &#125;); &#125; else &#123; Message(&#123; message: err.config ? `请求地址出错: $&#123;err.config.url&#125;` : err, type: 'error' &#125;); &#125; return Promise.reject(err); &#125;); // 请求 instance(options) .then(res =&gt; &#123; resolve(res); return false; &#125;) .catch(error =&gt; &#123; reject(error); &#125;); &#125;);&#125;;]]></content>
      <categories>
        <category>XMLHttpRequest</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class]]></title>
    <url>%2F2019%2F04%2F17%2Fclass%2F</url>
    <content type="text"><![CDATA[class 生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令 123456789class Point &#123; // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 实例的属性除非显式定义在其本身（即定义在this对象上）， 否则都是定义在原型上（即定义在class上）。 12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 与 ES5 一样，类的所有实例共享一个原型对象。 避免对环境产生依赖，生产环境中，我们可以使用 Object.getPrototypeOf方法来获取实例对象的原型，然后再来为原型添加方法/属性。 12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return 'Oops' &#125;;p1.printName() // "Oops"p2.printName() // "Oops"var p3 = new Point(4,2);p3.printName() // "Oops" 由于p1的原型就是p2的原型，因此p2也可以调用这个方法。 而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 constructor constructor方法是类的默认方法, 通过new命令生成对象实例时，自动调用该方法。 一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。相当于es5 new Vue 1234567891011class Point &#123;&#125;// 等同于 class Point &#123; constructor() &#123;&#125; //JavaScript 引擎会自动为它添加一个空的constructor方法。&#125;// 等同于new Point ()&#123; &#125; constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 表达式定义12345678910const MyClass = class Me &#123; getClassName() &#123; return Me.name; //这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。 &#125;&#125;;//内部没用到Me的话可以省略Meconst YouClass = class &#123;//...&#125;; 采用 Class 表达式，可以写出立即执行的 Class。 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // "张三" 不存在变量提升 （hoist），必须保证子类在父类之后定义 ，这一点与 ES5 完全不同。12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 继承类123456&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; //Bar继承Foo &#125;&#125; 私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。有三种方法可模拟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//第一种class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // _bar方法前面的下划线，表示这是一个只限于内部使用的私有方法 但是，在类的外部，还是可以调用到这个方法。&#125;//第二种class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // 内部调用了bar.call(this, baz)，成为了当前模块的私有方法&#125;//私有方法移出模块function bar(baz) &#123; return this.snaf = baz;&#125;//第三种const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。&#125;; 私有属性的提案 方法是在属性名之前，使用#表示。 1234567891011121314class Point &#123; #x=0;// 私有属性可以指定初始值，在构造函数执行时进行初始化。 constructor(x = 0) &#123; #x = +x; // 写成 this.#x 亦可 &#125; get #x() &#123; return #x &#125; set #x(value) &#123; #x = +value &#125; #sum() &#123; return #a + #b; &#125; //私有方法 // #x是一个私有属性，它的读写都通过get #x()和set #x()来完成。 #x和x是两个不同的属性&#125;//JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。@已经留给了 Decorator。 私有属性不限于从this引用，类的实例也可以引用私有属性 123456789class Foo &#123; #privateValue = 42; static getPrivateValue(foo) &#123; return foo.#privateValue; &#125;&#125;Foo.getPrivateValue(new Foo()); // 42console.log(Foo.#privateValue) // 报错 class 的取值函数（getter）和存值函数（setter）12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter']]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSQuestion]]></title>
    <url>%2F2019%2F04%2F10%2FJSquestion%2F</url>
    <content type="text"><![CDATA[赋值运算符多次出现，优先计算问题(结合性) 赋值表达式为右结合先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用。1234567891011121314151617181920212223242526272829303132333435363738394041424344a = b = c = v/*先解析 左侧的操作数1. refa2. refb3. refc4. value v*/refa = (refb = (refc = value v))/* 再计算右侧表达式的值 然后和从右到左赋值1. value v 赋值 refc2. value v 赋值 refb3. calue v 赋值 refa4. 返回 value v*/ //examplevar foo = &#123;n:1&#125;;var bar = foo;foo.x = foo = &#123;n:2&#125;;/* 变量名 存储在栈中， 引用对象存储在堆中根据规则 先解析 =号左侧的引用 refx = (refo = &#123;n:2&#125;)再赋值refo = &#123;n:2&#125; //refo 开辟新指针 foo 指向 &#123;n:2&#125; refx = &#123;n:2&#125; // 在原refo指针对象中开辟新指针 指向 &#123;n:2&#125;结果 refo.x == undefined*//* 或者 foo.x赋值前是&#123;n:1,x:unfiend&#125;;赋值后&#123;n:1,x:&#123;n:2&#125;&#125;;*/foo.x //undefinedbar.x // &#123;n: 1, x: &#123;n:2&#125;&#125;; split123456'81 newO'.split('') //["8", "1", " ", "n", "e", "w", "O"] '81 newO'.split(' ')// ["81", "newO"]'81 newO'.split('').reverse().join('');//"Owen 18" ###]]></content>
      <tags>
        <tag>JSQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interator]]></title>
    <url>%2F2019%2F04%2F04%2FInterator%2F</url>
    <content type="text"><![CDATA[Interator “集合”数据的结构主要有 Array 、Object、 Set and Map ，任何数据结构只要部署 Iterator 接口，就可完成遍历操作 遍历过程： 创建指针，指向当前数据结构起始位。（遍历对象本质是一个指针对象）。 依次循环调用指针对象的 next方法，对应指向数据结构成员，直至结束。每次调用next方法，返回对象当前成员的信息{value：text,done:true},其中value表示成员值，done` 表示遍历是否结束 123456789101112131415161718let arr = ['Owen','18'];let makeInterator = array =&gt;&#123; let index = 0; return &#123; next ()&#123; return index &lt; array.length ? &#123;value:array[index++],done:false&#125; : &#123;value:undefined, done:true&#125; &#125; &#125;&#125;let inter = makeInterator(arr);inter.next()it.next() // &#123; value: "Owen", done: false &#125;it.next() // &#123; value: 18, done: false &#125;it.next() // &#123; value: undefined, done: true &#125; 对与遍历器对象来说 done: false and value:undefined 可省略 原生具备 Iterator 的数据结构：Array 、 String 、 Map、 Set 、arguments and NodeList 都默认部署 [Symbol.iterator] 方法1234567891011121314151617181920212223//const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;;obj[Symbol.iterator]().next() //&#123;value: 1, done: true&#125;let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125;iter.next() // &#123; value: undefined, done: true &#125; 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//原型上部署Interatorclass RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; return &#123;done: true, value: undefined&#125;; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value); // 0, 1, 2&#125;//对象上部署Interatorfunction Obj(value) &#123; this.value = value; this.next = null;&#125;Obj.prototype[Symbol.iterator] = function() &#123; var iterator = &#123; next: next &#125;; var current = this; function next() &#123; if (current) &#123; var value = current.value; current = current.next; return &#123; done: false, value: value &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; return iterator;&#125;var one = new Obj(1);var two = new Obj(2);var three = new Obj(3);one.next = two;two.next = three;for (var i of one)&#123; console.log(i); // 1, 2, 3&#125; 类似数组对象，可引用 Array.prototype[Symbol.iterator]123456789101112131415161718//NodeListNodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];// 或者NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];[...document.querySelectorAll('div')] //objlet iterable = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for (let item of iterable) &#123; console.log(item); // 'a', 'b', 'c'&#125; 一些 默认调用 Iterator 的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 解构赋值let set = new Set().add('a').add('b').add('c');let [x,y] = set; // x='a'; y='b'let [first, ...rest] = set; // first='a'; rest=['b','c'];//扩展运算符var str = 'hello';[...str] // ['h','e','l','l','o']let arr = ['b', 'c'];['a', ...arr, 'd'] // ['a', 'b', 'c', 'd']//yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125;// for...of//for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、 Generator 对象，以及字符串。let arr = document.querySelectorAll("p");for (let item of arr ) &#123; console.log(item)&#125;/* 其他操作*/Array.from()Map(), Set(), WeakMap(), WeakSet() //生成对应数据结构Promise.all()Promise.race() 遍历器return方法和throw方法return() return方法必须返回一个对象。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。如果for…of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。 1234567891011121314151617181920212223242526function readFile(file) &#123; return &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123;done:false&#125; &#125;, return()&#123; file.close() return &#123;done:true&#125; &#125; &#125;; &#125; &#125;;&#125;//触发 return()for (let line of readFile(fileName)) &#123; console.log(line); break;&#125;//触发 return()for (let line of readLinesSync(fileName)) &#123; console.log(line); throw new Error();&#125; for…of 和其他遍历语法对比12345678910111213141516171819202122232425262728293031323334353637383940414243let arr = [1,2];//普通 `for`循环 for (var index = 0; index &lt;arr.length; index++) &#123; console.log(arr[index]);&#125;/** * 书写比较麻烦*/// Array.forEach arr.forEach(function(item)&#123; console.log(item)&#125;)/** * 无法跳出循环，无法使用 break or return */// for...infor (let index in arr) &#123; console.log(arr[index]);&#125;/** * 1.数组键名为字符串形式的数字 * 2.会遍历出原型链上的键，和手动添加的键 * 3.有些情况是无顺序遍历 */for (let item of arr) &#123; console.log(item);&#125;/** * 1.语法简洁 * 2.没有 for...in 的缺点 * 3.可以使用 return、break and continue * */]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Interator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator]]></title>
    <url>%2F2019%2F04%2F04%2Fgenerator%2F</url>
    <content type="text"><![CDATA[Generator ES6 提供的一种异步编程解决方案Generator 函数是一个状态机，封装了多个内部状态。还是一个遍历器对象生成函数。返回遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 Generator 函数特征 function关键字和函数名之间 有 * ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。 函数体内部有 yield 表达式123456789101112131415function* generator() &#123; yield 'Owen'; yield 18; return 'end';&#125;//调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象 Iterator let person = generator();person.next() //&#123;value:'Owen',done:false&#125;person.next() //&#123;value:18,done:false&#125;person.next() //&#123;value:'end',done:true&#125;person.next() //&#123;value:undefined,done:true&#125;person.next() //&#123;value:undefined,done:true&#125; yield yield 后面的表达式以分号作为结束语句一种可以暂停函数执行的表达式，配合 next方法使用。只能再在 Generator 函数中使用，普通函数中使用会报错.yield 如果用在另一个表达式中,必须用圆括号包起来，作为函数参数或者赋值表达式右边可以不用加括号。 next 运行逻辑 调用 next 遇到 yield表达式 暂停执行函数后面的操作，并且 紧跟 yield 后面的表达式的值作为返回对象 value 属性的值。 再次调用 next,继续执行yield表达式 后面的逻辑代码，直到下一个 yield表达式 或者 return 语句，返回值为 对象 value 属性的值。 如果没有 return 语句 ，则 value 属性的值为 undefined。 只有调用next方法，才会执行对应 yield 后面的表达式12345678function* g()&#123; yield 1 + 2&#125;let num = g() num //g &#123;&lt;suspended&gt;&#125;num.next() //&#123;value:3,done:false&#125;num.next() //&#123;value:undefined,done:true&#125; 使用 Interator 由于 Generator 函数是遍历器生成函数，因此 把它赋值给对象的 [Symbol.interator]属性，该对象就可以被遍历123456789let iter = &#123;&#125;;iter[Symbol.iterator] = function* ()&#123; yield 1; yield 2; yield 3;&#125;[...iter] //[1, 2, 3] next 参数 yield 本身的返回值为 undefined， 而 next方法可以带一个参数，当作上一个 yield的返回值 12345678910111213141516171819202122232425262728293031let g = fn(); g.next() //&#123;value:0,done:false&#125; g.next() //&#123;value:1,done:false&#125; g.next() //&#123;value:2,done:false&#125; g.next(1) //&#123;value:0,done:false&#125; function* fn ()&#123; for (let i = 0; true; i++)&#123; let reset = yield i; if(reset) i = -1; &#125; &#125;function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result';&#125;let genObj = dataConsumer();genObj.next();// Started//&#123;value: "undefined", done: fales&#125;genObj.next('a')//1. a//&#123;value: "undefined", done: fales&#125;genObj.next('b')//2. b//&#123;value: "result", done: true&#125; for…of 中使用 Generator 可以不用调用 next 方法 如果 返回对象 done属性值为 true， 循环终并且不包含该对象返回值；1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function* fn()&#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let i of fn())&#123; console.log(i); //1 2 3 4 5 undefined&#125;//斐波那契数列function* fibonacci() &#123; let [prev, curr] = [0, 1]; for (;;) &#123; yield curr; [prev,curr] = [curr, prev + curr]; &#125;&#125;for (let f of fibonacci()) &#123; if (f &gt; 1000) break; console.log(f)&#125;//遍历任意对象方法function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let key of propKeys)&#123; yield [key,obj[key]]; &#125;&#125;let person = &#123;name:'Owen', age:18&#125;;for (let [key,value] of Object.entries(person))&#123; console.log(key,value); //name Owen // age 18&#125;for (let [key,value] of objectEntries(person))&#123; console.log(key,value); //name Owen // age 18&#125;//或者person[Symbol.interator] = objectEntriesfor (let [key,value] of person)&#123; console.log(key,value); //name Owen // age 18&#125; Generator throw 在函数体外抛出错误，再在 函数体内捕获。throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。因为只有执行一次 next方法，函数才开始执行。 1234567891011121314151617181920212223function* g() &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部1',e ) &#125;; try &#123; yield; &#125; catch (e) &#123; console.log('内部2',e) &#125;; &#125;let t = g();t.next(); //&#123;value: undefined, done: false&#125;try&#123; t.throw('a'); t.throw('b'); t.throw('c');&#125; catch(e)&#123; console.log('外部',e)&#125;//内部1 a//内部2 b//外部 c Generator return 结束 Generator 函数 并且给定对象返回值如果有 try...finally，且在执行中，return方法会等待finally 执行完毕，再执行。12345678910111213141516171819202122232425262728293031function* g()&#123; yield 1; yield 2;&#125;let ge = g();ge.next(); // &#123; value: 1, done: false &#125;ge.return('Owen'); // &#123; value:"Owen", done: true &#125;ge.next() // &#123; value: undefined, done: true &#125;// try...finallyfunction* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var nun = numbers();nun.next() // &#123; value: 1, done: false &#125;nun.next() // &#123; value: 2, done: false &#125;nun.return(7) // &#123; value: 4, done: false &#125;nun.next() // &#123; value: 5, done: false &#125;nun.next() // &#123; value: 7, done: true &#125; next()、throw()、return() 都是让 Generator 恢复执行，并且使用不同语句替换 yield yield* Generator 函数默认不在内部调用另一个 Generator 函数 是没有效果的，如果放到 yield 后面 会返回一个遍历器对象yield* 后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个 for...of 循环。如果 yield* 后面紧跟数组，会遍历数组成员（数组原始支持遍历器）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//默认function* f()&#123; yield 1; yield 2;&#125;function* g()&#123; yield 'x'; f(); yield 'y';&#125;for(let key of g())&#123; console.log(key) //"x" "y"&#125;//yield*function* y()&#123; yield 'x'; yield* f(); yield 'y';&#125;for (let k of y()) &#123; console.log(k); // "x" "y" 1 2&#125;//无 returnfunction* concat(iter1, iter2) &#123; yield* iter1; yield* iter2;&#125;// 等同于function* concat(iter1, iter2) &#123; for (var value of iter1) &#123; yield value; &#125; for (var value of iter2) &#123; yield value; &#125;&#125;// yield* array 如果去掉 * 会返回整个数组//任何数据结构只要有 Iterator 接口，就可以被yield*遍历。function* gen()&#123; yield* ["a", "b", "c"];&#125;var g = gen();g.next() //&#123;value: "a", done: false&#125;g.next() //&#123;value: "b", done: false&#125;g.next() //&#123;value: "c", done: false&#125;g.next() //&#123;value: undefined, done: true&#125;//取出嵌套数组的所有成员function* iterTree(tree) &#123; if (Array.isArray(tree))&#123; for (let arr of tree) &#123; yield* iterTree(arr) &#125; &#125;else&#123; yield tree &#125;&#125;const tree = [1,[2,3],[4,[5,6],7],8];for (let v of iterTree(tree))&#123;console.log(v)&#125;//1 2 3 4 5 6 7 8[...iterTree(tree)] //[1, 2, 3, 4, 5, 6, 7, 8]//遍历完全二叉树// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 下面生成二叉树function make(array) &#123; // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123; result.push(node);&#125;result // ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 对象属性中的 Generator 函数1234567891011let obj = &#123; * generator()&#123; &#125;&#125;//orlet obj1 = &#123; generator :function* () &#123; &#125;&#125; Generator 函数的this Generator 函数不能和 new 一起使用 函数总返回一个遍历器，并且它指向 函数实例，同时继承 函数原型对象上的方法12345678910111213141516171819202122232425262728293031323334353637383940function* g() &#123; this.say = function()&#123; return 18 &#125;;&#125;g.prototype.say = function () &#123; return "Owen"&#125;let obj =g() //g &#123;&lt;suspended&gt;&#125;obj instanceof g //trueobj.say() //"Owen"obj.next() //&#123;value: undefined, done: true&#125;obj.say() //"Owen"//因为 next 返回的是遍历器对象而不是 this 对象,所以不会返回 18//通过call 绑定thisfunction* Gen()&#123; this.age = 18; yield this.name = "Owen";&#125;let obj = Gen.call(Gen.prototype);obj.next()obj.age // 18obj.next();obj.name //"Owen"// 使用 new 的变通方法function G()&#123; return Gen.call(Gen.prototype)&#125;let obj1 = new G();obj1.next()obj1.age // 18obj1.next();obj1.name //"Owen" Generator 函数异步应用 异步: 执行一个任务的时候还不能马上返回结果，那么先将其搁置到后台，执行其他任务，等到有结果返回之后放到消息队列中，等主线程任务执行完毕后，再从消息队列中取出对应任务（callback），执行。同步： 执行一个任务，中间无法中断，只能等待任务返回结果，才能执行其他任务。 异步编程： 回调函数123456$.ajax(&#123; url:&apos;url&apos;, success:function(res)&#123; console.log(res) &#125;&#125;) 事件监听 起初由网景公司知道一套事件驱动机制（事件捕获），之后IE 推出自己的驱动机制（事件冒泡）利用驱动机制实现事件代理委托12345678910111213141516el.addEventListener(event,function()&#123;&#125;,boolean);//IE8 以下el.attachEvent(event,function()&#123;&#125;)//事件代理委托var parent = document.getElementById('parent');parent.addEventListener('click',showColor,false); function showColor(e)&#123; var son = e.target; if(son.nodeName.toLowerCase() === 'li')&#123; console.log('The color is ' + son.innerHTML); &#125; &#125; 发布/订阅（观察者模式）123456789101112131415161718192021222324252627282930313233343536373839404142434445//实现一个简单的发布订阅/* 订阅一个事件，发布对应事件并且执行方法 需要先有代理主题 message proxy 然后订阅者去订阅 然后发布者发布消息执行方法 */ function PubSub () &#123;&#125;; // message proxy PubSub.prototype.message = &#123;&#125;; // publish PubSub.prototype.pub = function () &#123; // Turn arguments into real array let args = [].slice.call(arguments,0); let event = args.shift(); if(!this.message[event]) return this; let list = this.message[event]; for (let item of list) &#123; item.apply(this,args); &#125; return this; &#125; // subscribe PubSub.prototype.sub = function (event,callback)&#123; if( !this.message[event]) &#123; this.message[event] = []; &#125; this.message[event].push(callback); return this; &#125; // unsubscribe PubSub.prototype.unsub = function (event) &#123; if (!this.message[event]) return this; this.message[event] = null; &#125; Promise 对象 为了解决 “回调地狱”（callback hell）而提出的写法允许将 callback 变成链式调用12345678// read I/Olet readFile = require('fs-readfile-promise');readFile(fileA) .then( (data) =&gt; console.log(data.toString())) .then( () =&gt; readFile(fileB)) .then( (data) =&gt; console.log(data.toString())) .catch((err) =&gt; console.log(err)); Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 Generator 函数（es6）协程 多个线程相互协作，完成异步任务步骤 A方法开始任务 A方法执行到一半，暂停，将执行权转移到主线程 一段时间后主线程交还执行权 A方法恢复执行 12345678//examplefunction* async () &#123; //... do something let file = yield readFile(fileA); //... do something&#125;//异步操作需要暂停的地方，都用yield语句注明。 协程代码的写法非常像同步操作，Generator 函数最大优点是可以交出函数执行权 函数通过next 进行数据交换，通过 throw进行错误处理123456789101112function* async (num) &#123; let n; try&#123; n = yield ++num; &#125;catch(err)&#123; console.log(err) &#125; return n&#125;let g = async(1);g.next()g.throw('error'); 封装异步任务使用node-fetch 模块 返回一个Promise 对象123456789101112let fetch = require('node-fetch');let g = gen();let result = g.next();result.value.then((data) =&gt; data.json()) .then((data) =&gt; g.next(data) );function* gen() &#123; let url = '/index.json'; let result = yield fetch(url);&#125; Thunk (形实转换)函数传值策略 传值调用（参数在传入函数前计算）,简单易懂，不过可能会造成性能损失 传名调用（将参数放到一个临时函数，再将这个临时函数传入函数体（Thunk 函数)） 1234567891011//传值var x = 3;function fn (x,b) &#123; return x * 3 &#125;;fn(x + 1) // 4 * 3//传名fn(x + 1) // (x + 1) * 3 //等同于var thunk = function ()&#123; return x + 1&#125;fn (thunk) // thunk() * 3 async/await（es7)]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>async</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflect]]></title>
    <url>%2F2019%2F04%2F02%2FReflect%2F</url>
    <content type="text"><![CDATA[Reflect 将Object对象中一些属于语言内部的方法，放到 Reflect对象中会逐渐替换Object对象 中对应的方法优化一些放法返回的结果只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法,不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。 静态方法 13 个静态方法 作用对应Object同名方法 所有方法第一个参数，必须是对象，否则报错 Reflect.apply(target, thisArg, args) 等同于 Function 构造函数中的Function.prototype.apply.call(func, thisArg, args)1234567891011const ages = [11, 33, 12, 54, 18, 96];// ES5const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// Reflectconst youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []); Reflect.construct(target, args) 对应 new target(...args) 提供了一种不使用 new，来调用构造函数的方法。123456789function Greeting(name) &#123; this.name = name;&#125;// new 的写法const instance = new Greeting('Owen');// Reflect.construct 的写法const instance = Reflect.construct(Greeting, ['Owen']); Reflect.get(target, name, receiver) 查找目标对象属性值并返回1234567891011121314151617let obj = &#123; name : 'Owen', age:18, get baz()&#123; return this.name + this.age &#125;&#125;Reflect.get(obj,'name') //'Owen'Reflect.get(obj,'baz') //'Owen18'// receiver 改变 get 函数 this 指向let obj1 =&#123; name : 'Owen', age:16,&#125;Reflect.get(obj,'baz',obj1) //'Owen16 Reflect.set(target, name, value, receiver)123456789101112131415161718let obj = &#123; name : 'Owen', age:18, set baz(val)&#123; return this.age = val; &#125;&#125;Reflect.set(obj,'name','wen') obj.name //'wen'Reflect.set(obj,'baz', 16)obj.age // 16//receiver 改变 set this 指向let obj1 = &#123; name: 'wen'&#125;Reflect.set(obj,'baz', 16,obj1)obj.name // wen 如果 Proxy和 Reflect 联合使用，并且传入 receiver ， 那么 Reflect.set 会触发Proxy.defineProperty1234567891011121314151617181920212223let proxy = &#123; name:'Owen'&#125;let handler = &#123; set (target, key, value, receiver)&#123; console.log('set') Refelect.set(target, key, value, receiver) &#125;, defineProerty(target, key, attribute)&#123; console.log('defineProperty') Reflect.defineProperty(target, key, attribute) &#125;&#125;let obj = new Proxy(proxy,handler)obj.name = 'wen';// set// defineProperty/* 因为Proxy.set的receiver参数总是指向当前的 Proxy实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截。*/ Reflect.defineProperty(target, propertykey, attribute) 对应 Object.defineProperty12345678910111213function MyDate() &#123; /*…*/&#125;// es5Object.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;);// es6Reflect.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;); Reflect.deleteProperty(target, name) 对应 delete obj.name12345678let obj = &#123; name:'Owen'&#125;//es5 delete obj.name// ReflectReflect.deleteProperty(obj,'name') Reflect.has(target, name) 对应 name in obj 中的 in 运算12345678let obj = &#123; name:'Owen'&#125;//es5 'name' in obj // ture//ReflectReflect.has(obj,'name') //true Reflect.ownKeys(target) 对应 Object.getOwnPropertyNames and Object.getOwnPropertySymbols 返回对象所有属性1234567891011121314151617let obj = &#123; name:'Owen', age:18, [Symbol.for('name')]:'Owen', [Symbol.for('age')]:18&#125;//es5Object.getOwnPropertyNames(obj)// ['name', 'age']Object.getOwnPropertySymbols(obj)//[Symbol(name), Symbol(age)]//es6Reflect.ownKeys(obj)//['name', 'age',Symbol(name), Symbol(age)] Reflect.isExtensible(target) 对应 Object.isExtensible 返回 boolean，表示当前对象是否可扩展。123456const obj =&#123;&#125;//es5Object.isExtensible(obj) //true//es6Reflect.isExtensible(obj) //true Reflect.preventExtensions(target) 对应 Object.preventExtensions 让一个对象变为不可扩展。它返回 boolean，表示是否操作成功。123456const obj =&#123;&#125;// es5 Object.preventExtensions(obj) // Object &#123;&#125;// es6Reflect.preventExtensions(obj) // true Reflect.getOwnPropertyDescriptor(target, propertyKey) 对应 Object.getOwnPropertyDescriptors 返回对象所有自身属性（非继承） 的描述对象1234567891011var obj t = &#123;&#125;;Object.defineProperty(obj, 'hidden', &#123; value: true, enumerable: false,&#125;);// es5var theDescriptor = Object.getOwnPropertyDescriptor(obj, 'hidden');// es6theDescriptor = Reflect.getOwnPropertyDescriptor(obj, 'hidden'); Reflect.getPrototypeOf(target) 获取对象原型参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。1234567const myObj = new FancyThing();// es5 Object.getPrototypeOf(myObj) === FancyThing.prototype;// ReflectReflect.getPrototypeOf(myObj) === FancyThing.prototype; Reflect.setPrototypeOf(target, prototype) 对应Object.setPrototypeOf 设置 原型对象， 返回 Boolean 123456789101112const obj = &#123;&#125;;function Person ()&#123;&#125;//es5Object.setPrototypeOf(obj,Person.prototype);//es6 Reflect.setPrototypeOf(obj,Person.prototype);obj.length //0 Proxy Observer Mode 函数字段观察数据对象，如果数据改变，函数自动执行 1234567891011121314151617181920212223242526272829303132333435const queue = new Set();//队列函数const observe = callback =&gt; queue.add(callback);//观察目标const observable = obj =&gt; new Proxy(obj,&#123;set&#125;);//自动执行function set (target,key,value,receiver)&#123; const result = Reflect.set(target,key,value,receiver); queue.forEach(observer =&gt; observer() ); return result&#125;const person = observable(&#123; name:'Owen', age:18&#125;) function auto()&#123; console.log(`$&#123;person.name&#125;,$&#123;person.age&#125;`); &#125;observe(auto);person.name = 'Owen';/* 先定义一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。 */]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[proxy]]></title>
    <url>%2F2019%2F03%2F26%2Fproxy%2F</url>
    <content type="text"><![CDATA[Proxy 用于修改某些操作的默认行为。（对编程语言进行编程）在目标对象之前架设一层‘门户’，外界访问对象时，必须先访问这个门户，对外界的访问进行过滤和改写 生成: ES6中 所有proxy实例 通过 Proxy 构造函数生成12345678910 new Proxy(target,handler);// target对象 要访问的对象， handler对象 拦截行为var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35 Proxy 支持的操作get(target, propKey, proxy) 拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。12345678910111213141516171819202122/***get 接收三个参数*target 目标对象*property 属性名*proxy 实例本身**/var obj = &#123; name:"Owen"&#125;;var proxy = new Proxy(obj, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError("Property \"" + property + "\" does not exist."); &#125; &#125;&#125;);proxy.name // "Owen"proxy.age // error:Property "age" does not exist.//如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 set(target, propKey, value, proxy) 拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。12345678910111213141516171819202122232425262728293031/***set 有4 个参数*target 目标对象*property 属性名*value 属性值*proxy 实例本身 */ let validator = &#123; set: function(obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('The age is not an integer'); &#125; if (value &gt; 100) &#123; throw new RangeError('The age seems invalid'); &#125; &#125; // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; return true //严格模式下 return false or undefined 会报错 &#125;&#125;;let obj = new Proxy(&#123;&#125;, validator);obj.age = 18;obj.age ='18'; //errorobj.age =101;//error//每当对象发生变化时，会自动更新 DOM。 has(target, propKey) 拦截propKey in proxy的操作，返回一个布尔值。1234567891011121314151617/***接收两个参数*target目标对象*key 查询的属性名**/var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: 'Owen' &#125;;var proxy = new Proxy(target, handler);'_prop' in proxy // false//拦截以‘_’开头的属性名 对for ...in 遍历不生效 deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。1234567891011121314151617var handler = &#123; deleteProperty (target, key) &#123; invariant(key, 'delete'); delete target[key]; return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private "$&#123;key&#125;" property`); &#125;&#125;var target = &#123; _prop: 'foo' &#125;;var proxy = new Proxy(target, handler);delete proxy._prop// Error: Invalid attempt to delete private "_prop" property ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。123456789101112131415161718//拦截对象自身属性的读取操作let target = &#123; _bar: 'foo', _prop: 'bar', prop: 'Owen'&#125;;let handler = &#123; ownKeys (target) &#123; return Reflect.ownKeys(target).filter(key =&gt; key[0] !== '_'); &#125;&#125;;let proxy = new Proxy(target, handler);for (let key of Object.keys(proxy)) &#123; console.log(target[key]);&#125;//会自动过滤 不存在的属性，Symbol，不可遍历属性 getOwnPropertyDescriptor(target, propKey) 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。12345678910111213141516var handler = &#123; getOwnPropertyDescriptor (target, key) &#123; if (key[0] === '_') &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: 'bar', baz: 'tar' &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, 'wat')// undefinedObject.getOwnPropertyDescriptor(proxy, '_foo')// undefinedObject.getOwnPropertyDescriptor(proxy, 'baz')// &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125; defineProperty(target, propKey, propDesc) 拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。12345678var handler = &#123; defineProperty (target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.owen = 'Owen' // 不会生效 preventExtensions(target) 拦截Object.preventExtensions(proxy)，返回一个布尔值。该方法必须返回一个布尔值，否则会被自动转为布尔值。目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true12345678var proxy = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125;&#125;);Object.preventExtensions(proxy)//error getPrototypeOf(target) 拦截Object.getPrototypeOf(proxy)，返回一个对象。12345678910111213141516//主要拦截获取对象原型/** *Object.prototype.__proto__*Object.prototype.isPrototypeOf()*Object.getPrototypeOf()*Reflect.getPrototypeOf()*instanceof**/var proto = &#123;&#125;;var p = new Proxy(&#123;&#125;, &#123; getPrototypeOf(target) &#123; return proto; &#125;&#125;);Object.getPrototypeOf(p) === proto // true//返回值必须是对象或者null，否则报错 isExtensible(target) 拦截Object.isExtensible(proxy)，返回一个布尔值。123456789var p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; console.log("Owen"); return true; &#125;&#125;);Object.isExtensible(p)//返回值必须是Boolean setPrototypeOf(target, proto) 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。12345678910var handler = &#123; setPrototypeOf (target, proto) &#123; throw new Error('Changing the prototype is forbidden'); &#125;&#125;;var proto = &#123;&#125;;var target = function () &#123;&#125;;var proxy = new Proxy(target, handler);Object.setPrototypeOf(proxy, proto);// Error: Changing the prototype is forbidden apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。1234567891011121314151617/***接收三个参数 *target 目标对象*this 目标对象上下文*目标对象的参数数组*/var target = function () &#123; return 'I am the target'; &#125;;var handler = &#123; apply: function () &#123; return 'I am the proxy'; &#125;&#125;;var p = new Proxy(target, handler);p()// "I am the proxy" construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。123456789101112131415//接收两个参数/***target 目标对象*args 构造函数参数对象函数必须返回对象，否则会报错 */ let obj = &#123; construct: function(target, args) &#123; console.log('Owen: ' + args.join(', ')); return &#123; value: args[0] * 10 &#125;; // retirn '18'; error &#125; &#125; var p = new Proxy(function () &#123;&#125;, obj) new p(2).value // 20 Proxy.revocable Proxy.revocable方法返回一个可取消的 Proxy 实例。使用场景： 目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。1234567891011121314let target = &#123;&#125;let handler = &#123;&#125;let &#123;proxy, revoke&#125; = Proxy.revocable(target,handler);/* Proxy.revocable(target, handler);&#123;proxy: Proxy, revoke: ƒ&#125;*/proxy.name = 'Owen'proxy.namerevoke() //取消 proxy 实例proxy.name //error Proxy this 在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 123456 const target = new Date();const handler = &#123;&#125;;const proxy = new Proxy(target, handler);proxy.getDate();//error Proxy 实例使用123456789101112131415const service = createWebService('http://example.com/data');service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ···&#125;);function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl+'/' + propKey); &#125; &#125;);&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Extend]]></title>
    <url>%2F2019%2F03%2F19%2Fextend%2F</url>
    <content type="text"><![CDATA[String Extend被 for ... of 遍历1234567for (let val of 'abc')&#123; console.log(val); //a //b //c&#125; 查找字符12345678910let str = 'Hello Brother!';//includes 是否包含参数字符串str.includes('Br'); //true//startsWith 开头是否存在参数字符串str.startsWith('Hello') //true//endsWith 结尾是否存在参数字符串str.endsWith('er!')//true 重复字符12345678910//repeat 重复 n 次， n 为参数,返回新字符串let re = 'Hello Brother!';re.repeat(2); //"Hello Brother!Hello Brother!"re.repeat(-2); // Invalid count valuere.repeat(Infinity); // Invalid count value//小数会取整 re.repeat(1.9) // "Hello Brother!"re.repeat(-0.9) // "" 补全字符1234567891011121314//补全开头 padStart 补齐尾部 padEndlet pd = 'Brother!'; pd.padStart(14,'Hello '); //"Hello Brother!"//第一个参数为补齐的最大长度（整串字符） 第二个参数为补齐缺省的字符串//如果原始字符长度大于等于最大长度，返回原字符串pd.padStart(7,'Hello ')// 'Brother!'pd.padStart(8,'Hello ')// 'Brother!'//如果最大长度小于补齐长度，则去除超出部分pd.padStart(9,'Aay ')//'ABrother!'//如果缺省第二个参数则 默认使用空格补齐pd.padStart(9)//' Brother!' 模板字符 通过反引号 “ ” 当普通字符串使用1234567891011121314//所有换行和空格会保留，嵌入变量，须将变量包含在 `$&#123;&#125;` 中，并且可进行运算,函数调用，对象调用let num =1,obj =&#123;name:'Owen'&#125;, fn=()=&gt; 3;const str =` $&#123;num * 3 + 1 + fn() + obj.name&#125;`;console.log(str)/* " 7Owen"*///如果紧更在函数名后，函数将被调用（标签模板）alert`123` // 等同于alert(123) 转义符 \12345678//以 x 开头,会被当做 16 进制 `\x23` // # //以 u 开头,会被当做 unicode 字符 `\u004F` //"O"//如果无法编译将会报错 ES2018 放松了对标签模板里面的字符串转义的限制，无法转义的返回undefined； 123console.log`\uw`;//[undefined, raw: Array(1)]//undefined Function Extend形参指定默认值 形参 不能再次使用 let 和 const 声明形参不能重名函数 length 不包含设置默认值和后面的形参个数使用 ...arg 中的参数 length 也不包含 12345678910111213const fn = (x, y = 'Owen') =&gt;( console.log(x,y));fn(1) // 1 "Owen"//默认参数 惰性求值let x = 99;function foo(y = x + 1) &#123; console.log(y);&#125;foo() // 100x = 100;foo() // 101//调用一次计算一次 事实上 每次调用函数，如果不传递参数， 形参默认传递 undefined 12345678910111213 // 默认参数最好定义再尾部，因为使用形参默认参数，那么那个位置的形参必传function f(x, y = 5, z， ...arg) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2]//length 不包含设置默认值 和后面的形参 的个数，f().length // 1 作用域 函数中的变量无法访问 默认值函数中的形参名不能和默认名一样123456789101112131415161718192021222324//函数变量无法访问默认值function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // ReferenceError: x is not defined//函数中的形参名不能和默认名一样//参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错function f(x = x) &#123; console.log(x);&#125;f()// x is not definedvar x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 由于 var 声明的 x 和函数形参 x 不再同一个作用域 ， 因此调用 y() x值不变；如果 去掉 var , 那么 x 就指向 形参 x ,调用 y() x = 2。 reset 参数 （…） 使用形式 ...arg 实数以数组的形势赋给变量reset 参数后不能再有形参，否则报错123456789function fn (a,...arg)&#123; return arg;&#125;fn(0,2,3,4,5)//[2,3,4,5]function foo (a,...arg,b)&#123; return arg;&#125;//ught SyntaxError: Rest parameter must be last formal parameter 只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425// 报错function f(a, b = a) &#123; 'use strict'; // code&#125;// 报错const foo = function (&#123;a, b&#125;) &#123; 'use strict'; // code&#125;;// 报错const fn = (...a) =&gt; &#123; 'use strict'; // code&#125;;const obj = &#123; // 报错 fn(&#123;a, b&#125;) &#123; 'use strict'; // code &#125;&#125;;#### 箭头函数&gt;使用 () =&gt; 定义函数注意：- this 指向函数定义时所绑定的普通函数，不会被(bind,call,apply)更改,也不会被调用时的上下文改变。1234567891011121314151617181920212223let fn = () =&gt;console.log(this);let obj = &#123;name:"Owen"&#125;;fn.call(obj) //windowfn.bind(obj)fn() //windowfn.apply(obj) //window //可以通过改变宿主环境来改变 this 指向 function foo ()&#123; return () =&gt;&#123; console.log(this); return ()=&gt; &#123;console.log(this)&#125;; &#125;&#125;foo.call(obj)() //&#123;name: "Owen"&#125;foo.call(obj)()() //&#123;name: "Owen"&#125; &#123;name: "Owen"&#125;- 外层没有普通函数 ，严格模式和非严格模式下它的this都会指向window(全局对象)。- 不可以当作构造函数，也就是说，不可以使用new命令，没有prototype属性，不支持new.target,否则会抛出一个错误。- 参数和箭头之间不能换行- 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。- 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。123456789101112131415161718192021222324//定义简单函数let fn = () =&gt; 'Owen';fn()// 'Owen'let foo = r =&gt; r;foo('Owen') // 'Owen'let f = (num1,num2) =&gt; num1 + num2;f(1,2)//3//如果返回一个对象需要小括号包裹,f否则会报错let f = (name,age) =&gt; (&#123;name,age&#125;);f('Owen',18)//&#123;name: "Owen", age: 18&#125;//如果代码部分大于一条语句，那么需要 大括号包裹，使用return 返回值let fn1 = r =&gt; &#123; let a = 1; console.log(a); return r + a;&#125;#### 不推荐使用场景- 在对象中使用 this.123456var obj = &#123; gender:"man", getSex: () =&gt; &#123;console.log(this.gender)&#125;&#125;obj.getSex() //undefined//this -&gt; global- 动态使用 this.12345var lis = document.querySelector('li');lis.addEventListener('click',() =&gt; &#123; console.log(this)&#125;)// this -&gt; global- 内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数#### 双冒号运算符 ::&gt; 目前只是一个提案，用来绑定函数的 this 类似于 (bind,call,apply)&gt; 将做边的对象作为参数，绑定到右边函数上。1234567bar:: fn//等同于fn.bind(bar);bar::fn(...arguments);//等同于fn.apply(bar, arguments);#### 函数调用12345678 function f()&#123; foo()&#125; function foo()&#123; fn()&#125;function fn()&#123;&#125;f()&gt; 函数调用会在内存中形成一个 调用记录（调用帧），保存着调用位置和内部变量等信息。&gt; 函数 f内部调用 foo函数，f调用帧的上方会形成 foo的调用帧， foo运行接受并且将结果返回给 f，foo的调用帧才会消失，同理，foo函数 内部调用fn函数，还会有 fn 的调用帧，以此类推，形成一个调用栈。#### 尾调用&gt; 指某个函数的最后一步是调用另一个函数。&gt; 不一定出现在函数尾部，只要是最后一步操作即可。123456789101112131415161718192021222324252627//尾调用function f(x)&#123; return fn(x);&#125;//不属于尾调用// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; //等同于function f(x)&#123; g(x); return undefined;&#125;——### Array Extend#### 扩展运算 (…)&gt;主要用于函数调用， 将一个数组，变为参数序列。12345function add(x, y) &#123; return x + y;&#125;add(... [1,2]) // 3##### clone数组 123456789 //es5 let arr = [1,2];let arr1 = arr.concat(); //es6let [...arr2] = arr;let arr3 = [...arr];##### 合并数组1234567let arr = [1,2];let arr1 = [3,4];let arr2 = [5,6];//es5let arr3 = arr.concat(arr1,arr2);//es6let arr4 = [...arr,...arr1,...arr2];合并和clone 都是浅拷贝；##### 配合解构赋值1234567891011121314151617const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = ["foo"];first // "foo"rest // []//扩展运算符，只能放在参数的最后一位，否则会报错。const [first, ...middle, last] = [1, 2, 3, 4, 5];//error##### 将伪数组(内部实现了Iterator)转化伪数组1234567891011121314151617//内部实现Iterator//字符串， Set, Map, Generator, NodeList, htmlcollection, classList ,argument内部都实现了迭代接口let nodes = document.querySelectorAll('div');let divs = [...nodes];//内部未实现Iteratorlet objs = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr =[...objs];//error//可通过 Array.from方法转化let arr1 = Array.from(objs)#### Array.from&gt; 将伪数组转化为数组123456789101112131415161718192021222324252627let arrLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr = Array.from(arrLike)/*第二个参数 遍历每个元素并返回运算结果*/Array.from(arrLike, x =&gt; x * x);// 等同于Array.from(arrLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9]//将布尔值为false的成员转为0Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3]//获取DOM 节点的文本内容。Array.from(document.querySelectorAll('span.name');, s =&gt; s.textContent)//第三个参数 绑定第二个参数中回调函数的this#### find and findIndex&gt; 回调函数遍历所有成员，返回符合条件的值， 没有则返回 undefined&gt; find 返回值为，第一个符合条件的成员&gt;findIndex ，没有则返回 -1&gt; 回调函数接受三个参数（成员，位置，原数组）&gt; 第二个参数 绑定回调函数 this&gt; 可以识别NaN1234567[1, 4, -5, 10].find(function(v,i,arr)&#123; return v&lt;0;&#125;)// -5[1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0)// 2#### fill&gt; 填充数组,修改原数组&gt; 第一个参数为填充值，第二个参数为开始填充的位置，第三个参数为结束位置12345let arr =[1,2,3];arr.fill('Owen');//["Owen","Owen","Owen"]arr.fill(1,0,2);//[1,1,3]#### Interator&gt; keys,values,entries 对应属性遍历123456789101112131415161718// keyslet arr = ['o','w','e','n'];for (let key of arr.keys())&#123; console.log(key); //0 1 2 3&#125;for (let item of arr.values())&#123; console.log(item); //o w e n&#125;for (let [i,item] of arr.entries())&#123; console.log(i,item)//1 "w"//2 "e"//3 "n"&#125;#### includes&gt; 返回一个Boolean ,数组是否包含给定的值1234567891011[1,2,3,4].includes(3)//true//第二个参数为搜索的起始位置[1,2,3,4].includes(3,4)//false/* 是否支持 */const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false#### flat ,flatMap&gt; 将二维数组变成一位数组，并返回新数组12345678910[1,2,[3,4]].flat()//[1,2,3,4]//默认拉平1层[1,2,[3,[4]]].flat(2)//[1,2,3,4]//将所有维度变成一维array.flat(Infinty)//会忽略空位[1,,[3,4]].flat()//[1,3,4]—#### ES5 interator methods##### every- 访问每一个成员,给定某个条件，如果所有成员满足条件就返回true123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.every(function(item,key,array)&#123; return ( item&gt;2 )&#125;) n //false#### some- 访问每一个成员,给定某个条件，只要有一个成员满足条件就返回true- 有一个满足条件的成员之后的不再执行123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.some(function(item,key,array)&#123; return ( item &gt; 2 )&#125;) n //true##### filter- 访问每一个成员,给定某个条件，将满足条件的成员组成数组返回， 否则返回 []- 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用 123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.filter(function(item,key,array)&#123; return ( item &gt; 2 )&#125;) n //[3, 4, 5, 4, 3] map 访问每一个成员,将每次访问执行的结果组成数组返回，也就是说每个成员都 必须要有return返回结果，否则都是unndefined map不支持continue跳出循环 123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.map(function(item,key,array)&#123; return item * 2&#125;) n // [0, 2, 4, 4, 6, 8, 10, 6, 10] forEach 访问每一个成员,没有返回值 中途不能用常规操作跳出循环 不支持链式操作123456var num = [0,1,2,2,3,4,5,3,5]; var n = num.map(function(item,key,array)&#123; return item * 2&#125;) n // undefined reduce and reduceRight reduce 从数组的第一项开始，逐个遍历到最后。 reduceRight 从数组的最后一项开始，向前遍历到第一项。 接收两个参数 回调函数和 回调函数第一个参数的值，默认数组第一个元素。 返回 累计处理的结果 12345678910111213141516171819 /** * @param * prev 上次调用回调时的累积值 * cur 当前数组成员 * i 数组索引 * arrary 原数组 * */var num = [0,1,2,2,3,4,5,3,5];var n = num.reduce(function(prev,cur,i,array)&#123; return prev*2 + cur&#125;) n // 431 var num = [0,1,2,2,3,4,5,3,5];var n = num.reduce(function(prev,cur,i,array) &#123; return prev*2 + cur&#125;) n // 2186 以上都不会修改原数组，除非使用第三个参数做些操作，注意数组成员是值类型，还是引用类型 sort 对数组排序 默认排序按字母升序（根据字符串Unicode ） 参数为回调函数callback(a,b) 返回值为负数 那么 a 会被排列到 b 之前 返回值为 0 位置不变 返回值为正数 b 会被排列到 a 之前12345var num = [1,3,2,7,44,2,3,4,9];num.sort(function(a,b)&#123; return a-b&#125;)num // [1, 2, 2, 3, 3, 4, 7, 9, 44] reverse 翻转数组123var num = [1,3,2,7,44,2,3,4,9];num //[9, 4, 3, 2, 44, 7, 2, 3, 1]num.reverse() 数组去重 has方法 会发生隐式转化 1 ==’1’ 123456789101112131415161718192021222324252627282930 var arr = [2,3,4,2,3,5,6,4,3,2];var unique = function(arr) &#123; var obj = &#123;&#125;; var res = []; arr.forEach(function(item,i)&#123; if(!obj[item])&#123; obj[item] = true; res.push(item) &#125; &#125;) return res&#125;unique(arr)&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD=======- map has方法 不会发生隐式转化var unique = function(arr) &#123; var m = new Map(); var res = []; arr.forEach(function(item,i)&#123; if(!m.has(item))&#123; res.push(item) &#125; m.set(item,2); &#125;) return res&#125;unique(arr)&gt;&gt;&gt;&gt;&gt;&gt;&gt; d71c39e5118389885ef986735a9a15598115e5b9 filter 1234567891011121314151617//会忽略 undefinedvar arr = [null,null,null,undefined,undefined,'','',1,1,1];var unique = function (arr) &#123; return arr.sort().filter(function(item,i,array) &#123; return item !== array[i+1]; &#125;)&#125; unique(arr) // ["", 1, null]var unique = function(arr) &#123; return arr.filter( function(item, idx ) &#123; return arr.indexOf(item) === idx; &#125;)&#125;unique(arr) //[null, undefined, "", 1] Object extend对象中的简写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//函数const obj =&#123; methode()&#123; return 'Owen' &#125;, * m() &#123; yield 'hello world'; &#125;&#125;//等同于const obj =&#123; methode:function()&#123; return 'Owen' &#125; m:function* ()&#123; yield 'hello world'; &#125;&#125;//使用变量定义对象 //默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。let lastWord = 'last word';const obj = &#123; 'first word': 'hello', [lastWord]: 'world', ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj['first word'] // "hello"obj[lastWord] // "world"obj['last word'] // "world"obj.hello() // hi//对象中 函数 name属性//对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。const key1 = Symbol('description');const key2 = Symbol();let obj = &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;, sayName() &#123; console.log('Owen'); &#125;, get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;obj[key1].name // "[description]"obj[key2].name // ""obj.sayName.name // "sayName"const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');descriptor.get.name // "get foo"descriptor.set.name // "set foo"//通过构造函数创立的函数(new Function()).name // "anonymous"//通过 bind 绑定的函数var doSomething = function() &#123; // ...&#125;;doSomething.bind().name // "bound doSomething" 枚举和遍历 Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象 12345678910let obj = &#123; name:'Owen'&#125;Objct.getOwnPropertyDescriptor(obj,'name');// &#123;// value: Owen,// writable: true,// enumerable: true, //可枚举// configurable: true// &#125; 如果 enumerable 为 false有些操作会忽略，当前属性 for…in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 (ES6) Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 共有 5 种方法可以遍历对象的属性。 for…in for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。 super this 总是指向函数所在的当前对象super 指向当前对象的原型对象。super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。12345678910111213const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // "hello" 对象扩展运算符 ES2018 将这个运算符引入了对象。解构赋值的拷贝是浅拷贝不能复制继承自原型对象的属性。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 解构//必须保证右方为对象，否则报错let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125;//与函数参数扩展运算类似，解构赋值须最后一个参数let &#123; ...x, y, z &#125; = someObject; // 句法错误let &#123; x, ...y, ...z &#125; = someObject; // 句法错误//无法继承原型let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2.__proto__ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined//扩展运算//数组是特殊的对象，所以对象的扩展运算符也可以用于数组let foo = &#123; ...['a', 'b', 'c'] &#125;;foo// &#123;0: "a", 1: "b", 2: "c"&#125;//扩展运算符后面是一个空对象，无效果&#123;...&#123;&#125;, a: 1&#125;// &#123; a: 1 &#125;//扩展运算符后面不是对象，则会自动将其转为对象 &#123;...1&#125; // &#123;&#125;//扩展运算符后面是字符串，它会自动转成一个类似数组的对象&#123;...'Owen'&#125;//&#123;0: "O", 1: "w", 2: "e", 3: "n"&#125;let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b);//完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。// 写法一 非浏览器环境不一定部署 __proto__const clone1 = &#123; __proto__: Object.getPrototypeOf(obj), ...obj&#125;;// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj);// 写法三const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj))//对象的扩展运算符后面可以跟表达式const obj = &#123; ...(x &gt; 1 ? &#123;a: 1&#125; : &#123;&#125;), b: 2,&#125;;//扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行let aWithXGetter = &#123; ...a, get x() &#123; throw new Error('not throw yet'); &#125;&#125;;// 会抛出错误，因为 x 属性被执行了let runtimeError = &#123; ...a, ...&#123; get x() &#123; throw new Error('throw now'); &#125; &#125;&#125;; New method for objectsObject.is() 比较两个值是否严格相等 和 === 的区别12345678910111213141516171819+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // truees5 实现Object.defineProperty(Object,'is',&#123; value: function(x, y) &#123; if (x === y) &#123; // 针对+0 不等于 -0的情况 return x !== 0 || 1 / x === 1 / y; &#125; // 针对NaN的情况 return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;) Object.assign() 浅拷贝对象，无法拷贝原型,也不拷贝不可枚举的属性。总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。同属性后面的覆盖前面的值 12345678Object.assign(&#123;b: 'c'&#125;, Object.defineProperty(&#123;&#125;, 'invisible', &#123; enumerable: false, value: 'hello' &#125;) )// &#123; b: 'c' &#125;Object.assign([1, 2, 3], [4, 5])//[4,5,3] Object.getOwnPropertyDescriptors() 返回目标对象所有自身属性（非继承） 的描述对象12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return 'Owen' &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; 主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。1234567891011121314151617const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target = &#123;&#125;;const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source));shallowMerge(target,source)Object.getOwnPropertyDescriptor(target, 'foo')// &#123; get: undefined,// set: [Function: set foo],// enumerable: true,// configurable: true &#125; 配合Object.create()方法，将对象属性克隆到一个新对象1234const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); 实现一个对象继承另一个对象。123456789101112131415//一const obj1 = Object.create(prot);obj.foo = 123;//二const obj2 = Object.assign( Object.create(prot), &#123; foo: 123, &#125;//三const obj3 = Object.create(prot,Object.getOwnPropertyDescriptors(&#123; name:'Owen'&#125;))); 实现Mixin1234567891011121314let mix = (obj) =&gt; ( &#123; with:(...mixins) =&gt; mixins.reduce( (c,mixin) =&gt; Object.create( c, Object.getOwePropertyDescriptors( minxin )), obj ) &#125;)let a = &#123;a: 'a'&#125;;let b = &#123;b: 'b'&#125;;let c = &#123;c: 'c'&#125;;let d = mix(c).with(a, b);d.c // "c"d.b // "b"d.a // "a" proto属性，Object.setPrototypeOf()，Object.getPrototypeOf() 设置，和 获取原型12345678910111213141516171819202122232425//setlet proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40//getfunction Rectangle() &#123; // ...&#125;const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false Object.keys()，Object.values()，Object.entries()1234567891011//keyslet obj = &#123; foo: 'bar', baz: 42 &#125;; //es5Object.keys(obj)// ["foo", "baz"]//valuesObject.values(obj)//['bar,42]Object.entries(obj)// [['foo', 'bar'], ['baz', 42]] Object.fromEntries() Object.entries 方法的逆操作12345Object.fromEntries([ ['foo', 'bar'], ['baz', 42]])// &#123; foo: "bar", baz: 42 &#125; 目前谷歌版本 Chrome/72.0.3626.121 Safari/537.36 及以下不支持]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Extend Methods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map]]></title>
    <url>%2F2019%2F03%2F19%2Fmap%2F</url>
    <content type="text"><![CDATA[Map 键值对的集合 键名的范围不限制于字符串 1234567891011121314151617const m = new Map();const obj = &#123;name: 'Owen'&#125;;const fn = function()&#123;&#125;;//设值m.set(obj,"boy"); //将 obj 作为键名， 给它赋值//可以是对象，数组，甚至是函数，任何数据类型都可以当作属性名（键名）m.set(fn,1) //对同一个键名赋值，后面的将覆盖前面的//获值m.get(obj) // 'boy'//查询m.has(obj) // true//删除m.delete(obj)//true Map 参数 任何 Iterator 接口，并且每个成员都是双元素数组的数据结构 都可以作为参数123456789101112131415161718192021222324252627282930313233343536373839let arr = [[1,2],[2,3]];const ma = new Map(arr); //Map(2) &#123;1 =&gt; 2, 2 =&gt; 3&#125;ma.get(1) //2ma.get(2) //3//如果几组双元素成员相同那么只会生成一个值arr = [[1,2],[1,2]];mss = new Map(arr); //Map(1) &#123;1 =&gt; 2&#125;ma.size//2mss.size//1// keys 键名for (let key of ma.keys())&#123; console.log(key) //1 //2&#125;//values 值for (let val of ma.values())&#123; console.log(val) //2 //3&#125;//entries 键值 等同于 遍历 ma 默认遍历的是entries for (let [key,val] of ma.entries())&#123; console.log(key,val) //1,2 //2,3&#125;//转化为数组[... ma.keys() ] //[1,2][... ma.values() ] //[2,3][... ma] //[[1,2],[2,3]]]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set]]></title>
    <url>%2F2019%2F03%2F15%2Fset%2F</url>
    <content type="text"><![CDATA[Set ES6 提供的数据结构类似于数组，值是唯一的，通过 Set 构造函数来生成 1234567891011const arr = [1,2,2,3,4,5,3,2,3,4,5];//参数可以是一个可以迭代的数据结构const set = new Set(arr); //Set(5)&#123;1,2,3,4,5&#125;[...set] //[1,2,3,4,5]const set1 = new Set('12343333433225'); //Set(5) &#123;"1", "2", "3", "4", "5"&#125;set1.size //5//数组去重const arr1 = [... new Set([1,2,3,4,3,3,3,3])];const arr2 = Array.from(new Set([1,2,3,4,3,3,3,3])); 属性和方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//属性const s = new Set() s.constructor //指向 Set 函数 s.size //成员总数/** * 操作方法 *///也可以通过 add()方法添加 只有一个参数const set2 =new Set();set2.add(1) //Set(1) &#123;1&#125;//不会发生类型转换 NaN 会 = NaN set2.add("1") //Set(2) &#123;1,"1"&#125;set2.add(NaN).add(NaN)// Set(3) &#123;1,"1",NaN&#125; 链式调用//两个对象不相等set2.add(&#123;&#125;)set2.size //4set2.add(&#123;&#125;)set2.size //5//通过 delete() 删除某个值 返回 Boolean 值 set2.delete(1) //trueset2.delete(&#123;&#125;) //false //has() 是否存在某个值 set2.has(NaN) //trueset2.has(&#123;&#125;) // false//clear() 清除所有成员set2.clear() //Set(0) &#123;&#125;/** * 遍历方法 *//** * keys 返回键名的迭代器， values 返回 键值的迭代器， 由于 Set 键名和键值 相同 所以 * keys 和 values 方法返回值相同 */ const sK = new Set([1,2,3,4,5]).keys() //SetIterator &#123;1, 2, 3, 4, 5&#125; const sV= new Set([1,2,3,4,5]).values() //SetIterator &#123;1, 2, 3, 4, 5&#125; //enters 返回键值对 for (let item of new Set([1,2,3,4,5]).entries()) &#123; console.log(item);&#125;// [1, 1]// [2, 2]// [3, 3]// [4, 4]// [5, 5]//推荐使用for of const sI = new Set([1,2,3,4,5]);for (let key of sI) &#123; console.log(key); //1 2 3 4 5&#125;// Set的遍历顺序就是插入顺序。使用 Set 保存一个回调函数列表，调用时能保证按照添加顺序调用。//forEachsI.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 2 : 2// 3 : 3// 4 : 4// 5 : 5 weakSet 和Set 类似 但是只能存储对象，不可遍历如果其他对象未应用该对象，垃圾回收机制会自动收回所占用的内存适合存储临时对象和绑定对应对象的信息 12345678910const ws = new WeakSet([[1, 2], [3, 4]]); //WeakSet &#123;[1, 2], [3, 4]&#125;//a 的成员自动成为 weakSet 的成员//add 方法let arr =[[1]];ws.add(arr);//delete 删除对应成员ws.delete(arr); //true// has 是否包含ws.has(arr) //false 由于 WeakSet 的成员都是弱引用随时可能被回收，因此可以存储DOM节点，不用担心节点移除时，发生内存泄漏。 1234567891011const foo = new WeakSet() class Foo &#123; constructor()&#123; foo.add(this) &#125; method ()&#123; if(!foo.has (this))&#123; throw new TypeError("method 只能在Foo 实例上使用"); &#125; &#125; &#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[symbol]]></title>
    <url>%2F2019%2F03%2F15%2Fsymbol%2F</url>
    <content type="text"><![CDATA[含义 ES6 引入的原始数据类型，表示独一无二的值通过 Symbol函数生成的原始值，不是对象，所以无法添加属性和方法1234567891011121314151617let s = Symbol();let s1 = new Symbol('s'); //TypeError// 不能通过 new Symbol 否则会报错s.toString()//"Symbol()"let s2 = Symbol();s == s2 // false//独一无二的特性Boolean(s) //true!s // falses + s1 //error s + 1 //error s + "1" // error //symbol 不能参与任何值的运算 对象中的 symbol 无法通过 . 点运算访问123456let sm = Symbol()const s =&#123; [sm]: 1&#125;;s.sm //undefineds[sm]//1 消除魔术字符串 代码中多次出现，与代码形成强耦合的某一个具体的字符串或者数值。123456789101112131415161718192021222324252627282930313233function getDate(num,options)&#123; let data = 1; switch (num)&#123; case 1: data = num + 1; break case 2 : data = num * 2; break &#125; return data&#125;// case 右边的 1， 2 就是魔术数值//一般把魔术字符串 变成变量来消除let obj =&#123; one:Symbol(), two:Symbol()&#125;function getDate(num,options)&#123; let data = 1; switch (num)&#123; case obj.one: data = options + 2; break case obj.two : data = options * 2; break &#125; return data&#125;getDate(obj.one,3) 作为对象属性名 for...in、for...of，Object.keys() , Object.getOwnPropertyNames(),JSON.stringify()返回。 不是私有属性，可以通过 Object.getOwnPropertySymbols()获取指定symbol名123456789let a = Symbol('a');let b = Symbol('b');const obj = &#123; a:1, [a]:'hello', [b]:'word'&#125;console.log(Object.getOwnPropertySymbols(obj)) //(2) [Symbol(a), Symbol(b)] -可以通过 Reflect.ownKeys() 返回所有类型的属性名12345678let a = Symbol('a');let b = Symbol('b');const obj = &#123; a:1, [a]:'hello', [b]:'word'&#125;Reflect.ownKeys(obj) // ["a", Symbol(a), Symbol(b)] Symbol.for()与Symbol() Symbol(‘a’) 和 Symbol.for():两种方法都会生成新的 Symbol 值Symbol(‘a’) 使用10次，会生成10个新的 SymbolSymbol.for(‘a’)，使用10次，会生成一个 Symbol 并创建一个key值Symbol.keyFor(Symbol.for(‘a’)),会返回一个全局 key 值，可以在不同的iframe 或 service worker 获取同一个key 1234567let s = Symbol('a');let s1 = Symbol.for('s');let s2 = Symbol.for('s');s == s1 //falses1 == s2 //truelet key = Symbol.keyFor(s2) //s]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Async/await]]></title>
    <url>%2F2019%2F03%2F14%2FasyncEs8%2F</url>
    <content type="text"><![CDATA[ES2017引入async 函数 Generator 的语法糖 1234567891011121314151617181920212223242526272829//generatorconst fs = require('fs');const readFile = function (path) &#123; return new Promise(function (resolve,reject) &#123; fs.readFile(path, function(err,data) &#123; if (err) return reject(err); resolve(data); &#125;); &#125;);&#125;;const g = function* () &#123; const f1 = yield readFile(url1); const f2 = yield readFile(url2);&#125;// asyncconst asyncFile = async function () &#123; const f1 = await readFile(url1); const f2 = await readFile(url2);&#125;/** * 将 g 函数的 * 变成 axync * 将 yield 变成 await */ async 对 generator 进行以下优化 不再需要调用 next 方法就能执行 更加语义化 实用性更强 await 后面可以是 Promise , 原始类型值（会自动转成立即 resolved 的 Promise 对象） 返回值为Promise 对象更加方便，当函数执行遇到 await 时暂停执行，等到异步操作完成，再执行后面的代码 async 函数 return 的返回值会成为 then 方法的参数 async 函数内部抛出错误 将会被 catch方法接收 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// examplefunction timeout(ms) &#123; return new Promise(resolve =&gt; setTimeout(resolve,ms))&#125;async function asyncPrint(val, ms ) &#123; await timeout(ms); console.log(val)&#125;asyncPrint('Owen',1000) //1s 后 "Owen"//因为 asnyc 返回 Promise 所以可以改用 asyncasync function timout(ms) &#123; await new Promise(resolve =&gt; setTimeout(resolve,ms));&#125;async function asyncPrint(val, ms ) &#123; await timeout(ms); console.log(val)&#125;asyncPrint('Owen',1000) //1s 后 "Owen"/* 定义 async 函数 *///声明async function f()&#123;&#125;//表达式const fn = async function () &#123;&#125;;// 对象const obj = &#123; async f()&#123;&#125;&#125;// class class Storage &#123; async getAvatar(name) &#123; &#125;&#125;//箭头函数const foo = async () =&gt; &#123;&#125;;/* then方法接收return 的参数 */async function foo ()&#123; return "Owen"&#125;foo().then(re =&gt;console.log(re)); //Owen/* 接收错误对象 */async function fn ()&#123; throw new Error(18)&#125;fn().catch(er =&gt;console.log(er)) //error asyn回调只有等所有 await 后面的Promise 执行完毕或者报错和return才会执行。 123456789101112async function fn() &#123; var time = + new Date() console.log(time,1) let p1 = await new Promise(resolve =&gt; setTimeout(resolve,1000)); console.log(+ new Date() - time ,2) let p2 = await new Promise(resolve =&gt; setTimeout(resolve,2000)); return +new Date() - time;&#125;fn().then(time =&gt; console.log(time,3));// 1s 1// 2s 2// 3s 3 await await 后面是 thenable 对象，会和返回 promise 对象 一样返回结果 123456789101112131415161718class Sleep &#123; constructor(timeout) &#123; this.timeout = timeout; &#125; then(resolve, reject) &#123; const startTime = Date.now(); setTimeout( () =&gt; resolve(Date.now() - startTime), this.timeout ); &#125;&#125;(async () =&gt; &#123; const actualTime = await new Sleep(1000); console.log(actualTime);&#125;)(); 如果 await 后面的Promise 状态为 rejected 那么结果将会传递给 catch 方法；并且函数会中断执行,除非使用 try..catch 或者 对应的 Pomise 使用 catch方法 。 12345678910async function ay () &#123; await Promise.reject(18).catch((err) =&gt; &#123; console.log(err) &#125;) return "Owem"&#125;ay().then(res =&gt;console.log(res))//18//Owem 多个 await 后面的异步，如果不存在继发关系，最好同时触发 1234567891011async function fn() &#123; var time = + new Date() console.log(time,1) let [p1,p2] = await Promise.all([ new Promise(resolve =&gt; setTimeout(resolve,1000)), new Promise(resolve =&gt; setTimeout(resolve,2000))]); return +new Date() - time;&#125;fn().then(time =&gt; console.log(time,2)); 只能再 async 函数中使用 await 12345678async function ay () &#123; function ()&#123; await 1 &#125; return "Owem"&#125;ay() //error async 原理 将Generator 函数和执行器包装再一个函数中 1234567891011121314151617181920212223function autoactuator (gen) &#123; return new Promise((resolve,reject) =&gt; &#123; const g = gen(); let step = (next) =&gt; &#123; let n; try&#123; n = next(); &#125;catch(err) &#123; return reject(err) &#125; if(n.done)&#123; return resolve(n.value) &#125; Promise.resolve(next.value).ten((v) =&gt;&#123; step(() =&gt; g.next(v)); &#125;,function(e)&#123; setp(() =&gt; g.throw(e)); &#125;); &#125; step(() =&gt; g.next(undefined)); &#125;)&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pormise]]></title>
    <url>%2F2019%2F03%2F14%2Fpromise%2F</url>
    <content type="text"><![CDATA[Promise 为了解决 “回调地狱”（callback hell）而提出的写法允许将 callback 变成链式调用它是一个容器，保存着某个异步操作的结果。 特点 对象的状态部受外界影响；有三种状态， 进行中( pending ) 、 成功( fulfilled ) 、 失败( rejected );只有异步操作的结果可以决定那种状态。 状态一旦改变，就不会更改（resolved 定型），状态的改变只会是两种情况 pengding -&gt; fulfilled or pengding -&gt; rejected; 一旦建立就会立即执行 , 中途无法取消，无法得知事件进展，不设置callback，内部将会抛出错误 简单实列 使用 Promise 构造函数生成实例12345678910111213141516171819//exampleconst promise = new Promise(function (resolve,reject) &#123; //... do something $.get(url,function (data) &#123; if (data) &#123; resolve(data) &#125; &#125;).fail(function(err)&#123; reject(err) &#125;) &#125;);promise.then(function(data) &#123; console.log(data)&#125;,function(err)&#123; console.log(err)&#125;) 可见 Promise 接受一个callback 作为参数， callback有两个参数，都是函数 第一个 resolve 异步操作成功时调用，将成功的信息作为参数传递出去 第二个 rejcet 异步操作失败时调用，将失败的信息传递出去 then 方法生成实例后,可以使用 then 方法 接收成功状态和失败状态的回调,在当前脚本所有同步任务执行完才会执行 第一个参数是成功后的callback (必传) 第二个参数是失败后的callback (为可选参数) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108const promise = (time) =&gt; &#123; return new Promise((resolve,reject) =&gt; &#123; console.log("promise") setTimeout(resolve,time,'Owen') &#125;)&#125;promise(1000).then((val) =&gt; console.log(val)) //"promise" 1s后 "Owen"//加载图片function loadImage (url) &#123; return new Promise((resolve,reject) =&gt; &#123; const image = new Image(); image.onload = () =&gt; resolve(image); image.onerror = () =&gt; reject(new Error(`not lad image at: $&#123;url&#125;`)) image.src = url; &#125;)&#125;//实现原生ajax(get)const getJSON = function (url) &#123; return new Promise((resolve, reject) =&gt; &#123; const handler = function () &#123; if ( this.readySate !== 4 ) return; if (this.status === 200 ) &#123; resolve(this.response) &#125;else &#123; reject( new Error(this.statusText) ) &#125; &#125;; const client = new XMLHttpRequest(); client.open("GET",url); client.onreadystatechange = handler; client.setRequestHeader("Accept", "application/json"); client.send() &#125;);&#125;getJSON('url').then((res) =&gt; &#123;console.log(res)&#125;,err =&gt; console.error(err));//---console.log(1)const p1 = new Promise(function (resolve, reject) &#123;console.log(2) resolve();&#125;); console.log(3)const p2 = new Promise(function (resolve, reject) &#123; console.log(4) resolve(p1);&#125;)setTimeout( function () &#123; console.log(5)&#125;,0)window.requestAnimationFrame(function(v)&#123; // 回调函数执行次数通常是每秒60次 // 当requestAnimationFrame() 运行在后台标签页或者隐藏的&lt;iframe&gt; 里时， // requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。 //回调函数会被传入DOMHighResTimeStamp参数 （排队的回调开始触发的时间戳） console.log(8,v) //cancel​Animation​Frame(requestId) 取消 window.requestAnimationFrame&#125;)p2.then(function()&#123; console.log(7)&#125;)p1.then(function()&#123; console.log(6)&#125;)//p1的状态决定了p2的状态//1//2//3//4// 6// 7//&#123;&lt;resolved&gt;: undefined&#125;// 8// 5//向另一个 promise 传递 promise 执行状态问题const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123;reject(new Error('fail')); console.log(1)&#125;, 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt;&#123;console.log(2); resolve(p1) &#125;, 1000)&#125;)p2.then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error)) //error fail//传入的 promise 会改变 自己 promise 的状态，变成传入的promise的状态 catch 方法 指定发生错误时的回调函数。 12345678910111213141516171819202122232425262728293031323334p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err));//状态改变后不会再接收之后的状态const promise = new Promise(function(resolve, reject) &#123; resolve('ok'); reject( new Error('test'));&#125;);promise .then(function(value) &#123; console.log(value) &#125;) //ok .catch(function(error) &#123; console.log(error) &#125;);// promise 内部错误不会影响外部的代码，不会退出进程、终止脚本执行const promise = new Promise(function(resolve, reject) &#123; resolve(Owen); &#125;);promise.catch(function(error)&#123;console.log(error)&#125;).then(function(v)&#123;console.log('Owen:' + v)&#125;)console.log(18)//18//error//Owen:undefined //如果将 then 放到第一个将不会执行 //因为 then 接收的是 promise变量 的状态 //而放到末尾则接收的是 catch 返回的 Promise 函数的状态 finally不管 promise 的状态怎么变都会执行的方法 （ES2018) 12345678910111213141516//finally方法的回调函数不接受任何参数promise.finally(() =&gt; &#123; // 语句&#125;);// 等同于promise.then( result =&gt; &#123; // 语句 return result; &#125;, error =&gt; &#123; // 语句 throw error; &#125;); all 用于将多个 Promise 实例，包装成一个新 Promise 实例 参数是一个数组或者具有 Interator的接口（返回成员必须是promise)，如果成员不是 Promise 实例，会将其包装成一个porimse 实例 等待所以成员的状态都变成 resolved 状态， Promise.all 才变成 resolved 状态，并且成员返回值将以数组形式传递给 then 数组成员中只有又一位成员为rejectd 状态，Promise.all 就会变成 rejected , 并将第一个变为rejectd的成员返回值传递给 catch 如果成员自己定义了 then 或者 catch 对应成员的返回值不会传递到 all 的回调当中 123456789101112//exampleconst p1 = new Promise((resolve,reject) =&gt; setTimeout(resolve,1000,'Owen')) //.then(result =&gt;console.log(result)) // .catch(err =&gt;console.log(err));const p2 = new Promise(res =&gt; &#123; throw new Error('报错了');&#125;) .then(re =&gt; console.log(re)) .catch(err =&gt; console.log(err));//error const promise = Promise.all([p1,p2]) .then(res=&gt;console.log(res)) //1s 后 ["Owen",undefined] .catch(err =&gt; console.log(err)); race 和 all 方法一样 只是成员状态发生改变的情况不同 数组中只要有一个成员改变状态， race 就改变状态，并将返回值传递给 race方法 123456789101112//exampleconst p1 = new Promise((resolve,reject) =&gt; setTimeout(resolve,1000,'Owen')) //.then(result =&gt;console.log(result)) // .catch(err =&gt;console.log(err));const p2 = new Promise(res =&gt; &#123; throw new Error('报错了');&#125;) .then(re =&gt; console.log(re)) .catch(err =&gt; console.log(err));//error const promise = Promise.race([p1,p2]) .then(res=&gt;console.log(res)) //undefined .catch(err =&gt; console.log(err)); resolve 将对象转化为Promise对象123Promise.resolve('Owen')// 等同new Promise(resolve =&gt; resolve('Owen')) 传参情况 Promise实例 返回出入的实例 传入 thenable对象 具有 then方法的对象,将其转化为 Promise 对象 12345678910var obj = &#123; then: function(resolve,reject)&#123; resolve("Owen") &#125;&#125;var p = Promise.resolve(obj);p.then(function(res)&#123; console.log(res) //"Owen"&#125;) 不是对象或者没有 thenable方法 返回一个新的Promise，状态为 resolved1234const p = Promise.resolve(18);p.then(function(re)&#123; console.log(re) //18&#125;) reject 返回一个新的Promise，状态为 rejectd123456789101112131415const p = Promise.reject('出错了');// 等同 const p = new Promise((resolve, reject) =&gt; reject('出错了'))const thenable = &#123; then(resolve, reject) &#123; reject('出错了'); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable) //true&#125;) 结合 Generator 使用12345678910111213141516171819202122232425262728293031323334const g = function* () &#123; try &#123; const foo = yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function getFoo () &#123; return new Promise(function (resolve, reject)&#123; resolve('foo'); &#125;);&#125;function run (generator) &#123; const it = generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(g); Promise/A+ 规范 实现者为开发者提供开放的 Promise标准，实现可靠，可互操作的JavaScript承诺。 术语（Terminology） promise 是一个对象或函数，其then 方法 的行为符合此规范 thenable 定义 then 方法的对象或函数 value 是任何合法的 JavaScript 值 （包括 undefined 、thenable 和 promise） exception 是使用 throw 语句抛出的值 reason 是一个值（拒因），表明承诺被拒绝的原因（拒绝回调的值） 要求（Requirements）Promise states Promise 只有三种状态：pending 、 fulfilled（resolved） 和 rejected 状态 pending（等待状态）：可以过渡到 resolved 或 rejected 状态 fulfilled (执行状态）：无法再改变状态，且只有一个无法改变的value rejected （拒绝状态）：无法再改变状态，必须有一个 reason 这里的 ‘无法再改变’ 意味着不可改变的身份 使用 === 判断 value 或 reason then 方法（The then method） 一个 Promise 必须提供一个 then 方法来访问当前 或 最终value 或 reason此方法接收两个参数： onFulfilled,onRejected 必须忽略其中不是函数是参数 onFulfilled：必须在 promise 执行状态（fufilled ）结束后调用，其第一个参数为 value，只能调用一次 onRejected： 必须在 promise 拒绝状态（rejected ）结束后调用, 其第一个参数为 reason，只能调用一次 onFulfilled or onRejected 在执行上下文 (作用域)堆栈仅包含平台代码之前不得调用意味着调用 onFulfilled,onRejected 须在新一轮 event loop 中执行， 可用 macro-task（setTimout,setInterval,I/O,UI rendering, script主线程) 或 micro-task（Promise, Object.observe,process.nextTick,MutationObserver） 机制来实现 onFulfilled or onRejected 必须作为函数调用，在 use strict 下 this 为 undefined then在同一个 promise 中可以链式调用，按照对应注册顺序一次回调 then返回一个Promise对象 1promise2 = promise1.then(onFulfilled, onRejected); 任一 onFulfilled或onRejected返回一个值x ,则执行 Promise 解决过程 onFulfilled或onRejected 抛出异常 e, 则 promise2 必须拒绝执行，并返回 reason 如果onFulfilled 不是函数且 Promise1 为执行 fulfilled状态，那么 promise2 必须返回和 Promise1 相同的value 如果onRejected不是函数且 Promise1 为 rejected状态，那么 promise2 必须返回和 Promise1 相同的reason Promise 解决过程 (The Promise Resolution Procedure) Promise 解决过程是一个抽象的操作，作为输入一个Promise,和一个值，用 [[Resolve]](Promise2,x) 表示；如果 x 有 then 方法并且看上去像一个Promise,Promise 解决过程程序会尝试promise采用状态 x，否则用 x 的 value执行Promise;对thenables的这种处理使promise的实现进行互操作，只要它们暴露出一个遵循 Promise/A+规范 兼容then方法即可。它还允许Promise/A+规范来“吸收”与合理不符合标准的实现then方法。 运行 [Resolve] 需遵循以下步骤： 如果promise和x指向同一个对象，以TypeError为理由拒绝执行promise。 如果 x 是 promise，则接收其状态： 2.1 如果 x 为 pending， 则 Promise 保持等待直至 x改变状态 2.2 如果 x 为 resolved，则 用相同的 value 执行 promise 2.3 如果 x 为 rejected，则 用相同的 reason执行 promise 如果 x 是 Object or Function: 3.1 把 x.then 赋值给 then 3.2 如果 xthen 抛出异常 结果 e，promise 状态变为 rejected，reason 为 e 3.3 如果 then是一个函数，将x作为函数作用域 this 调用，传递两个回调函数作为参数，第一个为 resolvePromise, 第二个参数为 rejectPromise3.3.1 如果 `resolvePromise` 以值 `y`为参数被调用，以 `r`为 `reason` ，则运行 `[[Resolve]](promise, y)` 3.3.2 如果 `rejectPromise` 用`r`为参数调用 ，则以 `r`拒绝 promise 3.3.3 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用第一次调用并忽略剩下的调用 3.3.4 如果调用then抛出异常`e`，resolvePromise或rejectPromise已被调用，请忽略它；否则以 `e` 为`reason`(据因)拒绝 promise 3.4 如果then不是一个函数, 则以x为参数执行 promise 如果 x不为Object or Function，以 x 为参数执行 promise 如果一个 promise 被一个循环的 thenable 链中的对象解决，而[[Resolve]](promise, thenable) 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为reason(据因)来拒绝 promise 手写简版 Promise 1234567891011121314151617181920212223242526272829303132333435363738// 常用变量大写const PENDING ='pending'const RESOLVEd = 'resolved'const REJECTEd = 'rejected'class myPromise &#123; constructor(callback) &#123; const that = this that.state = PENDING; that.resolveCallback = []; that.rejectCallback = []; const resolve = value =&gt;&#123; if (that.state === PENDING)&#123; that.state = RESOLVED; that.value = value that.resolveCallback.map(cb =&gt; cb(that.value)) &#125; &#125; const reject = value =&gt;&#123; if (that.state === PENDING)&#123; that.state = REJECTED; that.value = value that.rejectCallback.map(cb =&gt; cb(that.value)) &#125; &#125; try &#123; callback(resolve,reject) &#125;catch(e)&#123; reject(e) &#125; &#125; then(onResolved,onRejected)&#123; const that = this &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步操作原理（二）]]></title>
    <url>%2F2019%2F03%2F13%2FeventLoop%2F</url>
    <content type="text"><![CDATA[事件循环(eventLoop) 详解并行和并发： 并行性是指两个或多个事件在同一时刻发生；并发性是指两个或多个事件在同一时间段内发生。 任务队列 和 事件循环 JS 将变量存储在 堆 heap 和 栈 stack中堆中存放对象比如 ：数组，对象，函数栈中存放变量和对象的指针运行时同步任务会排好队，依次执行，而排队的地方就叫执行栈（先进后出） JS运行时，除了有一个主线程运行，引擎还提供任务队列 task queue , 里面是各种需要当前程序处理的异步任务。（不止一个任务队列） 异步任务通常是一个回调函数；如果一个异步任务没有回调函数，是不会放入异步任务队列中，同样也不会进入主线程中执行。 执行过程： 主线程会先执行完所有同步任务 同步任务结束，查看任务队列（先进先出的数据结构，排在前面的事件，优先被主线程读取。）里面的异步任务 查看所有满足执行条件的异步任务，放入主线程中变成同步任务，执行对应的回调函数。 执行完毕再将下一个满足执行条件的异步任务放入主线程中执行。 不断重复前三步操作 只要同步任务执行完毕，JS引擎会不停的监测检查任务队列中的异步任务，将满足执行条件且最先进入的任务加入到执行栈中去执行，如此往复。这种检查机制就叫事件循环 Event Loop 微任务与宏任务异步任务还会分两层： 微任务(micro task) 宏任务(macro task) 主线程会先查看微任务 micro task；如果没有满足条件的任务，再去宏任务中查找；如果有则将所有满足条件的微任务按顺序依次加入到主进程中；执行完毕后再去红任务队列中查找，往复循环。常见宏任务： 定时器 I/O（输入/输出）操作 微任务(jobs)： Promise async/awaitnodeJSnodeJS 中任务队列 加入了 process.nextTick 和 setImmediate。前者比后者先执行123456789101112131415161718192021process.nextTick(function A() &#123; console.log(1); process.nextTick(function B()&#123;console.log(2);&#125;);&#125;);setImmediate(function ()&#123; setImmediate(function A() &#123; console.log(3); setImmediate(function B()&#123;console.log(4);&#125;); &#125;); setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED'); &#125;, 0);&#125;);// 1// 2// 3// TIMEOUT FIRED// 4//这个结果是不确定的可能是 1234 TIMEOUT FIRED || 12 TIMEOUT FIRED 34 其二者的调用顺序取决于当前event loop的上下文，如果他们在异步i／o callback之外调用，其执行先后顺序是不确定的。123456789101112var fs = require('fs')fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout') &#125;, 0) setImmediate(() =&gt; &#123; console.log('immediate') &#125;)&#125;)//immediate//timeout 这是因为fs.readFile callback执行完后，程序设定了timer 和 setImmediate，因此poll阶段不会被阻塞进而进入check阶段先执行setImmediate，后进入timer阶段执行setTimeout。setTimeout和setImmediate的差异 process.nextTick在最新版nodejs中不被推荐使用，推荐使用setImmediate ，原因在于nextTick是在当前帧介绍后立即执行，会阻断I/O并且有最大数量限制；而setImmediate不会阻断I/O，更像是setTimeout(func, 0)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步操作原理(一)]]></title>
    <url>%2F2019%2F03%2F11%2Fasync%2F</url>
    <content type="text"><![CDATA[单线程 javascript 只再一个线程上运行，同时只能执行一个任务，一行一行执行。 javascript 运行在单线程上，并不代表 JavaScript引擎就是单线程的，其实它有多个线程，单个脚本只能在一个线程上运行（主线程），其他线程在后台配合运行。 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 这种模式好处在于， 实现起来简单，环境单纯。 但是 耗时较长，后面的任务必须等待前面的任务执行完毕。 同步和异步任务 同步未被引擎挂起、在主线程上排队执行的任务。需要前面的任务执行完后才能执行。 异步 被引擎挂起，暂不处理的任务,不进入主线程、而进入任务队列; 只有达到某个条件，异步任务才会进入主线程，不会堵塞异步任务后面的代码 （ajax 是最具代表性的异步任务） 异步操作模式回调函数 Callback 将函数传递进一个方法中，函数不会立即执行，等待出来结果之后在执行。回调函数是异步操作最基本的方法 容易出现回调地狱（Callback hell)比如多个 ajax 嵌套请求123456789ajax(url, () =&gt; &#123; // 处理逻辑 ajax(url1, () =&gt; &#123; // 处理逻辑 ajax(url2, () =&gt; &#123; // 处理逻辑 &#125;) &#125;)&#125;) 这种方式容易理解和简单，但是不利于维护和阅读；耦合度高，结构混乱，错误较难追踪，而且每个任务只能指定一个回调。 事件监听 采用事件驱动。W3C规范中定义3个事件阶段：捕获(Netscape)，目标，冒泡（IE）。事件冒泡：在目标元素上发生click事件的顺序 目标元素 -&gt; 父级元素 -&gt; body -&gt; html -&gt; document事件捕获： 与冒泡相反，document -&gt; html -&gt; body -&gt; 父级元素 -&gt; 目标元素 123456789101112131415161718// 原生事件委托 var parent = document.getElementById('parent'); parent.addEventListener('click',showColor,false); function showColor(e)&#123; var son = e.target; if(son.nodeName.toLowerCase() === 'li')&#123; console.log('The color is ' + son.innerHTML); &#125; &#125; //类似 jQuery写法 fn.on('click',function()&#123;&#125;); //等同于 function fn ()&#123; setTimeout(function()&#123; //do someing fn.trigger('done') &#125;,1000) &#125; 这种方法比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，可以去“耦合”(decoupling),便于实现模块化。 但是整个程序都会变成事件驱动，流程不清晰。 发布/订阅 消息的发送者（称为发布者） 不会将消息直接发送给特定的接收者（称为订阅者），而是将不消息分为不同的类别，不需要了解哪些订阅者；订阅者,只接收感兴趣的消息，不需要了解哪些发布者可以把事件理解成“信号”,如果存在一个“信号中心”； 某个任务执行完成，就向信号中心“发布” (publish) 一个信号，其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己开始执行 1234567891011121314var obj = $(&#123;&#125;);obj.on("aaa", function () &#123; console.log(111111111111); &#125;)obj.on("aaa", function () &#123; console.log(222222222222); &#125;)$(dom).click(function() &#123; obj.trigger("aaa"); &#125;); 当 foo 执行完毕后，想消息纵向发布 done信号，引发执行fn 消息过滤订阅者通常接收信号中心中(消息代理)的一个子集，选择接受和处理的消息过程叫过滤过滤形式 基于主题 消息被发布到主题或命名通道上；订阅者将受到所有信息，并且所有订阅同一主题的订阅者都将收到同样的信息；发布者赋值定义订阅者所订阅的消息类别 基于内容 订阅者定义感兴趣的条件，只有当消息的属性或内容满足订阅者的条件，消息才投递到该订阅者。订阅者负责堆消息分类。 拓扑发布者 发布消息到一个消息代理，订阅者向其注册订阅，由消息代理来过滤 优缺点： 松耦合，发布者和订阅者只需要关注主题内容，相互独立地运行。 扩展性强，通过并行操作，消息缓存，基于树或网路路由等技术，比传统客户端具有更好的扩展性。 缺点： 发布者解耦订阅者，问题难以跟踪，无法知道消息传送是成功的还是失败的 异步操作的流程控制（多个异步操作如何确定异步操作的执行顺序，如何保证这种顺序执行）串行执行 一个任务执行完毕后，再执行另一个 123456789101112131415161718 let arr = [1,2,3,4,5]; let results = [];const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res);const series = item =&gt;&#123; if(item)&#123; async(item,result=&gt;&#123; results.push(result); return serise(items.shift();) &#125;) &#125;else&#123; return final(results[results.length-1]); &#125;&#125;series(items.shift()); 上面代码 series 就是一个串行函数； 类似与同步任务 并行执行 所有异步任务同时执行，全部执行完毕，再执行 最终 (final) 函数 12345678910111213141516 let arr = [1,2,3,4,5]; let results = [];const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res); for (let item of items)&#123; async(item,(result) =&gt;&#123; results.push(result) &#125;) if(results.length == items.length)&#123; final(results[results.length-1]); &#125; &#125; 上面代码，for 循环会同时执行5异步任务，等他们执行完毕再执行 final 函数。 过个并行任务较多，容易耗尽系统资源，拖慢运行 并串结合 限制并行执行任务的数量，避免占用过多系统资源 1234567891011121314151617181920let items = [1,2,3,4,5];let results = [];let running = 0,limit = 2;const async = (arg,callback)=&gt;&#123; console.log(`参数：$&#123;arg&#125;，1秒后返回`); setTimeout(()=&gt;callback(arr*2)&#125;,1000); &#125; const final = res =&gt; console.log(`完成：`,res);const launcher = () =&gt; &#123; while (running &lt; limit &amp;&amp; items.length&gt;0)&#123; let item = items.shift()； async (item,(res)=&gt;&#123; results.push(result); running--; items.length? launcher(): final(results); &#125;) running++ &#125;&#125; 上面代码，最多只能运行两个异步任务，当前 running 记录运行的任务数量，低于门槛 limit 就会新增一个任务，直到任务执行完毕。 轮询12345678let hash = window.location.hash;const hashWatcher = () =&gt;&#123; if(window.location.hash != hash)&#123; updatePage() &#125;&#125;setInterval(hashWatcher,1000) setInterval 时间 间隔是” 开始执行 “ 之间的间隔,不会考虑每次执行的任务时间，所以两次执行间隔会小于指定时间。比如 指定 100ms 任务本身消耗 105 ms，那么第一次执行完毕后，第二次会立即执行。 如果要固定间隔，可以使用 setTimeout12345678let hash = window.location.hash;const hashWatcher = () =&gt;&#123; if(window.location.hash != hash)&#123; updatePage() &#125; setTimeout(hashWatcher,1000)&#125;setTimeout(hashWatcher,1000) 注意： HTML标准规定 setTimeout 最小间隔 4ms 由于定时器每执行一次,会返回一个整数，连续执行，返回值比上一次大1 123456789101112131415161718 (function() &#123; // 每轮事件循环检查一次 var gid = setInterval(clearAllTimeouts, 1000); function clearAllTimeouts() &#123; var id = setTimeout(function() &#123; console.log("g:"+gid) &#125;,0); while (id &gt; 0) &#123; if (id !== gid) &#123; clearTimeout(id); &#125; id--; &#125; &#125;&#125;)(); 防抖（debounce） 在某些场景下不希望事件执行太频繁，我们可以设置一个阀门临界值，再一段时间内只执行一次,或者一段时间过后执完所有任务 123456789101112131415161718192021222324252627282930//一段时间只执行一次let perform = (fn,time) =&gt; &#123; let flag = true; return function () &#123; let self = this,arg = arguments; if(flag)&#123; flag = false; fn.apply(self,arg); setTimeout(() =&gt; &#123; flag = true &#125;,time) &#125; &#125;&#125;let fn = () =&gt; console.log(1);setInterval(perform(fn,2000),500); // 经过一段时间再执行所有要执行的任务 let debounce = (fn,delay) =&gt;&#123; let timer = null; return function ()&#123; let self = this,arg = arguments; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(self,arg) &#125;,delay) &#125; &#125;setInterval(perform(fn,2500),500); 参考原文链接： http://wangdoc.com]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发(二)]]></title>
    <url>%2F2019%2F03%2F07%2Fmodularization%2F</url>
    <content type="text"><![CDATA[ES6 详解 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。 顶层的this指向undefined，即不应该在顶层代码使用this。 严格模式主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface）上面这些限制，模块都必须遵守。 export命令 export除了输出变量，还可以输出函数或类（class）,还可以通过 as 更改输出名。 12345678let age = 18;let obj =&#123;name: "Owen"&#125;;let multiply = (x, y) =&gt; x * y;export &#123; age, obj as monicker, //改变量名 multiply&#125; 导出的对象必须是对外的接口 1234let num =2;export num ; //error 因为实际输出的是一个值，须放在对象中 &#123;num&#125;exprot 2 //error 输出的是值 而不是一个对外接口 =&gt; 须改成 export let num =2； 不能放到局部作用域中导出， 因为导出的对象是动态绑定的12let foo = (r) =&gt; r++;let fn = () =&gt; export default foo; //error export default 全局只能有一个 export default export default 后面不能有 变量声明的关键字 使用 export default ，import 就不需要使用 {},只需要自定义一个变量即可 123456export default var a=1; //errorexport default obj =&#123;name:'Owen'&#125;;//orlet num = 1;let obj1 = &#123;name:"Owen"&#125;;export default &#123;num, obj1&#125; import 配合 from 导入模块, 通过 as 修改导入接口, 接口不能重新赋值，但对象可以修改内部属性或方法。 12345import &#123;age, monicker as obj, multiply&#125; from './preson.js'; age = 0 ; //error obj.feature = "handsome Owen"; console.log(age, obj。name, multiply(1,2)) import * as preson from "./preson.js" //引入所有接口 import 具有提升的效果，会提升到作用域顶部执行，同一个模块多次引入只执行一次，并且不能再局部作用域中引入。 12345678multiply(2,2); //4import &#123;age, monicker as obj, multiply&#125; from './preson.js';if (true)&#123;import &#123;age, monicker as obj, multiply&#125; from './preson.js'; //error&#125; import() 因为require是运行时加载模块，import命令无法取代require的动态加载功能。因此，有一个提案，引入import()函数，完成动态加载。 import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。 和 require类似，不同之处在于 import()是同步加载 require()是异步加载 1const path =import('path'); 我们可以利用 import() 进行按需加载,动态加载，按条件加载: 12345678910import('./a.js') .then(r =&gt; &#123; r.fn(); &#125;) .catch(error =&gt; &#123; /* Error handling */ &#125;)if( x == 1)&#123; const path =import('path');&#125; 如果想同时加载多个模块，可以采用下面的写法 123456789 Promise.all([ import('./a.js'), import('./b.js'), import('./c.js'),]) .then(([a,b,c]) =&gt; &#123; // ... &#125;).catch(error =&gt; &#123; /* Error handling */ &#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>moduleDevelop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 升级 webpack4 配置]]></title>
    <url>%2F2019%2F03%2F07%2Fwebpack%2F</url>
    <content type="text"><![CDATA[升级webpack4 先删除之前的webpack1npm i -D webpack webpack-cli webpack-dev-server build/base.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119const os = require('os') //node OS模块 可查看主机系统相关信息const path = require('path') //node path模块 c处理文件路径const utils = require('./utils') //vue-cli封装的公用模块const webpack = require('webpack')const config = require('../config')//vue-cli封装的配置const HappyPack = require("happypack")//开启多个子进程去并发执行const HtmlWebpackPlugin = require('html-webpack-plugin')//webpack主要插件，可以简化HTML文件的创建const CleanWebpackPlugin = require('clean-webpack-plugin');//清空打包好的文件const ProgressBarPlugin = require('progress-bar-webpack-plugin')//查看进度const vueLoaderConfig = require('./vue-loader.conf')// 处理less,sass等样式配置文件 const VueLoaderPlugin = require('vue-loader/lib/plugin');const argv = require("yargs-parser")(process.argv.slice(2))//获取运行 scripts 里面的指令 --mode 后面参数 const isPro = argv.mode == "production"const resolve = dir =&gt; path.resolve(__dirname, "..", dir)module.exports = &#123; context: path.resolve(__dirname, '../'), entry: &#123; app: "./src/main.js" &#125;, output: &#123; path: config.build.assetsRoot, filename: '[name].js', publicPath: isPro ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue': 'vue/dist/vue.esm.js', 'src': path.resolve(__dirname, '../src/common'), '@': resolve('src'), '~': resolve('src/components/common'), 'static': path.resolve(__dirname, '../static'), &#125; &#125;, module: &#123; rules: [&#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loaders: 'happypack/loader?id=babel',//配合 happypack插件使用 exclude: /(node_modules|bower_components)/, include: [resolve('src'), resolve('test')] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;, node: &#123; setImmediate: false, dgram: 'empty', fs: 'empty', net: 'empty', tls: 'empty', child_process: 'empty' &#125;, plugins: [ new ProgressBarPlugin(), new CleanWebpackPlugin(), new HappyPack(&#123; id: 'babel', loaders: [&#123; loader: 'babel-loader', options: &#123; babelrc: true, cacheDirectory: true, &#125;, publicPath: "/" &#125;], //共享进程池 threadPool: HappyPack.ThreadPool(&#123; size: os.cpus().length //cpu nunbers &#125;), //允许 HappyPack 输出日志 verbose: true, &#125;), new webpack.DefinePlugin(&#123; 'process.env': &#123; 'NODE_ENV': JSON.stringify(argv.mode) &#125; &#125;), new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true, favicon: './src/assets/img/favicon.ico' &#125;), new webpack.ProvidePlugin(&#123;//引入全局变量 $: 'jquery', jQuery: 'jquery', // 加上这个 &#125;), new VueLoaderPlugin() ]&#125; build/dev.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566'use strict'const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')//可以合并 base.conf 配置文件const baseWebpackConfig = require('./webpack.base.conf')const HtmlWebpackPlugin = require('html-webpack-plugin')const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')//让日志更加友好const portfinder = require('portfinder') //查找开放端口或域接字的简单工具 const HOST = process.env.HOSTconst PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)const devWebpackConfig = merge(baseWebpackConfig, &#123; mode:'development', module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, devtool: config.dev.devtool, devServer: &#123; clientLogLevel: 'warning', historyApiFallback: true, hot: true, compress: true, host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll, &#125;, disableHostCheck: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125;)module.exports = new Promise((resolve, reject) =&gt; &#123; portfinder.basePort = process.env.PORT || config.dev.port portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; process.env.PORT = port devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`], &#125;, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) pluguin1npm i -D happypack html-webpack-plugin clean-webpack-plugin progress-bar-webpack-plugin yargs-parser friendly-errors-webpack-plugin portfinder webpack-merge extract-text-webpack-plugin@next optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin chalk rimraf babel-loader1npm i babel-loader @babel/cli @babel/core @babel/ @babel/preset-env plugin-proposal-class-properties @babel/ plugin-proposal-decorators @babel/ plugin-syntax-dynamic-import @babel/plugin-transform-classes @babel/plugin-transform-runtime -D 1npm i --save @babel/runtime @babel/runtime-corejs2 .babelrc123456789101112131415161718&#123; "presets": [ ["@babel/preset-env", &#123; "useBuiltIns": "usage" &#125;] ], "plugins": [ ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;], "@babel/proposal-class-properties", ["@babel/plugin-transform-runtime", &#123; "corejs": 2 &#125;], "@babel/plugin-syntax-dynamic-import", "@babel/plugin-transform-classes" ]&#125; build/prod.conf.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394'use strict'const path = require('path')const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const CopyWebpackPlugin = require('copy-webpack-plugin')//复制文件和目录const HtmlWebpackPlugin = require('html-webpack-plugin')const ExtractTextPlugin = require('extract-text-webpack-plugin')//提取样式文件，只有extract-text-webpack-plugin@^4.0.0-beta.0 才支持webpack4 //或者使用 mini-css-extract-plugin 用法详见 ![GitHub](https://github.com/search?q=mini-css-extract-plugin)const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin') //用于优化\最小化 CSSconst UglifyJsPlugin = require('uglifyjs-webpack-plugin') // 压缩JS资源const webpackConfig = merge(baseWebpackConfig, &#123; mode: 'production', module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true, usePostCSS: true &#125;) &#125;, devtool: config.build.productionSourceMap ? config.build.devtool : false, output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[chunkhash].js'), chunkFilename: utils.assetsPath('js/[id].[chunkhash].js') &#125;, optimization: &#123; splitChunks: &#123; chunks: 'all', // initial、async和all minSize: 30000, // 形成一个新代码块最小的体积 maxAsyncRequests: 5, // 按需加载时候最大的并行请求数 maxInitialRequests: 3, // 最大初始化请求数 automaticNameDelimiter: '~', // 打包分割符 name: true &#125;, minimizer: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true &#125;), // extract css into its own file new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[hash].css'), allChunks: true, &#125;), new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), new HtmlWebpackPlugin(&#123; filename: config.build.index, template: 'index.html', inject: true, favicon: './src/assets/img/favicon.ico', minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, chunksSortMode: 'dependency' &#125;), new webpack.optimize.ModuleConcatenationPlugin(), new CopyWebpackPlugin([&#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125;]) ] &#125;&#125;)module.exports = webpackConfig build.js123456789101112131415161718192021222324252627282930313233343536'use strict'require('./check-versions')()process.env.NODE_ENV = 'production'const rm = require('rimraf')//删除文件const path = require('path')const chalk = require('chalk')//终端字符串样式const webpack = require('webpack')const config = require('../config')const webpackConfig = require('./webpack.prod.conf')rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; if (err) throw err webpack(webpackConfig, (err, stats) =&gt; &#123; if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, chunks: false, chunkModules: false &#125;) + '\n\n') if (stats.hasErrors()) &#123; console.log(chalk.red(' 构建失败，错误.\n')) process.exit(1) &#125; console.log(chalk.cyan(' Build success.\n')) console.log(chalk.yellow( ' 打包文件应该通过HTTP服务器启用.\n' )) &#125;)&#125;)]]></content>
      <categories>
        <category>package</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发(一)]]></title>
    <url>%2F2019%2F03%2F07%2Fmodule%2F</url>
    <content type="text"><![CDATA[什么是模块化 将一组模块（及其依赖项）以正确的顺序拼接到一个文件（或一组文件）中的过程。 传统的模块化做法。 模块是实现特定功能的一组属性和方法的封装。 将模块写成一个对象，所有的模块成员都放到这个对象里面。1234567var module1 = new Object(&#123; _count:0, f1:function()&#123;&#125;, f2:function()&#123;&#125;&#125;)module1.f1()module1.f2() 上面的对象可以改变里面的属性和方法，不安全 123456789var module1 = （function()&#123; var count=0; return &#123; f1:function()&#123;&#125;, f2:function()&#123;&#125;&#125;&#125;());module1.f1()module1.f2()module1.count //undefined 使用立即执行函数 将相应的方法和属性封装在函数中,这样就不会暴露私有成员 利用构造函数封装对象12345678910111213function Father ()&#123; var arr =[]; this.add = function (val)&#123; arr.push(val) &#125; this.toString = function()&#123; return arr.join(''); &#125;&#125;var a = new Father();a.add(1);//[1]a.toString();//"1"a.arr // undefined 上面的函数将 arr 变成私有变量，在函数外部无法访问，但是形成了闭包，非常耗费内存；违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。12345678910111213function ToString() &#123; this._buffer = [];&#125;ToString.prototype = &#123; constructor: ToString, add: function (str) &#123; this._buffer.push(str); &#125;, toString: function () &#123; return this._buffer.join(''); &#125;&#125;; 虽然上面的构造函数未生成闭包，但是外部可以修改方法和属性，不安全 放大模式如果一个模块很大或者一个模块需要继承另一个模块可以利用立即执行函数的特效来封装123456var module1 = (function(m1)&#123;mod1.col=function()&#123; console.log(this)&#125;;return mod1;&#125;(window.modlue2 ||&#123;&#125;)) //有些模块可能是null 确保函数正常执行 采用兼容模式 window.modlue2 ||&#123;&#125; 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。123var module1 = (function ($, Swiper) &#123; //...&#125;(jQuery, Swiper)); 上面的 module1 引入 jQuery 和 Swiper 当做两个参数传入模块中，保证了模块的独立性，还使得模块之间的依赖关系变得明显。 立即执行函数还可以起到命名空间的作用。123456789101112131415161718192021(function($, window, document) &#123; function go(num) &#123; &#125; function handleEvents() &#123; &#125; function initialize() &#123; &#125; function dieCarouselDie() &#123; &#125; //attach to the global scope window.finalCarousel = &#123; init : initialize, destroy : dieCarouselDie &#125;&#125;( jQuery, window, document )); 以上都有一个共同点:使用单个全局变量箭头代码包装在函数中，使用闭包建立私有空间但是都有缺点： 不知道模块(库) 的加载顺序 还是有可能引起命名冲突，比如两个库都有相同的名称，或者使用哪个版本有几种良好实施的方法：CommonJS、AMD和CMD。可以解决以上的缺陷 CommonJS CommonJS 是一种思想, 本质上是可复用的JavaScript,它导出特定的对象，提供其它程序使用。 由于 JavaScript 没有模块系统、标准库较少、缺乏包管理工具,因此CommonJS是为它的表现来制定规范。 每个JavaScript 文件 都将模块存储在自己独有的作用域中。 需要使用 module.exports 和 exports.obj 来导出对象，并在需要它的程序中使用 require(&#39;module&#39;) 加载 1234567891011121314151617181920 //文件1 function myModule() &#123; this.hello = function() &#123; return 'hello!'; &#125; this.goodbye = function() &#123; return 'goodbye!'; &#125;&#125;module.exports = myModule; //文件2 var myModule = require('myModule');var myModuleInstance = new myModule();myModuleInstance.hello(); // 'hello!'myModuleInstance.goodbye(); // 'goodbye!' 实现原理 123456789101112var module1 = &#123; export1:&#123;&#125;&#125;;(function (module,exports)&#123; exports.add = functon(val)&#123; return val *10 &#125;&#125;(module1,module1.export1));var fn = module1.export1.add;fn(2)//20 利用立即执行函数 接受两个参数 module 和 exports， 模块就通过立即执行函数赋值，然后导出模块，即可实现模块的加载这种方法的好处： 避免全局污染 明确依赖项目 语法清晰缺点： 由于 CommonJS 采用服务器优先方法并且同步加载模块，因此在浏览器中使用它会阻止浏览器运行其他内容，直到加载完成。 我们可以使用 AMD 来异步加载 AMD(Asynchromous Module Definition) 定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。 AMD模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 定义了一个函数 define，通过 define 方法定义模块。 1234 define(['myModule', 'myOtherModule'], function(myModule, myOtherModule) &#123; console.log(myModule.hello());&#125;); 上面的 define 函数将每个模块的依赖项，以数组的形式作为参数。 这些依赖项会在后台异步加载，一旦加载完成，define 函数就调用模块给出的回调函数myModule 可能像下面一样定义： 1234567891011 define([], function() &#123; return &#123; hello: function() &#123; console.log('hello'); &#125;, goodbye: function() &#123; console.log('goodbye'); &#125; &#125;;&#125;); CMD(Common Module Definition) CMD由玉伯大佬提出并用于SeaJS CMD 和 AMD 很相似，都有 define 函数， 通过 require 加载 CMD和AMD 不同点： 对于依赖的模块 CMD 延迟执行， AMD 提前执行(requireJS 高版本也开始延迟执行) CMD使用依赖就近原则（按需加载）： 12345678910111213141516 define(function(require, exports, module) &#123; var near = require('./a') near.doSomething() // 此处略去 100 行 var nearOne = require('./b') // 依赖可以就近书写 nearOne.doSomething() // ... &#125;) ``` - AMD使用依赖前置原则（必须先加载完依赖）： ```javascript define(['./a', './b'], function(nearTow, nearThree) &#123; // 必须一开始加载 nearTow.doSomething() // 此处略去 100 行 nearThree.doSomething() ... &#125;) CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。 AMD 和 CommonJS 不同点：AMD： 采用浏览器优先的方法，异步加载，主要用于浏览器 先加载依赖项 依赖项可以说 对象、函数、构造函数、字符串等等其他JS类型 CommonJS: 采用服务器优先的方法，同步加载，主要用于服务器 支持对象作为模块共同点： 先加载依赖项 通用模块定义 UMD 同时支持 AMD和 CommonJS本质 创建了一种方法来使用两者的任何一种，同时支持全局变量定义，(JS兼容性的常用思想)所以 UMD 可以在客户端和服务器上工作1234567891011121314151617181920(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['myModule', 'myOtherModule'], factory); &#125; else if (typeof exports === 'object') &#123; // CommonJS module.exports = factory(require('myModule'), require('myOtherModule')); &#125; else &#123; root.returnExports = factory(root.myModule, root.myOtherModule); &#125;&#125;(this, function (myModule, myOtherModule) &#123; function notHelloOrGoodbye()&#123;&#125;; function hello()&#123;&#125;; function goodbye()&#123;&#125;; return &#123; hello: hello, goodbye: goodbye &#125;&#125;)); ES6模块（即 ES2015/ECMAScript 6、ES6） 使用 import 关键字引入模块，通过 export 关键字导出模块 ES6目前无法在浏览器中执行,只能通过babel将不被支持的import编译为当前受到广泛支持的 require。 12345678910111213141516171819//a.jsexport let cun =1; export function add() &#123; cun++;&#125;//----------------import &#123; cun, add &#125; from './a.js';console.log(cun); // 1incCounter();console.log(cun); // 2export var fo ='a';setTimeout(() =&gt; fo ='b',500);import &#123;fo&#125; from './a.js';console.log(fo);//'a'setTimeout(()=&gt; console.log(fo),500)//'b'//ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。fo = 's' //error ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。CommonJS、AMD和CMD相比: ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 ES6 对外接口只是一种静态定义，在代码静态解析阶段就会生成。 ES6 module编译时输出接口(加载)，输出的是值的引用。(静态编译) CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。 CommonJS 模块运行时加载，输出的是一个值的拷贝。(动态编译)一旦输出一个值，模块内部的变化就影响不到这个值。12345678910111213141516171819202122232425// lib/counter.jsvar counter = 1;function increment() &#123; counter++;&#125;function decrement() &#123; counter--;&#125;module.exports = &#123; counter: counter, increment: increment, decrement: decrement&#125;;// src/main.jsvar counter = require('../../lib/counter');counter.increment();console.log(counter.counter); // 1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>moduleDevelop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(三)]]></title>
    <url>%2F2019%2F03%2F05%2Foop3%2F</url>
    <content type="text"><![CDATA[对象继承A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。 JavaScript 语言的继承不通过 class，而是通过“原型对象”prototype实现 传统原型链式继承 过多的继承属性 比如一个函数用不到某个原型方法或属性，那么方法或属性就过剩了123456789101112function Grand()&#123;&#125;;Grand.prototype.name="grand";let grand = new Grand();Father.prototype=grand;function Father()&#123;&#125;let father = new Father();Son.prototype=father;function Son()&#123;&#125;let son = new Son(); 借用构造函数 使用call/appply 不是真正继承，因为不能调用原型上的方法，而且每调用一次都会调用多次函数，实际上步骤没有变少 工业级推荐使用 缺点无法添加私有原型 123456789101112 function Father() &#123; &#125;function Son() &#123; Father.call(this); // 调用父类构造函数&#125;Son.prototype.print = function() &#123; Father.prototype.print.call(this);//只使用单个方法&#125;// 子类继承父类的原型Son.prototype = Object.create(Father.prototype);Son.prototype.constructor = Son; 共有原型1234567891011Father.prototype =&#123; name:"common"&#125;function Father()&#123;&#125;Son.prototype = Object.create(Father.prototype)function Son()&#123;&#125;function inherit (Target,Origin)&#123;//继承源 Target.prototype = Origin.prototype;&#125; 圣杯模式 隐式附加的东西就私有化，可以公共定义的东西提取出来公有化1234567891011let inherit =(function()&#123; let Interim =function Interim() &#123;&#125;; return function (Target,Origin)&#123;//继承源 Interim.prototype =Object.create(Origin); Target.prototype = Interim.prototype; //现在 可以 制定自己的私有属性，但是 constuctor 不是 原函数所一手动赋值回来，如果想要知道函数真正继承那个原型需要保存它 Target.prototype.constuctor = Target; Target.prototype.yliluokka =Origin; &#125; &#125;()) 多重继承JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过Object.assign，实现这个功能。这种模式称之为 Mixin (混入)123456789101112function Fn1()&#123; &#125;function Fn2()&#123; &#125;function Son()&#123; F1.call(this); F2.call(this); &#125;//继承F1Son.prototype =Object.create(Fn1.prototype);//继承F2Object.assign(Son.prototype,Fn2.prototype);Son.prototype.constructor =Son;let a =new Son(); call，apply and bind 都可改变函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 call and apply1234567function test() &#123;&#125; //test() == test.call()let obj =&#123;&#125;;Object.prototype.toString.call(obj) //"[object Object]"//因为call 和 apply 会将函数中的this指向第一个参数//相当于 obj.toString() call and apply 二者区别在于传参： call 第二个参数开始单个单个参数传 apply 第二个参数为数组或类数组123456//返回数组中最大的数let a = [1, 2, 4, 1, 15];Math.max.apply(null, a) // 15//将数组的空元素变为undefinedArray.apply(null, [1,,3,,4])//[1,undefined,3,undefined,4]; 空元素与undefined的差别 forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 转换类似数组的对象 12let obj=&#123;0: 1, length: 2&#125;Array.protetype.slice.apply(obj);//[1,undefined] 被处理的对象必须有length属性，以及相对应的数字键。 参数为空、null和undefined，则默认传入全局对象。 bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 1234567891011121314151617181920212223let counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;let func = counter.inc.bind(counter);func();counter.count // 1let add = function (x, y) &#123; return x * this.m + y * this.n;&#125;let obj = &#123; m: 2, n: 2&#125;;let newAdd = add.bind(obj, 5); //将x 绑定为 5 newAdd(5) // 20newAdd(1,5)//12 第一个参数是null或undefined，等于将this绑定到全局对象 bind方法使用注意点 bind方法每运行一次，就返回一个新函数 需要一个变量接收 结合回调函数使用 1234567891011121314let counter = &#123; count: 0, inc: function () &#123; 'use strict'; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 结合call方法使用 1234567891011121314151617181920[1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1]//将Array.prototype.slice变成Function.prototype.call方法所在的对象//调用时就变成了Array.prototype.slice.call。let slice = Function.prototype.call.bind(Array.prototype.slice);Function.prototype.slice.call([1, 2, 3], 0, 1) // [1]//slice([1, 2, 3], 0, 1) let push = Function.prototype.call.bind(Array.prototype.push);let pop = Function.prototype.call.bind(Array.prototype.pop);let a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 将Function.prototype.bind方法变成Function.prototype.call的方法，就意味着bind的调用形式也可以被改写 1234567function f() &#123; console.log(this.v);&#125;let o = &#123; v: 123 &#125;;let bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123 Object 系统默认方法 getPrototypeOf 获取对象原型,只有一个参数 12345678910function Foo ()&#123;&#125;let obj = new Foo ();Object.getPrototypeOf(obj) // Foo.prototype//空对象原型 Object.getPrototypeOf(&#123;&#125;) // Object.prototype// Object.prototype 原型 Object.getPrototypeOf(Object.prototype) //null// FooObject.getPrototypeOf(Foo) // Function.prototype setPrototypeOf 设置对象原型有两个参数： 现有对象 继承的原型对象12345let now = &#123;&#125;;let pro = &#123;name:"Owen"&#125;;Object.setPrototypeOf(now,pro);now.name //"Owen" Object.create() 生成实例对象的常用方法 参数必须为对象 或 null 参数为 null 会生成一个不会继承任何属性和方法的对象12345678910111213141516171819202122232425262728293031let obj = Object.create(null);obj.toString()// Error //会继承第二个参数的属性和方法let obj = Object.create(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true, configurable: true, writable: true, &#125;, p2: &#123; value: 'Owen', enumerable: true, configurable: true, writable: true, &#125; &#125;);// 等同于let obj = Object.create(&#123;&#125;);obj.p1 = 123;obj.p2 = 'Owen';//生成的对象会继承它的原型对象的构造函数。function Foo() &#123;&#125;let f = new Foo();let b = Object.create(f);b.constructor === Foo // trueb instanceof Foo // true object.isPrototypeOf 判断对象是否再参数对象的原型链上 123function F()&#123;&#125;let f = new F()F.prototype.isPrototypeOf(f) //true 获取原型的三种方法 obj.__proto__ obj.constructor.prototype Object.getPrototypeOf(obj) 前两种不可靠，都个一手动修改， 而且 __proto__ 只有浏览器才需要部署 getOwnPropertyNames 和 keys 以数组形式返回参数对象所有属性名(不包含继承属性) 1234//不管可不可遍历都会返回出来Object.getOwnPropertyNames(Date);//["length", "name", "prototype", "now", "parse", "UTC"]//返回可遍历属性Object.keys(Date)// [] hasOwnProperty 判断参数是否是自身的属性，唯一一个不会遍历原型链的方法1Array.hasOwnProperty('length')//true 拷贝对象拷贝对象需要确保两件事情： 与原对象具有同样的原型。 与原对象具有同样的实例属性。 1234567891011121314151617function copyOwn (target,origin)&#123; Object.getOwnPropertyNames(origin).forEach((key)=&gt;&#123; let desc =Object.getOwnPropertyDescriptor(origin,key); Object.defineProperty(target,origin,desc); &#125;) return target&#125;function copy(origin)&#123; let clone = Object.create (Object.getPrototypeOf(origin)); copyOwn(clone,origin) return clone&#125;//es8const copyTwo = origin =&gt;Object.create( Object.getPropertyOf(origin),Object.getOwnPropertyDescriptor(origin) );]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(二)]]></title>
    <url>%2F2019%2F03%2F05%2Fopp2%2F</url>
    <content type="text"><![CDATA[原型对象 prototype 原型对象的所有属性和方法,都能被实例对象共享 JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。123456789function Cat (name, color) &#123; this.name = name; this.color = color;&#125;var cat1 = new Cat('小明', '白色');cat1.name // '小明'cat1.color // '白色' 构造函数缺点： 一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。 解决方法，就是 JavaScript 的原型对象 prototype，因为原型对象的所有属性和方法，都能被实例对象共享。 123456789function Cat (name, color) &#123; this.name = name;&#125;Cat.prototype.color ="白色";&#125;var cat1 = new Cat('巧克力');var cat2 = new Cat('布丁');cat1.color //白色cat2.color//白色 JavaScript规定，每个函数都有一个prototype属性，指向一个对象。 对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。 实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。 12function f() &#123;&#125;typeof f.prototype // "object" 每个 JS 对象都有 __proto__ 属性，这个属性可以访问到 原型（[[prototype]]） 内部属性。这个属性在现在来说已经不推荐直接去使用它了。 原型链 任何对象，都可以充当其他对象的原型；原型对象也有自己的原型。对象到原型，再到原型的原型，一层层向上找到Object.prototype。 可以说 基本上所有对象都继承了Object.prototype的属性；而 Object.prototype 的原型是 null通过 getPrototypeOf 方法返回参数对象原型1Object.getPrototypeOf(Object.prototype) //null 读取对象属性时，引擎会先在自身属性上查找，没有就查找原型，一级级向上查找，如果到Object.prototype还是没有，则返回undefined。 一级级向上，对性能有影响，寻找的层级越多，性能影响越大 原型链： 实例 F1 通过__proto__ 访问对应构造函数的原型 -&gt; FOO.prototype 函数原型再通过__proto__ 访问Object的原型 -&gt; Object.prototype Object的原型的__proto__ 指向 null 构造函数 Foo.prototype 通过constructor访问构造函数本身 Object.constructo 指向 Function Function.constructo 指向 本身 Function.__proto__ 指向一个匿名函数 每个构造函数通过 prototype 访问原型 只有函数才拥有prototype属性,基本上所有函数都有这个属性 1let fun = Function.prototype.bind() 当声明一个函数时自动创建 prototype 属性，这个属性的值是一个对象（也就是原型），且只有一个属性 constructor constructor prototype 有一个属性 constructor，默认指向原型所在的构造函数 12345678function Fn ()&#123;&#125;var f = new Fn ();f.constructor == Fn //truef.constructor == Function //false//可以从实例对象新建另一个实例var b =new f.constructor();b.constructor == Fn //true constructor是一个公有且不可枚举的属性。一旦我们改变了函数的 prototype ，那么新对象就没有这个属性了,如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。 1234function A()&#123;&#125;console.log(A.prototype) // &#123;constructor: ƒ&#125;constructor: ƒ A()__proto__: ObjectA.prototype="a"console.log(A.prototype) //"a" constructor作用： 让实例对象知道是什么函数构造了它 可以得知某个实例对象，是哪一个构造函数产生的。 如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 xx.constructor.method 来扩展 __proto__基本上每个对象都有的隐式原型属性，指向创建该对象的构造函数的原型，实际指向[[prototype]]， 内部属性，我们并不能访问到，所以使用 proto 来访问。12console.log(&#123;&#125;)//__proto__: Objectconstructor: ƒ Object()hasOwnProperty: .... 当我们使用 new 操作符时，生成的实例对象拥有了 __proto__属性。1234567function Foo() &#123;&#125;// 这个函数是 Function 的实例对象// function 就是一个语法糖// 内部调用了 new Function(...)const a =1;const fn = new Function("console.log(a)") // Function 的this始终指向 全局对象，除非手动改变this指向fn()//1 所有对象都可以通过原型链最终找到 Object.prototype ，虽然 Object.prototype 也是一个对象，但是这个对象却不是 Object 创造的，而是引擎自己创建了 Object.prototype 。可以这样说，所有实例都是对象，但是对象不一定都是实例。 -首先引擎创建了 Object.prototype ，然后创建了 Function.prototype ，并且通过proto 将两者联系了起来。 Function.prototype 以后才有了 function Function() ，然后其他的构造函数都是 function Function() 生成的。 函数通过 new Function() 生成, 不是所有函数都是 new Function()产生的。 Object 是所有对象的爸爸，所有对象都可以通过proto 找到它 Function 是所有函数的爸爸，所有函数都可以通过proto 找到它 Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎来创建 除了以上两个特殊对象，其他对象都是通过构造器 new 出来的 函数的 prototype 是一个对象，也就是原型对象的proto 指向原型，proto将对象和原型连接起来组成了原型链]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript OOP(一)]]></title>
    <url>%2F2019%2F03%2F04%2Fopp1%2F</url>
    <content type="text"><![CDATA[什么是对象对象是单个实物的抽象，通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。 面向对象编程的第一步，就是要生成对象。 对象是一个容器，封装了属性（property）和方法（method），属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。 JavaScript 语言的对象体系，不是基于“类”的，而是基于构造数constructor和原型链prototype；所以JS 专门使用构造函数作为对象模板；一个构造函数，可生成多个实列对象，它们有相同的结构 构造函数与普通函数区别 构造函数就是一个普通的函数，但是有自己的特征和用法。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。123456789101112//constructor var Bird = function () &#123; this.name = 'lai fu';&#125;;var bird1 = new Bird(); // 也可以使用 new Bird; 推荐使用前者console.log(bird1.name) // "lai fu"//ordinaryvar a =Bird();console.log(a) // undefinedconsole.log(a.name) // typeErrorname // 'laifu' 防止把构造函数constructor当普通函数使用1234567891011121314151617 //使用 严格模式function Fubar(foo, bar)&#123; 'use strict'; this._foo = foo; this._bar = bar;&#125;Fubar()// TypeError//判断 this 不是构造函数（constructor）的实列对象 那么手动返回自身constructorfunction Far(a)&#123; if (!(this instanceof Far)) return new Far(a); this._a=a;&#125;Far(1)._a new命令的原理 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 12345678910111213141516171819202122/***新生成一个空对象*链接到原型*绑定 this*返回新对象**/function _new(constuctor,param) &#123; // 获得构造函数 let Con = [].shift.call(arguments); // 创建一个空对象，继承构造函数的 prototype 属性 链接到原型 let obj = Object.create(Con.prototype); // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return (typeof(result) === 'object' &amp;&amp; result != null) ? result : obj&#125; var fn = _new( function Person (name,age)&#123; this.name = name; this.age = age &#125;, 'Owen', 28);fn.name // 'Owen' new.target12345678910111213141516function f() &#123; console.log(new.target === f);&#125;f() // falsenew f() // true //可利用 它来判断是否使用 new 命令function f() &#123; if (!new.target) &#123; throw new Error('请使用 new 命令调用！'); &#125; // ...&#125;f() // Uncaught Error: 请使用 new 命令调用！ this实质 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。 1var obj = &#123; a: 1 &#125;; JavaScript 存储变量实际上是以下面的形式保存的。 12345678&#123; a: &#123; [[value]]: 1 //函数的地址 [[writable]]: true //是否可赋值 [[enumerable]]: true//是否可枚举 [[configurable]]: true//是否可配置 &#125;&#125; 属性的值保存在属性描述对象的value属性里面。 如果 a 属性的值是引用值 那么属性将以下面的形式保存的：1234567891011var obj = &#123; fn: function () &#123;&#125; &#125;;/*&#123; fn: &#123; [[value]]: [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125;*/ 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f n= function () &#123;&#125;;var obj = &#123; f: fn &#125;;// 单独执行 fn()// obj 环境执行obj.f() JavaScript 允许在函数体内部，引用当前环境的其他变量。 由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 下面这几种用法，都会改变this的指向。1234567891011121314151617181920(obj.fn = obj.fn)() // window// 等同于(function () &#123; console.log(this);&#125;)()(false || obj.fn)() // window// 等同于(false || function () &#123; console.log(this);&#125;)()(4, obj.fn)() // window// 等同于(4, function () &#123; console.log(this);&#125;)() 数组调用forEach 方法时函数内部this 指向window ，将父级上下文传递给forEach 改变this指向1234567891011var o = &#123; v: 'hello', p: [ 'Owen', 18 ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + '-' + item); &#125;, this); //将外层的this传递给forEach方法 &#125;&#125;o.f() // hello-Owen hello-18 end]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
</search>
