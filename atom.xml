<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Owen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://owen027.github.io/"/>
  <updated>2019-09-24T12:33:09.766Z</updated>
  <id>https://owen027.github.io/</id>
  
  <author>
    <name>Owen Gao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库设计</title>
    <link href="https://owen027.github.io/2019/09/22/database_design/"/>
    <id>https://owen027.github.io/2019/09/22/database_design/</id>
    <published>2019-09-22T06:04:03.000Z</published>
    <updated>2019-09-24T12:33:09.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><blockquote><p>针对具体的应用场景，使用现有的 DBMS 构建适合的数据库模式，建立数据库及其应用系统，使之能有效的收集、存储、操作和管理数据，满足实际业务中各类用户的应用需求、信息需求和处理需求，这个过程称为数据库设计。</p></blockquote><p>1.数据库生命周期，从演变过程的角度分为两个阶段：分析与设计阶段 和 实现与操作阶段</p><p>1.1 分析与设计阶段细分为四个环节：需求方分析、概念设计、逻辑结构设计和物理结构设计。<br>1.2 实现与操作阶段细分为3个环节：数据库的实现、操作与监督和修改与调整。</p><ol start="2"><li><p>数据库设计主要以满足应用的功能需求和良好的数据库性能为目标。</p></li><li><p>数据库设计是从用户对数据的需求出发，研究并构造数据库的过程，包括两个方面：数据库结构设计（概念、逻辑和物理结构设计）和行为设计（对数据库的操作）</p></li><li><p>数据库设计的优劣，会直接影响当前的应用、数据库应用过程中的维护和生命周期，为使数据库设计更加合理，需要一个有效的指导原则（方法），大体分为三类：直观设计法、规范设计法和计算机辅助设计法。</p></li></ol><p>4.1 直观设计法：利用设计者的经验和技巧来设计数据库模式。此方法缺乏科学理论指导，质量很难保证。<br>4.2 规范设计法：又细分为 新奥尔良设计法、基于 E-R 模型的数据库设计法和基于第三范式的设计方法。<br>4.2.1 新奥尔良设计法：将数据库设计为四个阶段（需求分析、概念结构设计、逻辑结构设计和物理结构设计，注重结构设计）<br>4.2.2 E-R模型数据设计法：在需求分析的基础上用E-R图像构造一个反应现实世界实体之间联系的企业模式，然后将模式转换成某一特定 DBMS 下的概念模式。<br>4.2.3 基于第三范式的设计方法：在需求分析的基础上先确定数据库的模式，属性及属性间的依赖概念性，进行模式分解，规范成若干个第三范式关系模式的集合。</p><ol start="5"><li><p>计算机辅助设计方法：以领域专家的知识或经验为主导，模拟某一规范化设计的方法，通常通过人机交互的方式来完成设计的某些过程。</p></li><li><p>数据库设计的过程六大阶段：需求分析 -&gt; 结构设计（概念、逻辑和物理结构设计）∪ 行为设计（功能、事务和程序设计） -&gt; 数据库实施（加载数据库数据和调试运行应用程序） -&gt; 数据库运行和维护</p></li></ol><p><pre class="mermaid">graph LR</pre></p><p>A(需求分析) –&gt; B(结构设计)<br>A –&gt; C(行为设计)</p><p>B –&gt; D(数据库实施)<br>C –&gt; D(数据库实施)</p><p>D –&gt; E(数据库运行与维护)<br>数据库设计过程实际是一个反复修改、反复设计的迭代过程。</p><h2 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><blockquote><p>需求分析是数据库设计的起点，直接影响后续阶段的设计和数据库系统能否被合理使用。分四个步骤：确定数据库范围、分析数据应用过程、收集与分析数据和编写需求分析报告。<br>需求分析的目标是了解与分析用户的信息及应用处理的要求，并将结果按一定格式整理形成需求分析报告。</p></blockquote><p><span class="skyblue">数据库设计人员进行需求分析基本方法：听取数据库应用部们人员的报告，并沟通。同时需求分析人员提交一份需求调查表，该表内容主要包括调查的内容和要求提供资料的格式，应用部门的业务人员可根据该表进行准备和提交材料；此外数据库设计人员还需查阅原始资料，及跟班作业等</span></p><h4 id="确定数据库范围"><a href="#确定数据库范围" class="headerlink" title="确定数据库范围"></a>确定数据库范围</h4><p>范围指数据库应支持哪些应用功能。该范围应尽可能的考虑较为广泛的应用部门或领域，充分满足用户的应用功能要求，有效地利用计算机设备及数据库系统的潜在能力。同时还应尽可能考虑将来的应用需求，提高数据库应变能力，避免以后频繁修改。</p><p>满足上述要求的数据库是复杂而庞大的，由于诸多因素的影响，设计人员当首先考虑支持用户工作需要所必须的应用要求。</p><h4 id="应用过程分析"><a href="#应用过程分析" class="headerlink" title="应用过程分析"></a>应用过程分析</h4><p>此过程分析指了解并分析数据与数据处理间的关系。在确定数据库范围后，设计人员应逐次地了解分析每一部门或功能要用到哪些数据、数据的使用顺序、对数据作何处理和处理的策略及处理结果等</p><p>过程分析的结果是数据库结构设计的重要依据。</p><h4 id="收集与分析数据"><a href="#收集与分析数据" class="headerlink" title="收集与分析数据"></a>收集与分析数据</h4><p> 数据收集与分析是指了解并分析数据的组成格式及操作特征，每个数据元素的语义及关系等，并将它们收集起来整理归档。<br> 可从三个方面展开工作：静态结构、动态结构及数据约束。</p><h5 id="静态结构"><a href="#静态结构" class="headerlink" title="静态结构"></a>静态结构</h5><p>静态结构指不施加应用操作于其上时数据的原始状况。通过数据分类表和数据元素表来说明</p><p>1）数据分类表用于数据的总体描述。对于每一客观存在的具有独立意义的单类数据单位应给出其名称、用途、编制者及使用者等说明：</p><table><thead><tr><th style="text-align:center">数据ID</th><th style="text-align:center">数据名</th><th style="text-align:center">用途</th><th style="text-align:center">主人</th><th style="text-align:center">用户</th><th style="text-align:center">来源</th><th style="text-align:center">去向</th><th style="text-align:center">存档时间</th><th style="text-align:center">数据量</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>2）数据元素表<br>数据元素表指通常意义下的数据项或属性。数据分类表中的每一类数据的所有数据元素名称、类型、长度、意义及算法等都应在数据元素表中进行详尽说明。格式如下：</p><p>|数据ID|数据元素ID|元素名|意义|类型|长度|算法|备注|<br>|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概叙&quot;&gt;&lt;a href=&quot;#概叙&quot; class=&quot;headerlink&quot; title=&quot;概叙&quot;&gt;&lt;/a&gt;概叙&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;针对具体的应用场景，使用现有的 DBMS 构建适合的数据库模式，建立数据库及其应用系统，使之能有效的收集、存储、操
      
    
    </summary>
    
      <category term="Database basis" scheme="https://owen027.github.io/categories/Database-basis/"/>
    
    
      <category term="database design" scheme="https://owen027.github.io/tags/database-design/"/>
    
  </entry>
  
  <entry>
    <title>关系数据库的规范化理论</title>
    <link href="https://owen027.github.io/2019/09/19/normalization_theory/"/>
    <id>https://owen027.github.io/2019/09/19/normalization_theory/</id>
    <published>2019-09-19T12:00:02.000Z</published>
    <updated>2019-09-24T12:33:09.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><p>规范化理论研究的是关系模式中各属性间的依赖关系及对其概念性模式性能的影响，它提供了判断关系模式优劣的理论标准，能帮助数据库设计人员预测可能出现的问题。</p><p>规范化理论主要应用于数据库设计中的概念设计阶段。</p><h2 id="关系模式中可能存在的冗余或异常问题"><a href="#关系模式中可能存在的冗余或异常问题" class="headerlink" title="关系模式中可能存在的冗余或异常问题"></a>关系模式中可能存在的冗余或异常问题</h2><p>关系模式可能存在如下问题：</p><ul><li>数据冗余</li></ul><p>数据冗余指同一数据被反复存储的情况。如在一个供应商关系模式中，一个供应商每供应一种货物，其地址就存储一次，如果供应成千上万种货物，地址就会反复成千上完成。</p><ul><li><p>更新异常<br>数据冗余将导致存储空间的浪费和潜 在数据不一致性及修改麻烦问题。如供应1000种货物的供应商的地址信息发生变化，那么需要对这些供应商的地址进行逐一修改，这样就有可能在一个元组中修改了地址，而没修改该另一个元组中同一供应商的地址，从而导致与实际情况不相符</p></li><li><p>插入异常<br>插入异常指应该插入到数据库中的数据不能只需插入操作的情形。</p></li><li><p>删除异常<br>数据的删除操作异常指不应该删除的数据被删除的情形。</p></li></ul><p>产生上述问题的原因，及消除这些问题的方法，都与数据库依赖的概念密切相关。数据依赖是可以作为关系模式的取值的任何一个关系所必须满足的一种约束条件，是通过一个关系中各个元组的某些属性值之间的相等与否体现出来的相互关系。</p><h2 id="函数依赖与关键字"><a href="#函数依赖与关键字" class="headerlink" title="函数依赖与关键字"></a>函数依赖与关键字</h2><p>函数依赖指关系中属性间的对应关系</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设R 为任一给定关系，如果对于 R 中属性 X 的每个值，R 中的属性 Y 只有唯一值与之对应，则称 X 函数决定 Y （Y 函数依赖于 X） 记作 $X\to Y$。 X称为决定因素<br><strong>example:</strong><br><strong>表 T1</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">李梅</td><td style="text-align:center">女</td><td style="text-align:center">C101</td></tr></tbody></table><p>T1中存在如下函数依赖：<br>$SNO\to SName$<br>$SNO\to SSEX$<br>$SNO\to SROOM$</p><p>T1 中的函数依赖关系仅当SNO作为决定因素时存在</p><label>函数依赖是针对关系的所有元组，只要有一个元组的属性值不满足函数依赖的定义，则相对应的依赖就不成立。</label><h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h3><p>设 R 为任一给定定关系，X、Y 为其属性集， 若$X\to Y$,且 X 中的任一真子集 $X^{‘}$都有 Y 函数不依赖于 $X^{‘}$，则 Y 完全依赖于 X</p><p><strong>Example：</strong></p><p><strong>表 T2</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">课程编号（CNO）</th><th style="text-align:center">课程名（CTITLE）</th><th style="text-align:center">授课老师（INAME）</th><th style="text-align:center">成绩（GRADE）</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">201</td><td style="text-align:center">语</td><td style="text-align:center">张三</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">202</td><td style="text-align:center">数</td><td style="text-align:center">李四</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">203</td><td style="text-align:center">英</td><td style="text-align:center">王五</td><td style="text-align:center">60</td></tr></tbody></table><p>T2 中，函数依赖：$（SNO,CNO）\to GRADE$ ，它为完全函数依赖。因为其中单个属性 SNO/CNO 都不能单独决定GRADE</p><h3 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h3><p>设 R 为任一给定关系， X、Y 为其属性集合，若$X\to Y$,且 X 中存在某个真子集 $X^{‘}$满足  $X^{‘}\to Y$  ，则 Y 部分函数依赖于 X。</p><p>T1 中 函数依赖$（SNO,SNAME）\to SSEX$,而其中$SNO\to SSEX$ ,那么 SSEX部分函数依赖于（SNO,SNAME）</p><h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><p>设 R 为任一给定关系， X、Y、Z为不同属性子集，若$X\to Y$,X函数不依赖于Y，$Y\to Z$,则 $X\to Z$,即 Z传递函数依赖于X。</p><p><strong>Example：</strong></p><p>有一个关系模式 T2（BNO(书号),PNAME（出版社名）,PADDRESS（出版社地址））,一种书对应一个唯一的书号，且只能为某一出版社出版；<br>一个出版社只有唯一名称和地址，但一个出版社可出版多种书。<br>那么该关系中存在函数依赖：$BNO \to PNAME$, $PNAME\to PADDRESS$, PNAME函数不依赖于BNO，所以$BNO\to PADDRESS$</p><h3 id="严格的关键字定义"><a href="#严格的关键字定义" class="headerlink" title="严格的关键字定义"></a>严格的关键字定义</h3><p>设 R 为任一给定关系，U 为所有属性集合， X 为 U 的子集，若 U 完全依赖于 X，则 X 为 R 的候选关键字。</p><h2 id="范式与关系规范化过程"><a href="#范式与关系规范化过程" class="headerlink" title="范式与关系规范化过程"></a>范式与关系规范化过程</h2><p>关系数据库中的关系需要满足一定的要求，不同程度的要求称为不同的范式（Normal Form,NF）。</p><h3 id="第一范式-1FN"><a href="#第一范式-1FN" class="headerlink" title="第一范式 1FN"></a>第一范式 1FN</h3><p>设 R 为任一给定关系， R 中每个列和行的交点处的取值都是不可再分的基本元素，则 R 为 1FN。 1FN是范式的最低要求,是一个不含重复组的关系，不存在嵌套结构。</p><p><strong>表 T3 </strong></p><table><caption>学生选课信息表</caption><thead> <tr>    <th>SNO</th>    <th>CNO</th>    <th>CTITLE</th>    <th>INAME</th>    <th>IPLACE</th>    <th>GRADE</th> </tr></thead><tbody><tr><td>1027</td><td>C01</td><td>操作系统</td><td>王五</td><td>东01</td><td>100</td></tr><tr><td>1028</td><td>C02</td><td>数据库</td><td>刘备</td><td>东02</td><td>91</td></tr><tr><td rowspan="2">1029</td><td>C01</td><td>操作系统</td><td>王五</td><td>东01</td><td>88</td></tr><tr><td>C03</td><td>人工智能</td><td>曹操</td><td>东03</td><td>100</td></tr><tr><td>1030</td><td>C04</td><td>C语言</td><td>刘备</td><td>东02</td><td>97</td></tr></tbody></table><p>T3关系是一个非归范式关系，因为 SNO属性中 1029出现重复的组，可将T3转化为 1FN</p><p><strong>T4 1FN</strong></p><table><thead><tr><th style="text-align:center">SNO</th><th style="text-align:center">CNO</th><th style="text-align:center">CTITLE</th><th style="text-align:center">INAME</th><th style="text-align:center">IPLACE</th><th style="text-align:center">GRADE</th></tr></thead><tbody><tr><td style="text-align:center">1027</td><td style="text-align:center">C01</td><td style="text-align:center">操作系统</td><td style="text-align:center">王五</td><td style="text-align:center">东01</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">1028</td><td style="text-align:center">C02</td><td style="text-align:center">数据库</td><td style="text-align:center">刘备</td><td style="text-align:center">东02</td><td style="text-align:center">91</td></tr><tr><td style="text-align:center">1029</td><td style="text-align:center">C01</td><td style="text-align:center">操作系统</td><td style="text-align:center">王五</td><td style="text-align:center">东01</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">1029</td><td style="text-align:center">C03</td><td style="text-align:center">人工智能</td><td style="text-align:center">曹操</td><td style="text-align:center">东03</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">1030</td><td style="text-align:center">C04</td><td style="text-align:center">C语言</td><td style="text-align:center">刘备</td><td style="text-align:center">东02</td><td style="text-align:center">97</td></tr></tbody></table><h3 id="第二范式-2FN"><a href="#第二范式-2FN" class="headerlink" title="第二范式 2FN"></a>第二范式 2FN</h3><p>设 R 为任一给定关系，如果 R 为 1FN，且所有非主属性都完全函数依赖于候选关键字，则 R为 2FN。</p><p><strong>Example：</strong></p><p>T4 中存在着冗余度高、插入和删除操作异常等问题，CTITLE 中都某一课程被多人选修，那么对应的授课老师和地址将反复存储（数据冗余）；若新增一门课程，而没人任何同学选修，则这们课程将无法存储（插入异常）；如果将最后一元组删除，同时会删除C语言这门课程及相关老师和地址等信息（删除异常）；</p><p><span class="red">存在这些问题的原因在于仅有非主属性 GEEADE 完全 依赖于（SNO,CNO）,其他非主属性都只依赖于 CNO ，对于主键（SNO,CNO）为部分依赖</span></p><p><span class="skyblue">通过分解 T4 将部分函数依赖分解成完全函数依赖，得到 2FN</span><br><strong>T4.1</strong></p><table><thead><tr><th style="text-align:center">SNO</th><th style="text-align:center">CNO</th><th style="text-align:center">GRADE</th></tr></thead><tbody><tr><td style="text-align:center">1027</td><td style="text-align:center">C01</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">1028</td><td style="text-align:center">C02</td><td style="text-align:center">91</td></tr><tr><td style="text-align:center">1029</td><td style="text-align:center">C01</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">1029</td><td style="text-align:center">C03</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">1030</td><td style="text-align:center">C04</td><td style="text-align:center">97</td></tr></tbody></table><p><strong>T4.2</strong></p><table><thead><tr><th style="text-align:center">CNO</th><th style="text-align:center">CTITLE</th><th style="text-align:center">INAME</th><th style="text-align:center">IPLACE</th></tr></thead><tbody><tr><td style="text-align:center">C01</td><td style="text-align:center">操作系统</td><td style="text-align:center">王五</td><td style="text-align:center">东01</td></tr><tr><td style="text-align:center">C02</td><td style="text-align:center">数据库</td><td style="text-align:center">刘备</td><td style="text-align:center">东02</td></tr><tr><td style="text-align:center">C03</td><td style="text-align:center">人工智能</td><td style="text-align:center">曹操</td><td style="text-align:center">东03</td></tr><tr><td style="text-align:center">C04</td><td style="text-align:center">C语言</td><td style="text-align:center">刘备</td><td style="text-align:center">东02</td></tr></tbody></table><p>此时的 T4.2依然存在插入、删除操作及修改麻烦等异常问题。如:将一位新老师插入 T4.2表中，但这位老师暂无任何教学工作，因缺关键字 CNO的值而不能执行插入操作。</p><p><span class="red">原因在于：T4.2 关系中存在非主属性对主属性的传递函数依赖，须进一步分解。</span></p><h3 id="第三范式-3FN"><a href="#第三范式-3FN" class="headerlink" title="第三范式 3FN"></a>第三范式 3FN</h3><p>设 R 未任一给定关系， 如 R 未 2FN，且每一个非主属性都不传递依赖于候选关键字，则 R 为3FN。</p><p><strong>Example：</strong></p><p><span class="skyblue">通过分解 T4.2 将传递函数依赖分解成完全函数依赖，得到 3FN</span></p><p><strong>T4.2.1</strong></p><table><thead><tr><th style="text-align:center">CNO</th><th style="text-align:center">CTITLE</th><th style="text-align:center">INAME</th></tr></thead><tbody><tr><td style="text-align:center">C01</td><td style="text-align:center">操作系统</td><td style="text-align:center">王五</td></tr><tr><td style="text-align:center">C02</td><td style="text-align:center">数据库</td><td style="text-align:center">刘备</td></tr><tr><td style="text-align:center">C03</td><td style="text-align:center">人工智能</td><td style="text-align:center">曹操</td></tr><tr><td style="text-align:center">C04</td><td style="text-align:center">C语言</td><td style="text-align:center">刘备</td></tr></tbody></table><p><strong>T4.2.2</strong></p><table><thead><tr><th style="text-align:center">INAME</th><th style="text-align:center">IPLACE</th></tr></thead><tbody><tr><td style="text-align:center">王五</td><td style="text-align:center">东01</td></tr><tr><td style="text-align:center">刘备</td><td style="text-align:center">东02</td></tr><tr><td style="text-align:center">曹操</td><td style="text-align:center">东03</td></tr></tbody></table><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>通常 3FN 大多数能解决插入和删除操作异常的问题，数据冗余也能得到有效控制。为解决3FN有时出现的操作问题，R.F.Boyce和E.F.Codd 提出 改进范式 BCNF</p><p>设 R 为任一给定关系，X、Y 为属性集，F为其函数依赖集， 若 R 为 3NF，且 F 中所有函数依赖 $X\to Y$ (Y 不属于 X)中 X 必须包含候选关键字，则 R 为 BCNF。<span class="red"> 即 R中每一函数依赖的决定因素X（可为单一属性或组合属性） 都包含 候选关键字，则 R 为 BCNF。</span></p><p>当所有属性集合为候选关键字时依然会存在操作异常和数据冗余等问题<br><strong>Example：</strong></p><p><strong>表  T5</strong></p><table><thead><tr><th style="text-align:center">SNO</th><th style="text-align:center">CTITLE</th><th style="text-align:center">TNAME</th></tr></thead><tbody><tr><td style="text-align:center">S01</td><td style="text-align:center">操作系统</td><td style="text-align:center">王五</td></tr><tr><td style="text-align:center">S02</td><td style="text-align:center">人工智能</td><td style="text-align:center">曹操</td></tr><tr><td style="text-align:center">S02</td><td style="text-align:center">数据库</td><td style="text-align:center">刘备</td></tr><tr><td style="text-align:center">S03</td><td style="text-align:center">数据库</td><td style="text-align:center">孙权</td></tr></tbody></table><p>T5中新增一门课程和一位老师的数据时，须至少有一位学生选修该课且指导老师已被分配才能插入T5中。</p><p><span class="skyblue">此时可通过公共的函数依赖将 T5分解位为 T5.1 和 T5.2</span></p><p><strong>T5.1</strong></p><table><thead><tr><th style="text-align:center">SNO</th><th style="text-align:center">TNAME</th></tr></thead><tbody><tr><td style="text-align:center">S01</td><td style="text-align:center">王五</td></tr><tr><td style="text-align:center">S02</td><td style="text-align:center">曹操</td></tr><tr><td style="text-align:center">S02</td><td style="text-align:center">刘备</td></tr><tr><td style="text-align:center">S03</td><td style="text-align:center">孙权</td></tr></tbody></table><p><strong>T5.2</strong></p><table><thead><tr><th style="text-align:center">TNAME</th><th style="text-align:center">CTITLE</th></tr></thead><tbody><tr><td style="text-align:center">王五</td><td style="text-align:center">操作系统</td></tr><tr><td style="text-align:center">曹操</td><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">刘备</td><td style="text-align:center">人工智能</td></tr><tr><td style="text-align:center">孙权</td><td style="text-align:center">C语言</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概叙&quot;&gt;&lt;a href=&quot;#概叙&quot; class=&quot;headerlink&quot; title=&quot;概叙&quot;&gt;&lt;/a&gt;概叙&lt;/h2&gt;&lt;p&gt;规范化理论研究的是关系模式中各属性间的依赖关系及对其概念性模式性能的影响，它提供了判断关系模式优劣的理论标准，能帮助数据库设计人员预测可能出
      
    
    </summary>
    
      <category term="Datebase basis" scheme="https://owen027.github.io/categories/Datebase-basis/"/>
    
    
      <category term="normalization theroy" scheme="https://owen027.github.io/tags/normalization-theroy/"/>
    
  </entry>
  
  <entry>
    <title>关系数据模型要素三 关系完整性约束</title>
    <link href="https://owen027.github.io/2019/09/19/integrity_constraint_of_relational/"/>
    <id>https://owen027.github.io/2019/09/19/integrity_constraint_of_relational/</id>
    <published>2019-09-19T11:18:07.000Z</published>
    <updated>2019-09-19T15:10:50.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> 数据完整性指数据库中数据的<strong>正确性、相容性和一致性</strong>。包括现实世界中的应用需求的完整性。数据的完整性由完整性规则来定义。</p><p>关系模型的完整性规则是对关系的某种约束，提供一种手段来保证用户对数据库的修改时不会破坏数据库中数据的完整性。保证数据是有意义的。</p><p>关系模型分三类约束：实体完整性约束、参照完整性约束和用户自定义完整性约束。 <strong>前两者是必须满足的条件，称作关系的两个不变性</strong>。由DBMS自动支持</p><h3 id="实体完整性约束（Entity-Integrity-Constraint）"><a href="#实体完整性约束（Entity-Integrity-Constraint）" class="headerlink" title="实体完整性约束（Entity Integrity Constraint）"></a>实体完整性约束（Entity Integrity Constraint）</h3><p>此约束指关系的主属性，主码不能为空，在关系数据库系统中，一个关系对应一张表，实体完整性指在数据存储数据的表中，主键/码不能取控值 NULL</p><h3 id="参照完整性约束-（Referential-Integrity-Constraint）"><a href="#参照完整性约束-（Referential-Integrity-Constraint）" class="headerlink" title="参照完整性约束 （Referential Integrity Constraint）"></a>参照完整性约束 （Referential Integrity Constraint）</h3><p>现实世界中实体之间往往存在某种联系，在关系模型中这种联系通过关系来描述</p><blockquote><p>参照完整性约束就说定义外码和主码之间的引用规则，是对关系间引用数据的一种限制。若属性（属性组）X 是基本关系 R 的外码，它与基本关系 S 的主码 Y 对应，那么 R 中每个元组在 F 上的值要么取 NULL，要么等于 S中对应元组的主码值。 R 和 S 可以是不同的关系，也可以是同一关系。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">教师（职工号，姓名，性别，系编号）</span><br><span class="line">系（系编号，系名，办公地点）</span><br></pre></td></tr></table></figure></p></blockquote><p>上述两个关系之间存在属性的引用，系编码既是 <code>系</code> 关系的主码又是<code>教师</code>关系的外部码。那么<code>教师</code> 关系中系编码属性的取值需要参照 <code>系</code>关系中系编码的值或为 NULL。</p><h3 id="用户定义完整性约束-（User-defined-Integrity-constraint）"><a href="#用户定义完整性约束-（User-defined-Integrity-constraint）" class="headerlink" title="用户定义完整性约束 （User-defined Integrity constraint）"></a>用户定义完整性约束 （User-defined Integrity constraint）</h3><p>此约束针对某一应用环境的完整性约束条件，反映了某一具体应用所涉及的数据应满足的要求。关系模型提供定义和检验的机制，此类规则一般在建立数据库表的同时进行定义，如果某些条件未建立在库表一级，则应在各个模块的具体编程中通过程序进行检查和控制。</p><h3 id="关系模型完整性约束检验-重点"><a href="#关系模型完整性约束检验-重点" class="headerlink" title="关系模型完整性约束检验   重点"></a>关系模型完整性约束检验   <label style="color:red; ">重点</label></h3><p>在对数据库进行修改时须检验是否满足对上述三类完整性约束</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>首先检查实体完整性约束，检查插入行在主码属性上的值是否已存在，不存在，可以执行插入，否则不可插入。再检查参照完整性约束，如果是向被参照关系插入，则不需要考虑此约束；如果向参照关系插入，则检查插入行在外码属性上的值是否已在相应被参照关系的主码属性中存在，存在，可插入，否则不可插入，或者将插入行的外码属性的值改为NULL，再插入，最后检查自定义完整性约束，包括数据的类性、精度、取值范围、是否允许空值、是否有默认值等，满足即可执行插入操作，否则给出错误信息。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>一般只需对被参照关系检查参照完整性约束。如果主键被引用则不可删，或将参照关系中对应行的外码属性改为为NULL，再删除</p><h4 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h4><p>结合删除 和 插入操作，先删除再插入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt; 数据完整性指数据库中数据的&lt;strong&gt;正确性、相容性和一致性&lt;/strong&gt;。包括现实世界中的应用需求的完整性。数据的完整性由完整性
      
    
    </summary>
    
      <category term="Datebase basis" scheme="https://owen027.github.io/categories/Datebase-basis/"/>
    
    
      <category term="integrity constraint of relational" scheme="https://owen027.github.io/tags/integrity-constraint-of-relational/"/>
    
  </entry>
  
  <entry>
    <title>关系数据模型要素二 （关系操作集合）</title>
    <link href="https://owen027.github.io/2019/09/18/relational_operation/"/>
    <id>https://owen027.github.io/2019/09/18/relational_operation/</id>
    <published>2019-09-18T11:15:49.000Z</published>
    <updated>2019-09-24T12:33:09.767Z</updated>
    
    <content type="html"><![CDATA[ <link href="/static/css/relation_data_model.css" rel="stylesheet" type="text/css"><h3 id="基本的关系操作"><a href="#基本的关系操作" class="headerlink" title="基本的关系操作"></a>基本的关系操作</h3><p>增（插入 Insert）、删(Delete)、改(Update)、查（Query）。关系的查询表达能力是关系操作最主要的部分。查又可分为选择、投影、连接、除、并、差、交、笛卡尔积。集合操作方式（操作的对象和结果都是集合）。又称为一次一集合（set-at-a-time）</p><h3 id="关系数据语言的分类"><a href="#关系数据语言的分类" class="headerlink" title="关系数据语言的分类"></a>关系数据语言的分类</h3><p>通过关系语言实现关系操作。<label>它高度非过程化</label>用户不必请求DBM为其建立特殊的存取路径，由 DBMS 的优化机制来完成。</p><ol><li>代数方式：主要有关系代数，通过对关系的操作来表达查询要求</li><li>逻辑方式：主要有关系演算，是用谓词来表达查询要求，关系演算又按谓词变元的基本对象（元组变量或域变量），分为元组关系演算和域关系演算。</li><li>介于前两者之间的结构化查询语言（Structured Query Language,SQL）：SQL具有丰富的查询功能、数据定义和数据控制功能。集查询、数据定义语言（DDL）、数据操作语言（DML）和数据控制语言（Data Control Language, DCL）于一体；是关系数据库的标准语言。</li></ol><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>关系代数是关系操作语言中的传统表示方式，以集合代数为基础发展而来。任何一种操作都是将一定的操作符作用域一定的操作对象上，得到预期的操作结果。</p><p><label>操作包含三大要素：操作对象、操作符、操作结果。</label>而对象和结果均为关系。关系代数直接应用关系的运算来表达操作的目的，运算符包括集合运算符和专门的关系运算符。</p><table cellpadding="5" id="operator"><caption>关系代数的运算符</caption><thead><th colspan="2">运算符</th><th>含义</th></thead><tbody><tr><td rowspan="4">集合运算符</td><td>∪</td><td>并</td></tr><tr><td>−</td><td>差</td></tr><tr><td>∩</td><td>交</td></tr><tr><td>×</td><td>笛卡尔积</td></tr><tr><td rowspan="4">专门的关系运算符</td><td>σ</td><td>选择</td></tr><tr><td>π</td><td>投影</td></tr><tr><td>⋈</td><td>连接</td></tr><tr><td>÷</td><td>除</td></tr><tr><td rowspan="6">比较操作符</td><td> > </td><td>大于</td></tr><tr><td>≥</td><td>大于等于</td></tr><tr><td> < </td><td>小于</td></tr><tr><td>≤</td><td>小于等于</td></tr><tr><td>＝</td><td>等于</td></tr><tr><td>≠</td><td>不等于</td></tr><tr><td rowspan="3">比较操作符</td><td> ¬ </td><td>非</td></tr><tr><td>∧</td><td>与</td></tr><tr><td> ∨ </td><td>或</td></tr></tbody></table><p>关系代数操作经过有限次复合的式子称为关系代数操作表达式（关系代数表达式），可使用表达式表示所需要执行的各种数据查询和修改处理，所有关系代数是一种抽象的查询语言，通过对关系的操作来表达查询。</p><p>按运算符分类，关系代数操作可分为：传统的集合运算和专门的关系运算</p><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>传统集合运算是二目运算，将关系看成元组集合，运算从行的角度来进行，具有 并、差、交、迪卡尔积四种运算。</p><p><strong>Example：</strong></p><p><strong>表 T1</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">李梅</td><td style="text-align:center">女</td><td style="text-align:center">C101</td></tr></tbody></table><p><strong>表 T2</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0004</td><td style="text-align:center">刘八</td><td style="text-align:center">男</td><td style="text-align:center">D101</td></tr><tr><td style="text-align:center">0005</td><td style="text-align:center">赵二</td><td style="text-align:center">男</td><td style="text-align:center">B201</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">李梅</td><td style="text-align:center">女</td><td style="text-align:center">C101</td></tr></tbody></table><h4 id="并（UNION）"><a href="#并（UNION）" class="headerlink" title="并（UNION）"></a>并（UNION）</h4><p>表T1 和 表T2 使用并运算产生一个新表T3，（T3 = T1 ∪ T2）它是由T1和T2所有不同元组所组成，且 T1和T2属性个数、值域相同。下表为 T1 ∪ T2的结果<br><strong>表 T3</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">李梅</td><td style="text-align:center">女</td><td style="text-align:center">C101</td></tr><tr><td style="text-align:center">0004</td><td style="text-align:center">刘八</td><td style="text-align:center">男</td><td style="text-align:center">D101</td></tr><tr><td style="text-align:center">0005</td><td style="text-align:center">赵二</td><td style="text-align:center">男</td><td style="text-align:center">B201</td></tr></tbody></table><h4 id="差（DIFFERENCE）"><a href="#差（DIFFERENCE）" class="headerlink" title="差（DIFFERENCE）"></a>差（DIFFERENCE）</h4><p>表T1 和 表T2 使用差运算产生一个新表T4，（T4 = T1 - T2）它有T1的所有元组但不包含T2的元组，且 T1和T2属性个数、值域必须相同。下表为 T1 - T2的结果</p><p><strong>表 T4</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr></tbody></table><h4 id="交（INTERSECTION）"><a href="#交（INTERSECTION）" class="headerlink" title="交（INTERSECTION）"></a>交（INTERSECTION）</h4><p>表T1 和 表T2 使用交运算产生一个新表T5，（T5 = T1 ∩ T2）它同时包含T1和T2相同的所有元组，且 T1和T2属性个数、值域必须相同，交运算可由差运算表示（T1∩T2 = T1-(T1-T2)）。下表为 T1 ∩ T2的结果</p><p><strong>表 T5</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0003</td><td style="text-align:center">李梅</td><td style="text-align:center">女</td><td style="text-align:center">C101</td></tr></tbody></table><h5 id="笛卡尔积（CARTESIAN-PRODUCT）"><a href="#笛卡尔积（CARTESIAN-PRODUCT）" class="headerlink" title="笛卡尔积（CARTESIAN PRODUCT）"></a>笛卡尔积（CARTESIAN PRODUCT）</h5><p>表T6 和 表T7 使用笛卡尔积运算产生一个新表T8，（T8 = T6 × T7）它是T6和T7的所有元组连接而成，即将两张表的元关系合并，且T6的每一元组都对应T7所有的元组<br>下表为 T6 × T7的结果</p><p><strong>表 T6</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td></tr></tbody></table><p><strong>表 T7</strong></p><table><thead><tr><th style="text-align:center">课程号（CNO）</th><th style="text-align:center">课程名（CNAME）</th><th style="text-align:center">教室(SSEX)</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">数据库</td><td style="text-align:center">C-101</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">操作系统</td><td style="text-align:center">C-102</td></tr></tbody></table><p><strong>表 T8</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">课程号（CNO）</th><th style="text-align:center">课程名（CNAME）</th><th style="text-align:center">教室(SSEX)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">1</td><td style="text-align:center">数据库</td><td style="text-align:center">C-101</td></tr><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">2</td><td style="text-align:center">操作系统</td><td style="text-align:center">C-102</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">1</td><td style="text-align:center">数据库</td><td style="text-align:center">C-101</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">2</td><td style="text-align:center">操作系统</td><td style="text-align:center">C-102</td></tr></tbody></table><h3 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h3><p>此运算即涉及行，又涉及列，分为一元专门关系操作和二元专门关系操作</p><ul><li>一元关系操作：对单个关系进行垂直分解的投影运算和进行水平分解选择运算</li><li>二元关系操作：对两个关系进行操作，包括连运算和除运算</li></ul><h4 id="选择（SELECT）"><a href="#选择（SELECT）" class="headerlink" title="选择（SELECT）"></a>选择（SELECT）</h4><p>选择运算( $σ_F(R)$ )，F为条件表达式，R为指定的被运算关系名。 从指定关系中选取满足条件的若干元组组成一个新关系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 关系名 <span class="keyword">WHERE</span> 条件语句（表达式）</span><br></pre></td></tr></table></figure></p><p>条件语句：由常数、属性名或列名、比较操作符及逻辑操作符组成</p><p><strong>Example：</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T8 <span class="keyword">WHERE</span> 姓名 = <span class="string">"张三"</span></span><br></pre></td></tr></table></figure></p><p><strong>表 T9</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">课程号（CNO）</th><th style="text-align:center">课程名（CNAME）</th><th style="text-align:center">教室(SSEX)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">1</td><td style="text-align:center">数据库</td><td style="text-align:center">C-101</td></tr><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">2</td><td style="text-align:center">操作系统</td><td style="text-align:center">C-102</td></tr></tbody></table><h4 id="投影（PROJECTION）"><a href="#投影（PROJECTION）" class="headerlink" title="投影（PROJECTION）"></a>投影（PROJECTION）</h4><p>投影运算( $π_A(R)$ ), R为被运算关系，A为属性序列，从指定关系中选取指定的若干属性值组成新关系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROJECTION 关系名 ( 属性名1, 属性名2 ,... )</span><br></pre></td></tr></table></figure></p><p>组成的新关系自动去重</p><p><strong>Example：</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROJECTION T8 (课程号,课程名)</span><br></pre></td></tr></table></figure></p><p><strong>表 T10</strong></p><table><thead><tr><th style="text-align:center">课程号（CNO）</th><th style="text-align:center">课程名（CNAME）</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">操作系统</td></tr></tbody></table><h4 id="θ连接（JOIN）"><a href="#θ连接（JOIN）" class="headerlink" title="θ连接（JOIN）"></a>θ连接（JOIN）</h4><p>连接运算（$R\cfrac{⋈}{xθy}S$）,其中，R和S 代表两个不同的关系；x 和 y 分别表示R中的第x列和S中的第y列属性；θ表示比较运算符，从笛卡尔积R×S中选取R的第x列属性值与S的第y列属性值满足θ的那些元组组成一个新关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JOIN 关系1 AND 关系2 WHERE 条件语句</span><br></pre></td></tr></table></figure><p>条件语句：由比较操作符和属性名或列名组成的表达式</p><ul><li>等值连接：θ值为 “=”，从R和S的笛卡尔积中选取 x、y 属性值相等的元组</li></ul><p><strong>Example：</strong></p><p><strong>表 T11</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">e</td><td style="text-align:center">f</td></tr></tbody></table><p><strong>表 T12</strong></p><table><thead><tr><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">A</th></tr></thead><tbody><tr><td style="text-align:center">g</td><td style="text-align:center">h</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JOIN  T11 AND T12 WHERE B= A</span><br></pre></td></tr></table></figure><p><strong>T11 × T12</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">A</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">g</td><td style="text-align:center">h</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">g</td><td style="text-align:center">h</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td></tr></tbody></table><p>等值结果为：</p><p><strong>表 T13</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">A</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td></tr></tbody></table><ul><li>自然连接：是一种特殊的等值连接，要求两个关系中比较的分量必须是 <span style="color:red">相同的属性组，且结果中去除重复的属性列</span></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JOIN  T11 AND T12 WHERE A = A</span><br></pre></td></tr></table></figure><p><strong>表 T14</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">g</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">b</td><td style="text-align:center">c</td></tr></tbody></table><p>自然连接是构造新关系的有效方法，投影和选择是分解关系的有效方法，自然连接中如果两个关系没有公共属性则变成笛卡尔积</p><h4 id="除（DIVISION）"><a href="#除（DIVISION）" class="headerlink" title="除（DIVISION）"></a>除（DIVISION）</h4><p>除运算（R÷S） R和S代表两个不同的关系。<br>假如被除关系R 为 m 元关系，除关系S 为 n 元关系，则运算结果的新关系为 m-n元关系。</p><p><strong>Example 1：</strong></p><p><strong>表 T15</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">F</th><th style="text-align:center">G</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">j</td><td style="text-align:center">k</td><td style="text-align:center">l</td><td style="text-align:center">m</td><td style="text-align:center">n</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">c</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">b</td><td style="text-align:center">m</td><td style="text-align:center">n</td></tr></tbody></table><p><strong>表 T16</strong></p><table><thead><tr><th style="text-align:center">F</th><th style="text-align:center">G</th></tr></thead><tbody><tr><td style="text-align:center">f</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">n</td></tr></tbody></table><p>运算步骤：</p><ol><li>被除关系R对除关系S不同的属性 X 进行投影</li></ol><p><strong>X 投影</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">j</td><td style="text-align:center">k</td><td style="text-align:center">l</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">c</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">b</td></tr></tbody></table><p>待续。。。</p><ol start="2"><li>提取每个属性集值对应S元关系的象集</li></ol><p>2.1 |a|b|c|d|e| 值的象集</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">f</td><td style="text-align:center">g</td></tr></tbody></table><p>2.2 |h|i|j|k|l| 值的象集</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">m</td><td style="text-align:center">n</td></tr></tbody></table><p>2.3 |a|b|c|a|b| 值的象集</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">c</td><td style="text-align:center">d</td></tr></tbody></table><p>2.4 |a|c|e|f|b| 值的象集</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">m</td><td style="text-align:center">n</td></tr></tbody></table><ol start="3"><li>S 关系在公共属性 F G 的投影</li></ol><table><thead><tr><th style="text-align:center">F</th><th style="text-align:center">G</th></tr></thead><tbody><tr><td style="text-align:center">f</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">n</td></tr></tbody></table><p>通过 3 和 2 的对比 R÷S 为空</p><p><strong>Example 2：</strong><br>待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
         &lt;link href=&quot;/static/css/relation_data_model.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;

&lt;h3 id=&quot;基本的关系操作&quot;&gt;&lt;a href=&quot;#基本的关系操作&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Datebase basis" scheme="https://owen027.github.io/categories/Datebase-basis/"/>
    
    
      <category term="relational operation" scheme="https://owen027.github.io/tags/relational-operation/"/>
    
  </entry>
  
  <entry>
    <title>关系数据模型要素一 （关系数据结构）</title>
    <link href="https://owen027.github.io/2019/09/09/relation_data_model/"/>
    <id>https://owen027.github.io/2019/09/09/relation_data_model/</id>
    <published>2019-09-09T13:37:35.000Z</published>
    <updated>2019-09-18T13:48:28.345Z</updated>
    
    <content type="html"><![CDATA[<link href="/static/css/relation_data_model.css" rel="stylesheet" type="text/css"><h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><p>关系数据库的基本特征是使用关系模型的组织数据，20世纪80年代以后，在商用DBMS中，关系模型逐步取代早期的网状模型和层次模型。</p><h2 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h2><p>作为数据模型，关系模型包含三个组成要素：关系数据结构、关系操作集合和关系完整性约束。</p><h3 id="关系数据结构-重点"><a href="#关系数据结构-重点" class="headerlink" title="关系数据结构  重点"></a>关系数据结构  <label style="color:red; ">重点</label></h3><p> 结构只包含单一的数据结构（关系），现实世界的实体与实体间的各种联系均用关系来表示。关系模型是吧数据库比赛为关系的集合，并以二维表格的形式组织数据。</p><p> 录入一张二维表格如：</p><table><thead><tr><th>学号</th><th>姓名</th><th>性别</th><th>籍贯</th><th>民族</th><th>…</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>男</td><td>陕西</td><td>汉</td><td>…</td></tr><tr><td>002</td><td>李四</td><td>男</td><td>湘西</td><td>苗</td><td>…</td></tr><tr><td>003</td><td>王五</td><td>男</td><td>河北</td><td>汉</td><td>…</td></tr><tr><td>004</td><td>赵六</td><td>男</td><td>东北</td><td>汉</td><td>…</td></tr><tr><td>…</td></tr></tbody></table><h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><ol><li>表(Table)：也称为关系，是二维数据结构，由表名、构成表的各列及若干行数据组成，每个表由唯一的表名，每一行数据描述一条具体的记录值。</li><li>关系（Relation）：一个关系逻辑上对应一张二维表，可以为每个关系取一个名称来标识。关系有三种类型：基本关系（基表，实际存在的表，是实际存储数据的逻辑表示）、查询表（查询结构对应的表）和视图表（由基本表或其他视图导出的表，不对应实际存储的数据）。</li><li>列（Column）：称为字段（Field）或属性（Attribute）。每一列有一个名称，表示实体属性，具有相同数据类型。在一个数据库中，表名，字段名必须唯一，不同的表可以有相同的字段名，且命名须有意义，简单。</li><li>属性（Attribute）：表列即属性，给属性起名即属性名。属性的个数称为关系的元或度。列值为属性值；取值范围为值域。</li><li>行（Row）：称为元组（Tuple）或记录（Record）。表中的数据按行存储，一行数据即一条记录或元组，每行又若干个字段值组成。</li><li>分量（Component）：元组的属性值为分量</li><li>码/键（key）：在一个关系中，有一个属性或属性组，能用来标识该关系的元组，则为该关系的码或键。</li><li>超码或超键（Super Key）：从码中去除某个属性，它仍然是对应关系的码，则为超码；每个关系至少有一个默认的超码（所有属性的集合）。</li><li>候选码或键（Candidate Key）：关系中的一个码或键中，不能去除任何一个属性，否则它就不是对应关系表的码或键，则此码为候选码（键），它是关系表中最小的超码或超键。</li><li>主键/码(Primary Key)：在一张关系表中的若干候选键中指定一个用来唯一标识该关系的元组，则该候选键为主键。</li><li>全键/码（All-Key）：一个关系中所有的属性集合是是这个关系是主键/码，则为全键/码。</li><li>主/非属性（Primary Attribute/Nonprimary Attribute）：关系中包含任何一个候选键/码的属性为主/码属性，不包含任何一个候选码的属性为非主/码属性。</li><li>外键/码（Foreign Key）：关系中的某个属性或属性组不是这个关系的主键或候选键，而是另一个关系的主键，则该属性（属性组）为关系的外键/码。</li><li>参照关系(Referencing Relation)/被参照关系（Referenced Relation）：参照关系也称从关系，被参照关系又称主关系，它们指以外码相关联的两个关系。而以外码为主码的关系为被参照关系；外码所在的关系为参照关系，这种联系通常是一对多关联。</li><li>域（Domain）：指属性取值范围。</li><li>数据类型（Data Type）：每列（元关系）都有相应的数据类型，用于限制该列中存储的数据。</li><li>关系模式（Relation Schema）：通数据模型一样，数据库也有型和值，在关系数据库中关系模式是型，关系是值，关系模式是对关系的描述。</li></ol><table><thead><tr><th style="text-align:center">中文字段名</th><th style="text-align:center">数据类型</th><th style="text-align:center">宽度</th><th style="text-align:center">…</th></tr></thead><tbody><tr><td style="text-align:center">学号</td><td style="text-align:center">字符类型</td><td style="text-align:center">8</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">姓名</td><td style="text-align:center">字符类型</td><td style="text-align:center">10</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">身份证</td><td style="text-align:center">字符类型</td><td style="text-align:center">18</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>上表是学生基本星系登记表关系的结构定义，关系则是元组的集合，是关系模式在某一时刻的状态或内容</p><p><label>关系模式是静态的、稳定的，而关系是动态的、随时间不断变化，因为关系操作在不断地更新着数据库的数据</label>实际工作中关系模式和关系统称为关系。</p><ol start="18"><li>关系数据库（Relation Database）：以关系模型作为数据的逻辑模型，并采用关系作为数据组织方式的一类数据库，其数据库操作建立在关系代数的基础上。在给定的应用领域中，所以关系的集合构成一个关系数据库。</li></ol><p>在实际的数据库应用系统中，一般使用英文作为表名、字段名等。因为在编写数据库应用程序时，表名、字段名会作为变量名，使用中文不方便标识，且有些DBMS不能很好的兼容中文。 <label style="color:red; ">重点</label><br>因此上表应该变更为：</p><table><thead><tr><th style="text-align:center">含义</th><th style="text-align:center">字段名</th><th style="text-align:center">数据类型</th><th style="text-align:center">宽度</th><th style="text-align:center">…</th></tr></thead><tbody><tr><td style="text-align:center">学号</td><td style="text-align:center">studentNo</td><td style="text-align:center">字符类型</td><td style="text-align:center">8</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">姓名</td><td style="text-align:center">sutdentName</td><td style="text-align:center">字符类型</td><td style="text-align:center">10</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">身份证</td><td style="text-align:center">studentId</td><td style="text-align:center">字符类型</td><td style="text-align:center">18</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p><strong>关系数据库对关系的限定：</strong></p><ul><li>每个属性都不可分解，是关系数据库对关系的最基本的限定，要求关系的每个分量必须是一个不可分的数据项，即不允许表中有表</li><li>一个关系对应一种关系模式，模式中的属性的数据类型及属性的个数是相对固定的</li><li>每个关系模式中的属性必须命名，在同一模式中，属性名必须是不同的</li><li>同一关系中不允许出现候选码或键值完全相同的元组</li><li>关系中的元组顺序是可任意交换</li><li>关系中的属性顺序可以任意交换</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link href=&quot;/static/css/relation_data_model.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;

&lt;h2 id=&quot;概叙&quot;&gt;&lt;a href=&quot;#概叙&quot; class=&quot;headerlink&quot; title=&quot;概叙&quot;&gt;
      
    
    </summary>
    
      <category term="Datebase basis" scheme="https://owen027.github.io/categories/Datebase-basis/"/>
    
    
      <category term="relationDataModel" scheme="https://owen027.github.io/tags/relationDataModel/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础（Database Basis) (二)</title>
    <link href="https://owen027.github.io/2019/09/05/database_basis_2/"/>
    <id>https://owen027.github.io/2019/09/05/database_basis_2/</id>
    <published>2019-09-05T10:50:56.000Z</published>
    <updated>2019-09-24T12:33:09.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><blockquote><p>注：数据库（ DB ）数据库系统（DBS）数据库管理系统（DBMS） 数据库管理员（DBA）<br>在一个DBS中有着不同类型的用户，每个用户都从不同的角度以各自的观点看待数据库，从而形成了DBS不同的视图结构。因此DBS的结构可以有多种不同的层次或不同的视角。</p></blockquote><label>从数据库管理员（DBA）视角来看，DBS分为内部系统结构和外部体系结构，其中内部系统结构通常采用<code>三级模式结构</code>，外部体系结构通常表现为 <code>集中式结构</code>、<code>分布式结构</code>和<code>并行结构</code>等；</label><label>从数据库用户角度分为客户/服务器结构和浏览器/服务器结构，也就是DBS整体的运行与应用结构</label><h3 id="三级模式结构（DBA视角）"><a href="#三级模式结构（DBA视角）" class="headerlink" title="三级模式结构（DBA视角）"></a>三级模式结构（DBA视角）</h3><p>从DBA角度审视数据库系统，其内部基本遵循美国 <code>ANSI/SPAPRC</code> DBMS研究组提出的三体系结构（用户、概念级和物理级）。各个DBMS产品在体系结构上通常具有相同的特征（三级模式结构），并提供两层映像功能。DBS三模式结构是指 模式（Schema）、外模式（External Schema）和 内模式（Internal Schema）。</p><pre class="mermaid">graph LRA(数据库) --> B(内模式)B --内模式/模式映像--> C(模式)C -->  C1(外模式1)C --外模式/模式映像-->  C2(外模式2)C -->  C3(外模式3)C1 --> D1(应用1)C1 --> D2(应用2)C2 --> D3(应用3)C2 --> D4(应用4)C3 --> D5(应用5)C3 --> D6(应用6)</pre><p>外模式的描述向客户提供数据，内模式的描述存储数据，模式是两者的中间层，机不涉及数据的物理存储和硬件环境，也与具体应用程序、开发工具及设计语言无关。</p><p></p><h4>模式</h4><p></p><label>模式也称为概念模式或逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图，即数据在逻辑上的视图（又称概念视图）</label><p>DBA必须考虑整个数据库的全局概念视图，它不包含任何的数据库实现细节，如何种D是BMS、文件组织、存取方法及设备特征等；而是定义数据库的逻辑结构、数据之间的联系，及数据相关的安全性、完整性等要求（由DBMS提供模式描述语言（Schema DDL）），同时一个数据库只有有个模式，且相对稳定。</p><h4 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h4><label>  外模式也称为子模式（Subschema）或用户模式,是数据库用户能看见和使用的局部数据的逻辑结构和特征的描述，是与某一应用有关数据的逻辑表示。（DBMS提供子模式描述语言（Subschema DDL）来严格定义子模式）<br>通常其用于满足不同数据库用户需求的数据视图（用户视图），是模式的子集，对数据库整体数据的局部重构。<br>不同用户在看待数据的方式、应用需求、对数据保密的要求等方面存在差异，对应外模式描述就不同，且模式中同样的数据，在外模式中的结构、类型、长度、保密级别等都可以不同</label><p>外模式是保证数据库安全的重要措施，每个用户只能看见和访问所对应的外模式中的数据，简化了DBS的用户接口，便于用户使用，并有效支持数据独立性和共享性。</p><h4 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h4><p>内模式也称存储模式（Storage Schema）, 是对数据库中的物理结构和存储方式的描述，是数据在数据库内部的表现形式。是整个数据库的最底层表示，它不同于物理层，是DBA所见到的，特定的DBMS所处理的数据库的内部结构（内部视图或存储视图）。</p><label>和模式一样，内模式在一个数据库中只有一个，它不存储设备上的物理记录或物理快，也不涉及任何具体设备限制。</label><h4 id="两层映像与数据独立性-重点"><a href="#两层映像与数据独立性-重点" class="headerlink" title="两层映像与数据独立性 重点"></a>两层映像与数据独立性 <label style="color:red; ">重点</label></h4><p>总体而言，三个模式的对数据的三级抽象，其特点如下：</p><ul><li>一个数据库的整理逻辑结构和特征的描述（概念模式）是独立于数据库其他层次结构（内/外模式）的描述，其是数据库的核心，也是数据库设计的关键。</li><li>一个数据库的内部存储模式依赖于概念模式，并且独立于外部模式和具体的存储设备。</li><li>用户逻辑结构（外模式）是在全局逻辑结构描述的基础上定义的，它面向具体的应用程序，独立于内部模式和存储设备。</li><li>应用程序是在外模式的逻辑结构上编写，依赖于特定的外模式，与数据库的模式和存储结构独立。</li></ul><label>用户不必考虑数据的物理存储细节，将其交给DBMS负责管理，同时为有效支撑数据库的三级抽象及它们之前的联系和相互转换，DBMS通过提供两层映像来实现（外模式/模式 和 模式/内模式）</label><h5 id="映像"><a href="#映像" class="headerlink" title="映像"></a>映像</h5><p>映像是指一种对应规则，指出映像双方如何进行转换。</p><ul><li>外模式/模式映像：定义各个外模式与概念模式之间的映像关系，这些定义通常在各自的外模式中加以描述。DBS的模式如若发生改变（增加新的关系、属性、改变数据类型等)，DBA会对各个映像做出相应改变，使那些对用户可见的外模式保持不变，从而使程序员不必去修改那些依据数据的外模式所编写的程序，这样外模式就不受模式的影响，保证数据与程序的独立性。</li><li>模式/内模式：定义数据库全局逻辑结构与物理存储之间的关系，通常在模式中加以描述。而DB只有一个模式，所以此映像是唯一的。同样，DBS 的物理存储如若发生改变（选用另一个存储结构或更换存储位置），DBA会的此映像做出相应调整，使DBS 的模式保持不变，不必修改应用程序，保证的物理独立性</li></ul><p>因此，两层映像保证了DBS中的数据具有较高的逻辑独立性和物理独立性，使数据的定义和描述可以从应用程序中分离，简化数据库应用程序的开发，减少维护工作量。</p><h3 id="DBS-的运行与应用结构（用户视角）"><a href="#DBS-的运行与应用结构（用户视角）" class="headerlink" title="DBS 的运行与应用结构（用户视角）"></a>DBS 的运行与应用结构（用户视角）</h3><h4 id="客户-服务器结构"><a href="#客户-服务器结构" class="headerlink" title="客户/服务器结构"></a>客户/服务器结构</h4><p>在DBMS中，DB的使用者（程序员，DBA等）可以使用命令行客户端、图形化界面管理工具、应用程序等连接DBMS，通过DBMS查询和处理存储在底层数据库中的各种数据。<label>那些不与DBMS直接联系的工具和程序被称为<code>客户端</code>、<code>前台</code>或<code>表示层</code>，主要完成交互任务，而DBMS称为<code>服务器</code>、<code>后台</code>或<code>数据层</code>，主要负责数据管理。</label> 这种工作模式就是客户/服务器结构(Client/Server,C/S).</p><h4 id="浏览器-服务器结构"><a href="#浏览器-服务器结构" class="headerlink" title="浏览器/服务器结构"></a>浏览器/服务器结构</h4><p>此结构基于Web应用的客户/服务器结构，或者三层客户/服务器结构。<br>在DBS中，它将与DBMS交互的客户端进一步细分为<code>表示层</code>和<code>处理层</code>。</p><p>表示层：指数据库使用者的操作和展示界面，通常由各种浏览器构成<br>处理层（中间层）：负责处理数据库使用者的具体应用逻辑，与后台的DBMS共同组成功能丰富的<code>胖服务器</code> 。</p><p>这种工作模式就是浏览器/服务器结构（Browser/Server，B/S）</p><hr><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><blockquote><p>模型是现实世界特征的模拟和抽象表达，帮助人们更好的认识和理解客观事物、对象和过程等感兴趣的内容（飞机航模、建筑图纸、军事沙盘等）。而数据模型是用来模拟和抽象现实世界中的数据特征，描述的是数据的共性内容。</p></blockquote><h3 id="数据特征与数据模型组成要素"><a href="#数据特征与数据模型组成要素" class="headerlink" title="数据特征与数据模型组成要素"></a>数据特征与数据模型组成要素</h3><p>数据具有静态和动态两种特征。<br>静态特征：数据的基本结构、数据间的联系及对数据取值范围的约束。<br>动态特征：指对数据可以进行符合一定规则的操作。<br><strong>数据模型通常由数据结构、数据操作和数据约束三要素组成：</strong></p><ul><li>数据结构：是描述系统的静态特性，数据对象的类型、内容、属性及数据对象之间的联系。如层次结构、网状结构、关系结构的数据模型分别命名为层次模型、网站模型、关系模型及面向对象模型。</li><li>数据操作：描述的是系统动态特性，是对各种对象的实例允许执行的操作集合，包括操作及相关的操作规则。主要分为更新（增、删、改）和检索两大类。数据模型必须定义这些操作的确切含义、操作符号、操作规则（优先级等）及实现操作的语言。</li><li>数据约束：描述数据结构中国数据间的语法和语义关联，包括相互制约与依存关系及数据动态变化规则，保证数据正确性、有效性与相容性。约束包含数据完整性约束、数据安全性及并发控制约束；数据约束既刻画了数据静态特征，也表示了数据动态行为规则。</li></ul><h3 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h3><p><strong>数据模型应满足三个要求：</strong></p><ol><li>能比较真实的模拟现实世界</li><li>容易使人们理解</li><li>便于在计算机上实现</li></ol><p>目前一种数据模型要完全满足三个要求，很困难，因此需针对不同对象和应用，采取逐步抽象的方法，在不同抽象层使用不同的数据模型。</p><h4 id="概念层数据模型（数据的概念模型-（Conceptual-Model）-信息模型）"><a href="#概念层数据模型（数据的概念模型-（Conceptual-Model）-信息模型）" class="headerlink" title="概念层数据模型（数据的概念模型 （Conceptual Model）,信息模型）"></a>概念层数据模型（数据的概念模型 （Conceptual Model）,信息模型）</h4><p>概念层是数据抽象级别的最高层，目的是按照用户的观点对世界建模。概念层模型用来描述现实世界的事物，是对信息世界建模，与具体的计算机系统无关，独立于任何DBMS，容易向DBMS所支持的逻辑数据库模型转换，此类模型主要用于数据库的设计阶段，表示现实世界的各个事物及其联系。</p><h5 id="信息世界中的基本概念（类似于对象）重点"><a href="#信息世界中的基本概念（类似于对象）重点" class="headerlink" title="信息世界中的基本概念（类似于对象）重点"></a>信息世界中的基本概念（类似于对象）<label style="color:red;">重点</label></h5><p>概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具，是设计人员和用户之间交流的语言，因此概念模型具有较强的语义表达能力，能够方便、直接地表达应用中的各种语义知识，它简单、清晰、易于理解。</p><ul><li>实体（Entity）：客观存在并可相互区别的事物，既可以是实体事物，也可以说抽象的概念或联系（学生、商品、部门、课程、比赛等都可以是实体）</li><li>属性（Attribute）：实体所具有的某种特性，一个实体可以由多个属性描述（性别，名称、日期，年龄等等）</li><li>码或键（Key）：可唯一标识实体的属性集。如学生的学号</li><li>域（Domain）：一个属性的取值范围。如学生实体中姓名的域</li><li>实体型（Entity Type）：具有相同属性的实体必然具有共同的特征和性质。用实体名于属性名集合抽象和刻画同类实体即实体型。（学号，姓名，性别）</li><li>实体集（Entity Set）：同实体的集合。（每个学生是一个实体，所以学生组成实体集）</li><li>联系（Relatinship）：现实世界中，事物内部及事物之间是有联系的，反应到信息世界中即实体（型）内部的联系和实体（型）之间的联系。实体内部的联系通常指各属性之间的联系。如确定学号，即知道对应的姓名，学号与姓名两个属性之间有联系。实体之间的联系指不同实体间的联系。如一个班有许多学生，一个学生只属于一个班级，这是学生与班级两个实体间的联系。</li></ul><p>数据模型中有<code>型【type】</code>（某一类数据的结构和属性说明）和<code>值【value】</code>（对型的赋值）的概念</p><h5 id="概念模型的表示方法"><a href="#概念模型的表示方法" class="headerlink" title="概念模型的表示方法"></a>概念模型的表示方法</h5><p>概念模型的表示方法有很多种，最常用的是实体-联系方法（Entity-Relationship approach）也称E-R模型，它是抽象和描述现实世界的有力工具，它独立于具体的DBMS所支持的逻辑模型，是各种逻辑模型的共同基础。</p><h4 id="逻辑层数据模型"><a href="#逻辑层数据模型" class="headerlink" title="逻辑层数据模型"></a>逻辑层数据模型</h4><p>逻辑层是数据抽象的中间层，描述数据整体逻辑结构；这层的数据抽象被称为逻辑模型，是用户通过DBMS看到的现实世界，基于计算机系统的观点来对数据进行建模和表示。因此，它既要让用户易于理解，又要便于DBMS实现。<br>主要的逻辑数据模型有 层次模型（Hierarchical）、网站模型（Network Model）、关系模型（Relational Model）和面向对象模型（Object Oriented Model）等</p><h5 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h5><p>此模型是数据库最早的一种数据模型，它的数据结构是一颗“有向树”，数的每个结点对应一个记录集。特点：有且仅有一个结点没有父结点（根结点）；其他结点有且仅有一个父结点。</p><h5 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h5><p>此模型以网状结构表示实体与实体之间的联系。是层次模型的扩展，允许结点又多个父结点，且可以有多个节点没有父结点。此模型可以方便的表示实体间各种类型的联系，但结构复杂，实现的算法难以规范化。</p><h5 id="关系模型-重点"><a href="#关系模型-重点" class="headerlink" title="关系模型 重点"></a>关系模型 <label style="color:red;">重点</label></h5><p>此模型用二维表结构来表示实体及实体间联系的模型，并以二维表格的形式组织数据库中的数据。<br><strong>特点：</strong></p><ul><li>建立在严格的数学概念基础之上</li><li>概念单一，统一用关系表示实体及实体间的联系，对数据的检索与更新结果同样也用关系（即表）表示。</li><li>关系模型的存取路径对用户透明，这样就具有更高的数据独立性、更好的安全保密性，简化了程序员的开发工作。目前流行的商用数据库大多基于关系模型（关系数据库管理系统）。</li></ul><h5 id="面向对象模型"><a href="#面向对象模型" class="headerlink" title="面向对象模型"></a>面向对象模型</h5><p>此模型是面向对象方法与数据库相结合所构成的数据模型。它既是概念模型又是逻辑模型。用面向对象观点描述现实世界实体逻辑组织、对象间的联系。</p><h4 id="物理层数据模型"><a href="#物理层数据模型" class="headerlink" title="物理层数据模型"></a>物理层数据模型</h4><p>此模型又叫数据的物理模型，描述数据在存储介质上的组织结构，是逻辑模型的物理实现，每一种逻辑模型在实现时都有与其对应的物理模型。物理模型是数据库最底层的抽象，它确定数据的物理存储结构、数据存取路径及调整、优化数据库的性能。<br>物理数据结构一般向用户屏蔽，用户不必了解其细节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库系统的结构&quot;&gt;&lt;a href=&quot;#数据库系统的结构&quot; class=&quot;headerlink&quot; title=&quot;数据库系统的结构&quot;&gt;&lt;/a&gt;数据库系统的结构&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;注：数据库（ DB ）数据库系统（DBS）数据库管理系统（DBMS
      
    
    </summary>
    
      <category term="Database basis" scheme="https://owen027.github.io/categories/Database-basis/"/>
    
    
      <category term="Database_basis_2" scheme="https://owen027.github.io/tags/Database-basis-2/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础（Database Basis) (一)</title>
    <link href="https://owen027.github.io/2019/09/04/database_basis_1/"/>
    <id>https://owen027.github.io/2019/09/04/database_basis_1/</id>
    <published>2019-09-04T13:50:21.000Z</published>
    <updated>2019-09-24T12:33:09.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><p>数据库技术是对数据进行管理的技术，能有科学地管理各类信息资源。数据、数据库、数据库管理系统和数据库系统是数据库常用的基本概念。</p><h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><h3 id="数据（Data）"><a href="#数据（Data）" class="headerlink" title="数据（Data）"></a>数据（Data）</h3><label>数据是描述事物的符号记录，指用物理符号记录下来的、可鉴别的信息。</label><p><strong>数据有多种表现类型：</strong></p><ul><li>文本数据：数字、字母、特殊字母、文字等组成</li><li>多媒体数据：图像、图形、动画、影像、声音、语言等组成</li></ul><p>各种类型的数据经过数字化处理后存入计算机，便于进一步加工、处理、使用</p><p>人们通常只抽取感兴趣的事物特征或属性来描述事物。例如，人们关注客户的姓名、性别、年龄、籍贯、所在地区、联系方式等特征，（张三，男，26，北京，上海，1383838444；）这些具体的特征值就构成一组数据，就是一条记录</p><label> 数据记录往往不能完全表达其内容的含义，还需经过解释才能表达明确含义;</label>如： 张三，男，26岁，北京人，住在上海，联系电话是1383838444；而不了解数据含义的人难以从北京、上海的地名上理解所表达的意思<br>因此数据及关于该数据的解释密切相关，数据的解释是对数据的含义说明，也称数据的语义，即数据所蕴含的信息，没有语义的数据是没有意义和不完整的。<br><br>数据是信息存在的一直形式，只有通过解释或处理的数据才能成为有用的信息。<br><br><br> <h3> 数据库（Database）</h3><br><label>数据库是存储数据的仓库，是有组织的、可共享的数据集合，且数据库中的数据按一定的数据模型组织、描述和永久存储，具有较小的冗余度、较高的数据独立性，系统易于扩展，并可以被多个用户共享</label><h3 id="数据库管理系统（Database-Management-System，DBMS）"><a href="#数据库管理系统（Database-Management-System，DBMS）" class="headerlink" title="数据库管理系统（Database Management System，DBMS）"></a>数据库管理系统（Database Management System，DBMS）</h3><label><br>是一套建立和管理数据库的软件，介于应用程序和操作系统之间。负责科学有效地组织和存储数据，并帮助使用者从大量的数据中快速地获取所需数据，提供必要的安全性和完整性等</label><p><strong>主要功能：</strong></p><ul><li>数据定义功能：通过系统提供的数据定义语言（Data Definition Language, DDL），定义数据库中的数据对象，包括表、视图、存储过程、触发器等</li><li>数据操纵功能：通过系统提供的数据操作语言（Data Manipulation Language, DML），对数据库增、删、改、查等</li><li>数据库运行管理功能：由于数据库具有共享性，为保证数据的安全性、可靠性，系统提供了统一的控制和管理机制，实现数据在不被相互干扰的情况下并发使用，并且发生故障时能对数据库进行正确的恢复</li><li>数据库建立和维护功能：主要包括创建数据库及对数据库空间的维护、数据库的备份与回复功能、数据库的重组织功能和性能监视、分析等，一般通过系统提供的一些实用工具实现。</li><li>数据组织、存储和管理功能：为提高数据的存取效率，系统需对数据进行分类存储和管理，根据具体组织和存储方式提供多种数据存取方法，如索引查找、顺序查找等</li><li>其他功能：主要于其他软件的网络通信、不同数据库管理系统之间的数据传输及相互访问功能等。</li></ul><h3 id="数据库系统（Database-System，-DBS）"><a href="#数据库系统（Database-System，-DBS）" class="headerlink" title="数据库系统（Database System， DBS）"></a>数据库系统（Database System， DBS）</h3><p>指计算机中引入数据库技术之后的系统。通常一个完成的数据库系统包括 数据库、数据库管理系统及相关实用工具、应用程序、数据库管理员和用户。</p><p>数据库管理员（Database Administrator, DBA）不同于普通数据库用户，他们专门负责对数据库进行维护，并保证数据库正常、高效运行</p><p>用户则是数据库系统的服务对象，通常包括程序员和数据库终端用户，程序员通过高级程序设计语言（JAVA,PHP等）和数据库语言（SQL）编写数据库应用程序。</p><p>一般不引起混淆，常将数据库系统简称数据库。</p><hr><p></p><h2 style="text-align:center">数据库管理技术的发展</h2><br><strong>数据库管理可从两方面理解：</strong><p></p><ul><li>针对组织业务管理：负责制定并执行整个组织中关于数据的定义、组织、保护与有效使用的策略、过程和计划</li><li>依靠技术：负责实现数据作为一种资源的集中控制管理</li></ul><p><strong>数据组织：</strong>以便于处理的某种方式收集数据，并将记录在纸介文件上的数据转换成计算机可处理的形式；然后将收集的数据进行适当的构造</p><p><strong>数据组织分为两种：</strong></p><ul><li>逻辑组织：用户或应用程序所使用的数据结构形式</li><li>物理组织：数据在物理存储设备上的结构形式</li></ul><p>检索：存储的数据能方便的被选择提取</p><label>数据管理的任务是进行数据的收集、组织、控制、存储、选取、维护，实现在适当的时候，以适当的形式，给适当的人提供适当的数据；是数据处理的中心问题</label><p><strong>数据处理：</strong>指对各种数据进行收集、存储、加工、和传播的一系列活动的总和</p><h3 id="管理技术的发展阶段"><a href="#管理技术的发展阶段" class="headerlink" title="管理技术的发展阶段"></a>管理技术的发展阶段</h3><h4 id="人工管理阶段"><a href="#人工管理阶段" class="headerlink" title="人工管理阶段"></a>人工管理阶段</h4><p>20世纪50年代中期以前，计算机主要用于科学计算，所涉及的数据处理工作基本上都是靠手工方式进行</p><p><strong>主要特点：</strong></p><ul><li>数据不会保存：由于计算机软件和硬件发展刚刚起步，存储容量有限且价格昂贵，通常一组数据对应一个程序，数据随程序一起输入计算机，处理完毕后即将出结果，数据空间随着程序空间一起被释放</li><li>应用程序管理数据：当时没有专门的数据管理软件，应用程序的数据由程序自行负责，因而数据的组织方式必须由程序员自己设计、定义和管理。所有包括逻辑结构、物理结构、存取方法等数据库设计工作都由应用程序的编写人员来完成，程序员的工作负担十分繁重</li><li>数据面向应用：一组数据对应一个程序，多个应用程序涉及某些相同的数据时必须各自定义，不能共享，因此程序与程序之前存在大量冗余数据，数据独立性差</li></ul><h4 id="文件系统阶段"><a href="#文件系统阶段" class="headerlink" title="文件系统阶段"></a>文件系统阶段</h4><p>20世纪50年代中期到60年代中期，计算机软、硬件发展到一定阶段。其中，硬件方面配置了磁盘、磁鼓等直接存储设备；软件则在操作系统中配备了专门的数据管理软件，即文件系统</p><p>文件系统是将数据的逻辑结构和物理结构分离，由“存放方法”实现逻辑结构与物理结构执行的映射。应用程序只涉及数据的逻辑结构，系统决定数据的物理结构，两者直接可以由差别，这样不会相互影响（数据的物理独立性），使得使用性提高，同时程序员不必关心数据的物理存储细节，生产效率大大提高</p><p><strong>主要特点：</strong></p><ul><li>数据可长期保存和专门管理：磁盘、磁鼓等直接存储设备；软件则在操作系统中配备了专门的数据管理软件</li><li>物理数据独立性：应用程序与数据的具体物理存储结构分离</li><li>文件级数据共享：通过数据的抽取、排序、合并等为应用提供新的文件，不能实现数据项级的普通共享；文件的逻辑结构是根据它的应用而设计，数据的逻辑结构与应用程序之间相互依赖。不同应用程序必须构造各自的文件，数据项大部分相同时还是存在大量的数据冗余。</li></ul><h4 id="数据库系统阶段"><a href="#数据库系统阶段" class="headerlink" title="数据库系统阶段"></a>数据库系统阶段</h4><p>数据库技术是应数据管理任务的需要而产生。20世纪60年代末以来，计算机技术与工业迅速发展，计算机开始广泛应用于企业管理，并对计算机数据管理提出更高的<strong>要求：</strong></p><ul><li>数据作为企业组织的公共资源而集中管理控制，能为企业各类用户共享，须大量地消除数据冗余，节省存储空间；</li><li>当数据变更时，能节省对多个数据副本的多次变更操作，从而缩小计算机运算时间，不会遗漏某些副本的变更而使系统出现不一致的数据</li><li>数据要具有更高的独立性，不但具有物理独立性，而且具有逻辑独立性，当数据逻辑结构改变时，不影响那些不须改变的用户应用程序，节省开发和维护的代价</li></ul><p><strong>数据库系统的特点</strong></p><ul><li>数据集成：数据库管理系统的主要目的就说数据集成。在数据库中，通过相关联数据间定义的逻辑联系，数据被组成统一的逻辑结构，与数据的物理组织与定位分离，应用的修改、增加只与数据的逻辑结构发生关系。</li><li>数据共享性高：在数据库中，一个数据可为多个不同用户共同使用，各个用户可以为了不同的目的来存取相同的数据，他们从各种不同的角度来看待数据库，即<label>一个数据库有多种不同的用户视图</label>。这些用户视图简化了数据的共享，它们可以给每个用户提供执行其业务职能所要求的数据的准确视图，使用户无须知道数据库的全部复杂组成。<label>共享不仅是同一数据被不同用户存取，还包含并发共享，不同用户可同时存取同一的数据</label></li><li>数据冗余小：将独立而又冗余的数据文件集成为单一的逻辑结构，每个数据项的值可以理想地只存储一次，从而节约空间，避免数据的重复存储。<label>并非所有的冗余都可以被消除，有时业务或技术上的原因，如数据的合法性检验、数据存储效率等方法，同一数据可能在数据库种保持多个副本，因此数据库系统种，冗余是受控的，系统知道冗余，保留必要的冗余是系统预定的</label></li><li>数据一致性：通过消除或控制数据冗余，可在一定范围内避免数据的不一致性。</li><li>数据独立性高：数据定义与使用数据的应用程序分离，一方的修改不会影响另一方的修改。<br><strong>数据库提供了两层数据独立：</strong></li></ul><ol><li><strong>逻辑独立：</strong>不同的应用程序对同样的数据可以使用不同的视图，即应用程序一定范围内修改它的数据库视图，而不修改数据本身的定义；而数据定义的修改，在一定范围内不会引起应用的修改</li><li><strong>物理独立：</strong>改变数据的存储结构或存取方法以响应变化的需求而无需修改现有的应用程序</li></ol><ul><li><p>实施统一管理与控制：主要包括数据的安全性、完整性、并发控制与故障恢复等（数据库包含）</p><ol><li>数据安全性（Security）：指保护数据，防止非法使用造成数据泄密和破坏，每个用户只能按规定对某些数据以某些方式进行使用和处理，保证数据只有赋予权限的用户才能访问数据。</li><li>数据完整性（Integrity）：对数据的正确性、有效性和相容性的校验，即控制数据在一定范围内有效或要求数据之前满足一定的关系，保证输入到数据库中的数据满足相应的约束条件，确保数据<label>有效、正确</label></li><li>并发控制（Concurrency）：多个用户的并发进程同时存储、修改数据库时，可能发生相互干扰，而得到错误结果，使得数据库的完整性糟到破坏，因此对多用户的并发操作加以控制和协调。如用户网上订购火车票，系统必须确保不会由于多个用户同时购买相同的车票而造成冲突。</li><li>故障恢复：计算机产生的硬件故障、操作员的失误以及人为的破坏都会影响数据库中数据的正确性，DBMS必须具有将数据库从错误状态恢复到某一已知的正确状态的功能。</li></ol></li><li><p>减少应用程序开发与维护的工作量：<label>由于数据库中的数据具有共享性、独立性，使得程序员不在需要承担基本数据文件的设计、建造与维护等繁重负担</label></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概叙&quot;&gt;&lt;a href=&quot;#概叙&quot; class=&quot;headerlink&quot; title=&quot;概叙&quot;&gt;&lt;/a&gt;概叙&lt;/h2&gt;&lt;p&gt;数据库技术是对数据进行管理的技术，能有科学地管理各类信息资源。数据、数据库、数据库管理系统和数据库系统是数据库常用的基本概念。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="Datebase basis" scheme="https://owen027.github.io/categories/Datebase-basis/"/>
    
    
      <category term="Database_basis_1" scheme="https://owen027.github.io/tags/Database-basis-1/"/>
    
  </entry>
  
  <entry>
    <title>访问媒体设备</title>
    <link href="https://owen027.github.io/2019/08/12/mediaDevices/"/>
    <id>https://owen027.github.io/2019/08/12/mediaDevices/</id>
    <published>2019-08-12T07:54:16.000Z</published>
    <updated>2019-09-06T14:33:47.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><blockquote><p>mediaDevices 是 Navigator 对象的只读属性，一个单列对象，可以连接访问相机和麦克风，屏幕共享等媒体输入设备</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="enumerateDevices"><a href="#enumerateDevices" class="headerlink" title="enumerateDevices"></a>enumerateDevices</h3><blockquote><p>请求一个可用的媒体输入和输出设备列表，如麦克风、相机、耳机等。返回的 <code>Promise</code>完成状态中是一个带有 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo">MediaDeviceInfo</a> 的数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mediaDevices = navigator.mediaDevices</span><br><span class="line"><span class="keyword">if</span>(!mediaDevices || !mediaDevices.enumerateDevices) <span class="keyword">return</span> <span class="built_in">console</span>.erorr(<span class="string">'浏览器不支持enumerateDevices API'</span>)</span><br><span class="line">navigator.mediaDevices.enumerateDevices()</span><br><span class="line">.then(<span class="function">(<span class="params">devices</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> device <span class="keyword">of</span> devices)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(device.kind + <span class="string">': '</span> +device.lable + <span class="string">' id = '</span>+ device.deviceId );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">audioinput: undefined id = default</span></span><br><span class="line"><span class="comment">audioinput: undefined id = communications</span></span><br><span class="line"><span class="comment">audioinput: undefined id = ac67d348685a08c75e5017f9a449b3d85f08dcb774c88ab95de82bbf2c0fc820</span></span><br><span class="line"><span class="comment">videoinput: undefined id = e41039bcfbc84d926a0b73cdc1d8b1daf3d67d36c62588202191d918fb076426</span></span><br><span class="line"><span class="comment">audiooutput: undefined id = default</span></span><br><span class="line"><span class="comment">audiooutput: undefined id = communications</span></span><br><span class="line"><span class="comment">audiooutput: undefined id = 015d73652e57bffb21679b937675d32c4d4a43862aba3774aaf0b5f1e983151f</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p><img src="/static/img/enumerateDevices.png" alt="enumerateDevices"></p><h3 id="getSupportedConstraints"><a href="#getSupportedConstraints" class="headerlink" title="getSupportedConstraints"></a>getSupportedConstraints</h3><blockquote><p>返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaTrackSupportedConstraints">MediaTrackSupportedConstraints</a> 对象，其属性都是客户端所支持约束的属性,值为 Boolean 类型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> supportedConstraints = navigator.mediaDevices.getSupportedConstraints()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> constraint <span class="keyword">of</span> <span class="built_in">Object</span>.keys(supportedConstraints))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(constraint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">aspectRatio</span></span><br><span class="line"><span class="comment">autoGainControl</span></span><br><span class="line"><span class="comment">brightness</span></span><br><span class="line"><span class="comment">channelCount</span></span><br><span class="line"><span class="comment">colorTemperature</span></span><br><span class="line"><span class="comment">contrast</span></span><br><span class="line"><span class="comment">deviceId</span></span><br><span class="line"><span class="comment">echoCancellation</span></span><br><span class="line"><span class="comment">exposureCompensation</span></span><br><span class="line"><span class="comment">exposureMode</span></span><br><span class="line"><span class="comment">exposureTime</span></span><br><span class="line"><span class="comment">facingMode</span></span><br><span class="line"><span class="comment">focusDistance</span></span><br><span class="line"><span class="comment">focusMode</span></span><br><span class="line"><span class="comment">frameRate</span></span><br><span class="line"><span class="comment">groupId</span></span><br><span class="line"><span class="comment">height</span></span><br><span class="line"><span class="comment">iso</span></span><br><span class="line"><span class="comment">latency</span></span><br><span class="line"><span class="comment">noiseSuppression</span></span><br><span class="line"><span class="comment">pointsOfInterest</span></span><br><span class="line"><span class="comment">resizeMode</span></span><br><span class="line"><span class="comment">sampleRate</span></span><br><span class="line"><span class="comment">sampleSize</span></span><br><span class="line"><span class="comment">saturation</span></span><br><span class="line"><span class="comment">sharpness</span></span><br><span class="line"><span class="comment">torch</span></span><br><span class="line"><span class="comment">volume</span></span><br><span class="line"><span class="comment">whiteBalanceMode</span></span><br><span class="line"><span class="comment">width</span></span><br><span class="line"><span class="comment">zoom</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h4><p><img src="/static/img/supportedConstraints.png" alt="supportedConstraints"></p><h3 id="getDisplayMedia"><a href="#getDisplayMedia" class="headerlink" title="getDisplayMedia"></a>getDisplayMedia</h3><blockquote><p>提示用户选择和授予权限来捕获显示或部分的内容，(如分屏共享时分享哪一屏的内容)然后使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_Recording_API">medieaStream Recording API</a> 记录生成的 stream，或作为 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API">webRTC</a> 会话的一部分进行传输。</p></blockquote><p>可以传递一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints">MediaStreamConstraints</a> 对象指定返回要求的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream">mediaStream</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startCapture</span>(<span class="params">displayMediaOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> captureStream = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    captureStream = <span class="keyword">await</span> navigator.mediaDevices.getDisplayMedia(displayMediaOptions);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Error: "</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> captureStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="兼容性-2"><a href="#兼容性-2" class="headerlink" title="兼容性"></a>兼容性</h4><p><img src="/static/img/displayMedia.png" alt="displayMedia"></p><h3 id="getUserMedia"><a href="#getUserMedia" class="headerlink" title="getUserMedia"></a>getUserMedia</h3><blockquote><p>提示用户给予使用媒体输入的许可（如麦克风，摄像机）,当媒体输入时产生一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream">mediaStream</a>包含所请求的媒体类型的轨道。该流可以包括视频轨道（摄像机，视频记录设备，共屏等硬件或虚拟视频流源）、音频轨道（来自麦克风、A/D转换器等硬件或虚拟音频源），也可能是其它轨道类型</p></blockquote><p>该方法返回一个<code>Promise</code>对象,成功时 <code>resolve</code> 回调函数带有<code>mediaStream</code>对象。如果用户拒绝授予使用权限，或是媒体源不可用，则返回 <code>reject</code>回调</p><p><strong> <code>Promise</code> 可能既不会 <code>resolve</code> 也不会<code>reject</code>,因为用户不必做出选择，可能只是忽略请求</strong></p><p><img src="/static/img/microphone.png" alt="microphone"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想要获取一个最接近 1280x720 的相机分辨率</span></span><br><span class="line"><span class="keyword">let</span> constraints = &#123; <span class="attr">audio</span>: <span class="literal">true</span>, <span class="attr">video</span>: &#123; <span class="attr">width</span>: <span class="number">1280</span>, <span class="attr">height</span>: <span class="number">720</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">navigator.mediaDevices.getUserMedia(constraints)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">mediaStream</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line">  video.srcObject = mediaStream;</span><br><span class="line">  video.onloadedmetadata = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    video.play();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123; <span class="built_in">console</span>.log(err.name + <span class="string">": "</span> + err.message); &#125;);</span><br></pre></td></tr></table></figure><h4 id="参数-constraints"><a href="#参数-constraints" class="headerlink" title="参数 constraints"></a>参数 constraints</h4><blockquote><p>一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaStreamConstraints">mediaStreamConstraints</a>对象指定请求的媒体类型和相对应参数，该对象包含 <code>video</code> 和 <code>audio</code> 两个属性，必须一个或两个同时被指定，如果无法找到指定的媒体类型或无法满足对于的参数要求，<code>Promise</code>将返回 <code>rejected</code></p></blockquote><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">audio</span>:<span class="literal">true</span>,<span class="attr">video</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>属性设置为 Truthy 则生成的<code>stream</code> 必须具有该类型的轨道，否则调用 <code>getUserMedia</code>会抛出错误</strong></p><h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  audio: <span class="literal">true</span>,</span><br><span class="line">  video: &#123; <span class="attr">width</span>: <span class="number">1280</span>, <span class="attr">height</span>: <span class="number">720</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>表示<code>video</code>的分辨率应为 1280x720 浏览器将试着满足这个请求参数，如果无法满足要求或选择覆盖，则可能返回其它的分辨率</strong></p><h5 id="3"><a href="#3" class="headerlink" title="3"></a>3</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  audio: <span class="literal">true</span>,</span><br><span class="line">  video: &#123;</span><br><span class="line">    width: &#123; <span class="attr">min</span>: <span class="number">1280</span> &#125;,</span><br><span class="line">    height: &#123; <span class="attr">min</span>: <span class="number">720</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此配置要求了最低分辨率，如果达不到要求，<code>promise</code> 将返回 <code>reject</code>;还可配置 max、exact(min == max),而且用户将不会得到要求授权的提示</strong></p><h5 id="4"><a href="#4" class="headerlink" title="4"></a>4</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  audio: <span class="literal">true</span>,</span><br><span class="line">  video: &#123;</span><br><span class="line">    width: &#123; <span class="attr">min</span>: <span class="number">1024</span>, <span class="attr">ideal</span>: <span class="number">1280</span>, <span class="attr">max</span>: <span class="number">1920</span> &#125;,</span><br><span class="line">    height: &#123; <span class="attr">min</span>: <span class="number">776</span>, <span class="attr">ideal</span>: <span class="number">720</span>, <span class="attr">max</span>: <span class="number">1080</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果使用<code>ideal</code>,浏览器将尝试找到（如果相机有多个的话）最接近指定值的理想值的设备或相机</strong><br>意味着上方的第一个分辨率例子可简写为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  audio: <span class="literal">true</span>,</span><br><span class="line">  video: &#123;</span><br><span class="line">    width: &#123; <span class="attr">ideal</span>: <span class="number">1280</span> &#125;,</span><br><span class="line">    height: &#123; <span class="attr">ideal</span>: <span class="number">720</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><p><strong>并不是所有的 <code>constraint</code> 都说数字，如在移动设备上优先使用前置相机</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">audio</span>: <span class="literal">true</span>, <span class="attr">video</span>: &#123; <span class="attr">facingMode</span>: <span class="string">"user"</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p><p><strong>强制使用后置相机</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">audio</span>: <span class="literal">true</span>,</span><br><span class="line"> video: &#123;</span><br><span class="line">  facingMode: &#123; <span class="attr">exact</span>: <span class="string">"environment"</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="APP权限配置"><a href="#APP权限配置" class="headerlink" title="APP权限配置"></a>APP权限配置</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"permissions": &#123;</span><br><span class="line">  "audio-capture": &#123;</span><br><span class="line">    "description": "Required to capture audio using getUserMedia()"</span><br><span class="line">  &#125;,</span><br><span class="line">  "video-capture": &#123;</span><br><span class="line">    "description": "Required to capture video using getUserMedia()"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作为可能涉及重大隐私问题的API，getUserMedia()规范规定了浏览器有义务满足的各种隐私和安全要求。</strong><br>getUserMedia()是一个强大的功能，只能在安全的环境中使用; 在不安全的情境中，<code>navigator.mediaDevices</code> 是undefined，阻止访问<code>getUserMedia()</code>。<br><strong>简而言之，安全上下文是使用<code>HTTPS</code>或 <code>file:///URL</code> 方案加载的页面，或者是从中加载的页面<code>localhost</code>。</strong></p><h4 id="在旧的浏览器中使用新的API"><a href="#在旧的浏览器中使用新的API" class="headerlink" title="在旧的浏览器中使用新的API"></a>在旧的浏览器中使用新的API</h4><p><strong>推荐使用处理了约束的 <a href="https://github.com/webrtc/adapter">adapter.js</a><code>polyfill</code>  来替代。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象</span></span><br><span class="line"><span class="keyword">let</span> mediaDevices = navigator.mediaDevices</span><br><span class="line"><span class="keyword">if</span> (mediaDevices === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  mediaDevices = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一些浏览器部分支持 mediaDevices。我们不能直接给对象设置 getUserMedia</span></span><br><span class="line"><span class="comment">// 因为这样可能会覆盖已有的属性。这里我们只会在没有getUserMedia属性的时候添加它。</span></span><br><span class="line"><span class="keyword">if</span> (mediaDevices.getUserMedia === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  mediaDevices.getUserMedia = <span class="function"><span class="keyword">function</span>(<span class="params">constraints</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，如果有getUserMedia的话，就获得它</span></span><br><span class="line">    <span class="keyword">var</span> getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些浏览器根本没实现它 - 那么就返回一个error到promise的reject来保持一个统一的接口</span></span><br><span class="line">    <span class="keyword">if</span> (!getUserMedia) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'getUserMedia is not implemented in this browser'</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，为老的navigator.getUserMedia方法包裹一个Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      getUserMedia.call(navigator, constraints, resolve, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">mediaDevices.getUserMedia(&#123; <span class="attr">audio</span>: <span class="literal">true</span>, <span class="attr">video</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line">  <span class="comment">// 旧的浏览器可能没有srcObject</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"srcObject"</span> <span class="keyword">in</span> video) &#123;</span><br><span class="line">    video.srcObject = stream;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 防止在新的浏览器里使用它，应为它已经不再支持了</span></span><br><span class="line">    video.src = <span class="built_in">window</span>.URL.createObjectURL(stream);</span><br><span class="line">  &#125;</span><br><span class="line">  video.onloadedmetadata = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    video.play();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err.name + <span class="string">": "</span> + err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="兼容性-3"><a href="#兼容性-3" class="headerlink" title="兼容性"></a>兼容性</h4><p><img src="/static/img/getUserMedia.png" alt="getUserMedia"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;mediaDevices 是 Navigator 对象的只读属性，一个单列对象，可以连接访问相机和麦克风，屏幕共享
      
    
    </summary>
    
    
      <category term="mediaDevices" scheme="https://owen027.github.io/tags/mediaDevices/"/>
    
  </entry>
  
  <entry>
    <title>Redux 学习</title>
    <link href="https://owen027.github.io/2019/08/04/redux/"/>
    <id>https://owen027.github.io/2019/08/04/redux/</id>
    <published>2019-08-04T04:22:58.000Z</published>
    <updated>2019-09-06T14:33:47.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>Redux 是一个可以预测的JavaScript 状态控制器，专注于状态管理，有store,state, action,reducer 等API（类似 vue 中的 vux）</p></blockquote><p>Redux 可编写构建行为状态一致的应用，可运行在客户端、服务的 和 原生应用 环境中，并且容易测试。 最重要的是，它提供很好的开发体验，编译后的代码可通过devtools实时预览调试。</p><p>Redux 可以和 React 一起使用，也可以和其他视图库（如 <a href="https://cn.vuejs.org/v2/guide/installation.html">Vue</a>）使用。它很小（2K大小 包含依赖 ），并且有一个庞大的插件生态系统。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 npm<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux -S</span><br></pre></td></tr></table></figure></p><p>使用 yarn</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add redux -P</span><br></pre></td></tr></table></figure><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 redux</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ADD_NUM = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> SUB_NUM = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 redecer</span></span><br><span class="line"><span class="keyword">const</span> counter = <span class="function">(<span class="params">state = <span class="number">6</span>,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> ADD_NUM:</span><br><span class="line">            <span class="keyword">return</span> ++state</span><br><span class="line">        <span class="keyword">case</span> SUB_NUM:</span><br><span class="line">            <span class="keyword">return</span> --state</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="comment">// 获取state</span></span><br><span class="line"><span class="keyword">const</span> num = store.getState()</span><br><span class="line"><span class="comment">// 发布信息更改state</span></span><br><span class="line">store.dispatch(&#123;<span class="attr">type</span>:<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅 获取state</span></span><br><span class="line">store.subscrible(lister)  <span class="comment">// 没执行一次dispatch （改变state) 就执行一次 lister 方法</span></span><br><span class="line"><span class="comment">// 设置每次state变化 后的行为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lister</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">&#125;</span><br><span class="line">store.dispatch(&#123;<span class="attr">type</span>:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote><p>更新state中的数据，须通过action（就是一个普通对象） 来更改,这样可清晰的知道应用中发生了什么，数据为什么变动，怎样变动。而核心想法是如何根据这些 action 对象来更新 state。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">type</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#123;<span class="attr">type</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>将state和action结合成函数，这就是reducer。它只接受 state和action 两个参数，并返回新的state函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">console</span>.log(store.getState())<span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然一个应用不单单只有一个reducer,我们可以通过redux来将它们合并。</p><h2 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h2><h3 id="单一数据源-（Single-source-of-truth）"><a href="#单一数据源-（Single-source-of-truth）" class="headerlink" title="单一数据源 （Single source of truth）"></a>单一数据源 （Single source of truth）</h3><blockquote><p>整个应用程序的 state 存储在一个单一 store 的对象树（object tree）中</p></blockquote><p>这样更容易创建创建通用应用，来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。这样单一的 state 树更容易调试和检查。它还能在开发过程中保持应用程序的状态，从而加快开发周期。一些在传统上难以实现的功能（撤销/重做），将其state 存储在树中，从而变得更加简单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="State-是只读的-（State-is-read-only）"><a href="#State-是只读的-（State-is-read-only）" class="headerlink" title="State 是只读的 （State is read-only）"></a>State 是只读的 （State is read-only）</h3><blockquote><p>改变state的唯一方法是触发 action, action是描述发生什么事件的对象</p></blockquote><p>这样确保视图和网络请求不会直接修改state，反而，它们明确表达想要修改的意图。因为所有的变化都被集中处理，且按照严格的顺序一个接一个执行。所以没有细微的竞争条件需要注意。 Action是一个普通对象，所以可以对它们进行打印、序列化、存储，然后后期调试和测试。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="使用纯函数进行更改"><a href="#使用纯函数进行更改" class="headerlink" title="使用纯函数进行更改"></a>使用纯函数进行更改</h3><blockquote><p>要如何通过 action改变指定的state tree ,需要编写 Reducers 函数</p></blockquote><p>Reducer 只是一些纯函数，他接收 state 和 action 两个参数，并且返回新的state ,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers, createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// 创建 redecer</span></span><br><span class="line"><span class="keyword">const</span> counter = <span class="function">(<span class="params">state = <span class="number">6</span>,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> ADD_NUM:</span><br><span class="line">            <span class="keyword">return</span> ++state</span><br><span class="line">        <span class="keyword">case</span> SUB_NUM:</span><br><span class="line">            <span class="keyword">return</span> --state</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter1 = <span class="function">(<span class="params">state = <span class="number">6</span>,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> ADD_NUM:</span><br><span class="line">            <span class="keyword">return</span> ++state</span><br><span class="line">        <span class="keyword">case</span> SUB_NUM:</span><br><span class="line">            <span class="keyword">return</span> --state</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reducers = combineReducers(&#123; counter, counter1 &#125;) <span class="comment">// 通过 combineReducers 合并reducer</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducers)</span><br></pre></td></tr></table></figure></p><h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><blockquote><p>Actions 是将数据从应用程序发送到 store 的有效负载。它们是store 的唯一数据来源，通过 <code>store.dispatch()</code> 传递给 store<br>example:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: ADD_TODO,</span><br><span class="line">  text: <span class="string">'Build my first Redux app'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actions 本质上是普通对象。并且该对象必须有一个<code>type</code> 属性来表示将要执行的动作，通常 <code>type</code> 被定义成字符串常量。当规模变大时，可以存放到单独的文件种管理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ADD_TODO, REMOVE_TODO &#125; <span class="keyword">from</span> <span class="string">'../actionTypes'</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意：使用单独的模块或文件定义 常量<code>type</code>不是必须的，对于小应用来说，使用字符串<code>type</code>方便。而在大型项目种定义常量利大于弊。</p></blockquote><p>出了<code>type</code>属性外其他属性可自行定义，对于规范参考<a href="https://github.com/redux-utilities/flux-standard-action">Flux Standard Action</a></p><h4 id="创建-Action-的生产函数"><a href="#创建-Action-的生产函数" class="headerlink" title="创建 Action 的生产函数"></a>创建 Action 的生产函数</h4><blockquote><p>即生成action 的方法，函数返回一个 action 对象这样更容易被移植和测试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type:ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在<a href="http://facebook.github.io/flux/">传统的Flux</a>实现中调用 action 实现方法时，一般会触发一个<code>dispatch</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> action= &#123;</span><br><span class="line">        type:ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Redux 中只需把action 函数传递给<code>dispatch()</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type:ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.dispatch(addTodo(text))</span><br></pre></td></tr></table></figure></p><h4 id="异步-Action"><a href="#异步-Action" class="headerlink" title="异步 Action"></a>异步 Action</h4><blockquote><p>当调用异步 API时，发送请求和响应（可能超时），都可能会更改 state；因此需要 同步地 <code>dispatch</code> 由<code>reduce</code> 处理的操作<br>通常需要对应三种 action:</p><ul><li>通知 reducer 请求开始的action：reducer 可能会切换state中的 <code>flag</code>,来更改UI状态。</li><li>通知 reducer 请求成功的action：reducer 可能会将接收到的数据合并到 state 中，并更改 <code>flag</code>,控制 UI。</li><li>通知 reducer 请求失败的action：reducer 可能会重置 <code>flag</code>,并将一些失败在UI中信息显示出来</li></ul></blockquote><p>至于<code>flag</code>如何定义完全取决于开发者，使用多个type会降低出错几率。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS_REQUEST'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS_FAILURE'</span>, <span class="attr">error</span>: <span class="string">'Oops'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS_SUCCESS'</span>, <span class="attr">response</span>: &#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意：在实际应用中，网络请求失败时也需要 dispatch action。</strong></p><p>待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Redux 是一个可以预测的JavaScript 状态控制器，专注于状态管理，有store,state, acti
      
    
    </summary>
    
      <category term="React" scheme="https://owen027.github.io/categories/React/"/>
    
    
      <category term="Redux" scheme="https://owen027.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>ReactDOM API</title>
    <link href="https://owen027.github.io/2019/08/02/reactDomAPI/"/>
    <id>https://owen027.github.io/2019/08/02/reactDomAPI/</id>
    <published>2019-08-02T11:15:12.000Z</published>
    <updated>2019-09-06T14:33:47.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-dom"><a href="#react-dom" class="headerlink" title="react-dom"></a>react-dom</h2><ul><li><code>react-dom</code> 的 <code>package</code> 提供了可在应用顶层使用的DOM方法，所有的顶层 API 都可调用</li></ul><p><code>React</code> 支持所有的现代浏览器，IE9及以上版本，但是需要引用相关 <a href="https://zh-hans.reactjs.org/docs/javascript-environment-requirements.html">polyfills</a>,那些在不兼容ES5语法的浏览器中奋斗的同志需要孤军奋战了。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line">ReactDOM.render(element,container[, callback])</span><br></pre></td></tr></table></figure><p>在提供的<code>container</code>里渲染一个 <code>React 元素</code>，并返回该组件的<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">引用</a>, 对于 <a href="https://zh-hans.reactjs.org/docs/components-and-props.html#functional-and-class-components">无状态组件</a>返回 null。<br>如果 <code>React 元素</code> 已经在 <code>container</code>中渲染过，那么将会更新里面的元素，并仅会在必要的时候改变DOM 映射新的 React 元素。<br>callback将在组件被渲染或更新后执行</p><blockquote><p>当首次调用时，container节点中所有DOM元素都会被替换，后续的调用则使用 React 的 DOM diff 算法 进行高效更新。<br><code>rend()</code>不会修改container节点，之后修改子节点，可以在不覆盖现有子节点的情况下，将组件插入已有的DOM节点中。对服务端渲染容器进行 <code>hydrate</code>操作的方式已被废弃，且会在 1<br><code>rend()</code>目前会返回对根组件 <code>ReactComponent</code> 实例的引用。但应该避免使用它，因为历史遗留下来的内容，在未来版本中，组件渲染某些情况下可能会是异步的。对服务端渲染容器进行 <code>hydrate</code>操作的方式已被废弃，且会在 1<br>如果需要根组件 <code>ReactComponent</code> 实例的引用，推荐使用<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">callback ref</a>。<br>使用<code>rend()</code>对服务端渲染容器进行 <code>hydrate</code>操作的方式已被废弃，且会在 17版中被 <a href="https://zh-hans.reactjs.org/docs/react-dom.html#hydrate">hydrate()</a></p></blockquote><h3 id="hydrate"><a href="#hydrate" class="headerlink" title="hydrate()"></a>hydrate()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.hydrate(element,container[, callback])</span><br></pre></td></tr></table></figure><p>此方法和 <code>render()</code>相同，区别在于 <a href="https://zh-hans.reactjs.org/docs/react-dom-server.html">ReactDOMServer</a> 渲染的容器中对HTML的内容进行 <code>hydrate</code> 操作。React 会尝试在已有的标记上绑定事件监听器。</p><h3 id="unmountComponentAtNode"><a href="#unmountComponentAtNode" class="headerlink" title="unmountComponentAtNode()"></a>unmountComponentAtNode()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.unmountComponentAtNode(container)</span><br></pre></td></tr></table></figure><p>此方法将卸载 DOM 中的组件，会将事件处理器和 state 一并清除。如果指定的 container 中没有对应已挂在的组件，那么此方法什么也不会做，如果组件被移除将会返回 true，如果未移除将返回false</p><h3 id="findDOMNode"><a href="#findDOMNode" class="headerlink" title="findDOMNode()"></a>findDOMNode()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.findDOMNode(component)</span><br></pre></td></tr></table></figure><p>如果组件已被挂载到DOM上，此方法会返回浏览器中x相应的原生DOM，不能用于函数组件，对于在未挂载的组件中调用将发生异常。对于读取DOM中的值很有用，一般<strong>推荐使用 <code>ref</code>来获取DOM元素</strong></p><p><strong>此方法是访问底层DOM节点的应急方案，严格模式中被弃用</strong></p><h3 id="createPortal"><a href="#createPortal" class="headerlink" title="createPortal()"></a>createPortal()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.createPortal(child,container)</span><br></pre></td></tr></table></figure><p>创建<a href="https://zh-hans.reactjs.org/docs/portals.html">portal</a>，它提供一种将子节点渲染到DOM节点中的方式，该节点存在于DOM组件的乘此结构之外。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react-dom&quot;&gt;&lt;a href=&quot;#react-dom&quot; class=&quot;headerlink&quot; title=&quot;react-dom&quot;&gt;&lt;/a&gt;react-dom&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;react-dom&lt;/code&gt; 的 &lt;code&gt;packa
      
    
    </summary>
    
      <category term="React" scheme="https://owen027.github.io/categories/React/"/>
    
    
      <category term="ReactDOM API" scheme="https://owen027.github.io/tags/ReactDOM-API/"/>
    
  </entry>
  
  <entry>
    <title>React API</title>
    <link href="https://owen027.github.io/2019/07/31/reactAPI/"/>
    <id>https://owen027.github.io/2019/07/31/reactAPI/</id>
    <published>2019-07-31T09:44:31.000Z</published>
    <updated>2019-09-06T14:33:47.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement()"></a>createElement()</h2><blockquote><p>创基并返回指定类型的 <a href="https://zh-hans.reactjs.org/docs/rendering-elements.html">React元素</a>。其中类型参数既可以是DOM标签字符串，也可以是<a href="https://zh-hans.reactjs.org/docs/components-and-props.html">React组件类型</a>,或是<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactfragment">React fragment</a>类型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(type,[props],[...children])</span><br></pre></td></tr></table></figure><p> JSX 编写的代码将会被转换成使用 React.createElement() 的形式。</p><h2 id="cloneElement"><a href="#cloneElement" class="headerlink" title="cloneElement()"></a>cloneElement()</h2><blockquote><p>以 element 元素为样板克隆并返回新的React元素，返回元素的props将新的props与原始的prosp浅合并。新的子元素取代现有的子元素，原始元素的 key 和 ref 将被保留</p></blockquote><p>通过 ref 获取子节点时，将不会意外地从祖先节点上窃取它。相同的 ref 将添加到克隆后的新元素中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.cloneElement(element,[props],[...children])</span><br></pre></td></tr></table></figure></p><h2 id="isValidElement"><a href="#isValidElement" class="headerlink" title="isValidElement()"></a>isValidElement()</h2><blockquote><p>验证对象是否为React元素，返回值为 true or false</p></blockquote><h2 id="React-children"><a href="#React-children" class="headerlink" title="React.children"></a>React.children</h2><blockquote><p>提供用于处理 <code>this.props.children</code> 不透明数据结构的方用方法。</p></blockquote><h3 id="React-Children-map"><a href="#React-Children-map" class="headerlink" title="React.Children.map"></a>React.Children.map</h3><ul><li>在每个直接子节点上调用一个函数，并将 <code>this</code>(执行期上下文) 设置为 <code>thisArg</code>。</li><li>如果<code>Children</code> 是一个数值，它将被遍历并为数组中的每个子节点调用该函数。</li><li>如果子节点为<code>null</code> 或 <code>undefined</code>,则返回对应的 null 或 undefined。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">React.Children.map(children,function[(thisArg)])</span><br></pre></td></tr></table></figure><p><strong>如果children 是一个Frgment对象，它将被视为单一子节点的情况处理，不被遍历</strong></p><h3 id="React-Children-forEach"><a href="#React-Children-forEach" class="headerlink" title="React.Children.forEach"></a>React.Children.forEach</h3><blockquote><p>和 <code>React.Children.map</code> 类似，但是不会返回数组<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">React.Children.forEach(children,function[(thisArg)] )</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="React-Children-count"><a href="#React-Children-count" class="headerlink" title="React.Children.count"></a>React.Children.count</h3><blockquote><p>返回 children 中组件总数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">React.Children.count(children)</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="React-Children-only"><a href="#React-Children-only" class="headerlink" title="React.Children.only"></a>React.Children.only</h3><blockquote><p>验证children是否只有一个React元素，有则返回它，无则抛出错误</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">React.Children.only(children)</span><br></pre></td></tr></table></figure><p>**此方法不接受<code>React.Children.map</code>的返回值，因为它是一个数组</p><h3 id="React-Children-toArray"><a href="#React-Children-toArray" class="headerlink" title="React.Children.toArray"></a>React.Children.toArray</h3><blockquote><p>将children 这个复杂的数据结构以数组的形式扁平展开并返回，且为每个子节点分配一个key.想要在渲染函数中操作子节点的集合时，非常实用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">React.Children.toArray(children)</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>注意：此方法在拉平展开节点列表时，更改key值以保留嵌套数组的语言。即 toArray 会为返回数组中的每个key添加前缀，使每个元素key的范围都限定在此函数入参数组的对象内</strong></p><h2 id="React-Fragment"><a href="#React-Fragment" class="headerlink" title="React.Fragment"></a>React.Fragment</h2><blockquote><p><code>React.Fragment</code> 能在不额外创建DOM元素情况下，让 render方法返回多个元素</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">          &lt;ChildA /&gt;</span><br><span class="line">          &lt;ChildB /&gt;</span><br><span class="line">          &lt;ChildC /&gt;</span><br><span class="line">        &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 简写</span></span><br><span class="line"><span class="regexp">render()&#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ChildA /</span>&gt;</span><br><span class="line">          &lt;ChildB /&gt;</span><br><span class="line">          &lt;ChildC /&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://zh-hans.reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html">更多信息</a></p><h2 id="React-createRef"><a href="#React-createRef" class="headerlink" title="React.createRef"></a>React.createRef</h2><blockquote><p>创建一个能通过 ref 属性附加到 React元素的 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">ref</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Componet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">this</span>.inputRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    reder()&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;input type="text" ref= &#123;this.inputRef&#125; /&gt;；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        this.inputRef.current.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-forwardRef"><a href="#React-forwardRef" class="headerlink" title="React.forwardRef"></a>React.forwardRef</h2><blockquote><p><code>React.forwardRef</code> 会创建一个React组件，能将其接受的<code>ref</code> 属性转发到其组件树下的另一个组件中。</p><ul><li><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components">转发refs到DOM组件</a></li><li><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components">在高阶组件中转发 refs</a></li></ul></blockquote><p><strong><code>React.forwardRef</code>接受渲染函数作为参数。使用props和ref z作为参数调用此函数，返回 React节点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = React.forwardRef(<span class="function">(<span class="params">props,ref</span>)=&gt;</span> ( &lt;button ref=&#123;ref&#125; className="FancyButton"&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;/button&gt;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can now get a ref directly to the DOM button:</span></span><br><span class="line"><span class="keyword">const</span> ref = React.createRef();</span><br><span class="line">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure><h2 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy"></a>React.lazy</h2><blockquote><p>React.lazy()允许你定义一个动态加载组件。有助于减少 bundle的体积，并提高首屏加载效率</p></blockquote><p><strong>此特性需要支持 <code>promise</code></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'./component'</span>)) <span class="comment">// 动态加载</span></span><br></pre></td></tr></table></figure></p><p><a href="https://zh-hans.reactjs.org/docs/code-splitting.html#reactlazy">参考文章</a></p><h2 id="React-Suspense"><a href="#React-Suspense" class="headerlink" title="React.Suspense"></a>React.Suspense</h2><blockquote><p>React.Suspense 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。目前，懒加载组件是 &lt;React.Suspense&gt; 支持的唯一用例：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该组件是动态加载的</span></span><br><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 显示 &lt;Spinner&gt; 组件直至 OtherComponent 加载完成</span></span><br><span class="line">    &lt;React.Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;OtherComponent /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>React.Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>lazy</code> 组件可以位于 <code>Suspense</code> 组件树的深处——它不必包装树中的每一个延迟加载组件。最佳实践是将 <code>&lt;Suspense&gt;</code> 置于你想展示加载指示器（loading indicator）的位置，而 <code>lazy()</code> 则可被放置于任何你想要做代码分割的地方。</p><p>虽然目前尚未支持其它特性，但未来我们计划让 Suspense 支持包括数据获取在内的更多场景。可以在<a href="https://zh-hans.reactjs.org/blog/2018/11/27/react-16-roadmap.html">roadmap</a> 中了解相关信息。</p><p><strong><code>React.lazy()</code> 和 <code>&lt;React.Suspense&gt;</code> 尚未在 <code>ReactDOMServer</code> 中支持。这是已知问题，将会在未来解决。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;createElement&quot;&gt;&lt;a href=&quot;#createElement&quot; class=&quot;headerlink&quot; title=&quot;createElement()&quot;&gt;&lt;/a&gt;createElement()&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;创基并返回指定类型
      
    
    </summary>
    
      <category term="React" scheme="https://owen027.github.io/categories/React/"/>
    
    
      <category term="React API" scheme="https://owen027.github.io/tags/React-API/"/>
    
  </entry>
  
  <entry>
    <title>React 生命周期函数</title>
    <link href="https://owen027.github.io/2019/07/29/reactLifeCycle/"/>
    <id>https://owen027.github.io/2019/07/29/reactLifeCycle/</id>
    <published>2019-07-29T15:39:45.000Z</published>
    <updated>2019-07-31T14:27:01.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件生命周期函数"><a href="#组件生命周期函数" class="headerlink" title="组件生命周期函数"></a>组件生命周期函数</h2><blockquote><p>React 主动调用的方法，也可重写这些方法</p></blockquote><p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">生命周期图谱</a></p><h3 id="当组件实例被创建并插入-DOM-中时，其生命周期调用顺序如下："><a href="#当组件实例被创建并插入-DOM-中时，其生命周期调用顺序如下：" class="headerlink" title="当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下："></a>当组件实例被创建并插入 <code>DOM</code> 中时，其生命周期调用顺序如下：</h3><h4 id="constructor-props"><a href="#constructor-props" class="headerlink" title="constructor(props)"></a>constructor(props)</h4><blockquote><p>如果不需要初始化 state 或 不进行方法绑定，则不需要使用该方法</p></blockquote><p>在组件挂载之前会先调用该方法，在实现构造函数时必须先调用<code>super(props)</code>方法，否则会出现BUG<br><strong>通常，构造函数仅用于两种情况：1. 初始化 <code>state</code> 2. 为事件处理函数绑定实例</strong><br><strong>在该方法中不要使用 <code>setState()</code> 方法,在其他方法中使用<code>setState()</code>改变 state</strong><br><a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">为什么 props 复制给 state 会产生 bug</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="comment">// 不要在这里调用 this.setState()</span></span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    counter: <span class="number">0</span>,</span><br><span class="line">    name:props.name <span class="comment">// 严禁这样赋值，props.name值更新时 state.name并不会更新</span></span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="static-getDerivedStateFromProps-（此方法不常用）"><a href="#static-getDerivedStateFromProps-（此方法不常用）" class="headerlink" title="static getDerivedStateFromProps() （此方法不常用）"></a>static getDerivedStateFromProps() （此方法不常用）</h4><blockquote><p>此方法会在 <code>render</code> 方法之前调用，并且初始化和数据更新时都会调用，它返回一个对象更新 state，如果返回null 则不更新任何内容。</p></blockquote><p>此方法适用于 state 值在任何时候都取决于props 的情况。</p><h4 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h4><blockquote><p>render 是 class 组件必须实现的方法</p></blockquote><p>当该方法被调用时，它会监测 props 和 state 的变化，并且返回以下类型之一：</p><ul><li><code>React 元素</code>：通过JSX创建，渲染成对应的DOM节点或自定义组件</li><li><strong>数组或fragments：</strong> 使render方法可以返回多个元素 <a href="https://zh-hans.reactjs.org/docs/fragments.html">frgments</a></li><li><code>Portals</code>：可以渲染子节点到不同的DOM子树汇中<a href="https://zh-hans.reactjs.org/docs/portals.html">portals</a></li><li><strong>字符串或数值类型：</strong> 在DOM中会被渲染为文本节点、</li><li><code>Boolean 或 null</code>：什么都不渲染</li></ul><p><strong>render方法最好为纯函数，即在不修改组件 <code>state</code>情况下，每次调用时都返回相同的结果，并且不会直接与浏览器交互</strong></p><blockquote><p>如果要和浏览器交互，可以在其他生命周期函数中执行，<strong>注意：<code>shoouldComponentUpdate</code>方法中返回false,将不会调用render方法</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="title">extemds</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">render()&#123; <span class="comment">// 不会执行</span></span><br><span class="line">  &lt;div&gt;owen&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="componentDIdMount"><a href="#componentDIdMount" class="headerlink" title="componentDIdMount()"></a>componentDIdMount()</h4><blockquote><p>此方法会在组件挂载后（插入DOM树中）调用，初始化的数据的好地方</p></blockquote><h3 id="组件的-props-或-state-发生变化会触发更新。组件更新的生命周期调用顺序如下："><a href="#组件的-props-或-state-发生变化会触发更新。组件更新的生命周期调用顺序如下：" class="headerlink" title="组件的 props 或 state 发生变化会触发更新。组件更新的生命周期调用顺序如下："></a>组件的 <code>props</code> 或 <code>state</code> 发生变化会触发更新。组件更新的生命周期调用顺序如下：</h3><h4 id="static-getDerivedStateFromProps-（此方法不常用）-已解释"><a href="#static-getDerivedStateFromProps-（此方法不常用）-已解释" class="headerlink" title="static getDerivedStateFromProps() （此方法不常用）(已解释)"></a>static getDerivedStateFromProps() （此方法不常用）(已解释)</h4><h4 id="shouldComponentUpdate-nextProps-nextState-（此方法不常用）"><a href="#shouldComponentUpdate-nextProps-nextState-（此方法不常用）" class="headerlink" title="shouldComponentUpdate(nextProps, nextState) （此方法不常用）"></a>shouldComponentUpdate(nextProps, nextState) （此方法不常用）</h4><blockquote><p>当state 或 props 变化时该方法会在渲染执行前调用默认返回值为true,首次加载不会被调用</p></blockquote><p><strong>根据该方法的返回值判断组件输出是否受当前 state 或 props 更改的影响。默认为 state 每次更新重新渲染</strong></p><p>此方法进仅做为性能优化的方式存在，不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</p><h4 id="render-已解释"><a href="#render-已解释" class="headerlink" title="render()(已解释)"></a>render()(已解释)</h4><h4 id="getSnapshotBeforeUpdate-（此方法不常用）"><a href="#getSnapshotBeforeUpdate-（此方法不常用）" class="headerlink" title="getSnapshotBeforeUpdate() （此方法不常用）"></a>getSnapshotBeforeUpdate() （此方法不常用）</h4><blockquote><p>此方法在最近一次渲染输出（提交到DOM节点）之前调用。使组件能在发送更改前从DOM中捕获一些信息（如 位置）。此生命周期的返回值将作为参数传递给 <code>componentDidUpdate()</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// 我们是否在 list 中添加新的 items ？</span></span><br><span class="line">    <span class="comment">// 捕获滚动​​位置以便我们稍后调整滚动位置。</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="comment">// 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span></span><br><span class="line">    <span class="comment">// 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span></span><br><span class="line">    <span class="comment">//（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>上述示例中，重点是从 getSnapshotBeforeUpdate 读取 scrollHeight 属性，因为 “render” 阶段生命周期（如 render）和 “commit” 阶段生命周期（如 getSnapshotBeforeUpdate 和 componentDidUpdate）之间可能存在延迟。</p><h4 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h4><blockquote><p>此方法会在数据更新后立即调用，首次加载不会被调用,在此方法中使用 <strong><code>setState</code>必须将它放到条件语句中</strong>，否则会导致死循环。还会导致额外的重新渲染，影响性能</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps) &#123;</span><br><span class="line">  <span class="comment">// 典型用法（不要忘记比较 props）：</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.userID !== prevProps.userID) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fetchData(<span class="keyword">this</span>.props.userID);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：如果 shouldComponentUpdate() 返回值为 false，则不会调用 componentDidUpdate()。</strong></p><h3 id="当组件从-DOM-中移除时会调用如下方法："><a href="#当组件从-DOM-中移除时会调用如下方法：" class="headerlink" title="当组件从 DOM 中移除时会调用如下方法："></a>当组件从 <code>DOM</code> 中移除时会调用如下方法：</h3><h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h4><blockquote><p>此方法会在组件卸载销毁前调用，可以执行必要的清理操作，如 定时器，取消网络请求，或清除componentDidMount() 中创建的订阅等。</p></blockquote><h3 id="当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法："><a href="#当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：" class="headerlink" title="当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法："></a>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</h3><p><strong>Error boundaries</strong>：捕获渲染期间及整个树的函数发送的错误，渲染降级 UI，但自身的错误无法捕获 <a href="https://zh-hans.reactjs.org/blog/2017/07/26/error-handling-in-react-16.html">React 16中的错误处理</a></p><h4 id="static-getDerivedStateFromError-error-（此方法不常用）"><a href="#static-getDerivedStateFromError-error-（此方法不常用）" class="headerlink" title="static getDerivedStateFromError(error) （此方法不常用）"></a>static getDerivedStateFromError(error) （此方法不常用）</h4><blockquote><p>次生命周期会在后代组件抛出错误后调用，将错误作为参数，返回一个值更新state，在渲染期间不允许出现副作用，建议使用 componentDidCatch()</p></blockquote><h4 id="componentDidCatch-error-info-（此方法不常用）"><a href="#componentDidCatch-error-info-（此方法不常用）" class="headerlink" title="componentDidCatch(error, info) （此方法不常用）"></a>componentDidCatch(error, info) （此方法不常用）</h4><blockquote><p>此方法在后代组件抛出错误后被调用</p></blockquote><p>如果发生错误，可以通过调用 <code>setState</code> 使用 <code>componentDidCatch()</code> 渲染降级 UI，但在未来的版本中将不推荐这样做。 可以使用静态 <code>getDerivedStateFromError()</code> 来处理降级渲染。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染可以显降级 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// "组件堆栈" 例子:</span></span><br><span class="line">    <span class="comment">//   in ComponentThatThrows (created by App)</span></span><br><span class="line">    <span class="comment">//   in ErrorBoundary (created by App)</span></span><br><span class="line">    <span class="comment">//   in div (created by App)</span></span><br><span class="line">    <span class="comment">//   in App</span></span><br><span class="line">    logComponentStackToMyService(info.componentStack);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 你可以渲染任何自定义的降级  UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value:<span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="comment">// 实例化组件之后以及在重新呈现组件之前调用新的静态生命周期。它可以返回要更新的对象state，或null指示新对象props不需要任何state更新。</span></span><br><span class="line">  &#125;</span><br><span class="line">   componentDidMount() &#123; <span class="comment">// 组件被渲染到 DOM 中后运行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'DidMount: 1'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate()&#123;</span><br><span class="line">    <span class="comment">// 更新前</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate()&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="comment">// 更新后</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError() &#123;</span><br><span class="line">      <span class="comment">// 出错时</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentDidCatch()&#123;</span><br><span class="line">    <span class="comment">// capture error</span></span><br><span class="line">  &#125;</span><br><span class="line">  compoentwillUnmount()&#123; <span class="comment">// 组件被删除的时候</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'UnMount: end'</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=<span class="string">"square"</span> onClick = &#123;()=&gt;&#123;<span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="string">'X'</span>&#125;)&#125;</span><br><span class="line">      &#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><a href="https://zh-hans.reactjs.org/docs/react-component.html">参考资料</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组件生命周期函数&quot;&gt;&lt;a href=&quot;#组件生命周期函数&quot; class=&quot;headerlink&quot; title=&quot;组件生命周期函数&quot;&gt;&lt;/a&gt;组件生命周期函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;React 主动调用的方法，也可重写这些方法&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
      <category term="React" scheme="https://owen027.github.io/categories/React/"/>
    
    
      <category term="React life cycle" scheme="https://owen027.github.io/tags/React-life-cycle/"/>
    
  </entry>
  
  <entry>
    <title>React.Component API</title>
    <link href="https://owen027.github.io/2019/07/29/react.Component/"/>
    <id>https://owen027.github.io/2019/07/29/react.Component/</id>
    <published>2019-07-29T14:42:29.000Z</published>
    <updated>2019-07-31T14:27:01.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Component"><a href="#React-Component" class="headerlink" title="React.Component"></a>React.Component</h2><blockquote><p>使用ES6 classes 方式定义React组件的基类<br><strong>最好不要建立自己的组件基类，因为，在React组件中，代码重用的主要方式是组合而不是继承</strong></p></blockquote><h3 id="setState-updater-callback"><a href="#setState-updater-callback" class="headerlink" title="setState(updater[, callback])"></a>setState(updater[, callback])</h3><blockquote><p>用于更新用户界面以响应事件处理器和处理服务器数据的主要方法</p></blockquote><p>此方法不会总数立即更新组件，他会批量推迟更新，如果需要使用<code>setState</code> 后立即读取 <code>state</code>可能会是旧值。<br>使用 <code>componentDidMount</code> 方法或使用 <code>setState</code>的回调函数可解决旧值问题。<br>注意 <strong>shouldComponentUpdate 方法返回false，将不会重新渲染页面</strong></p><h4 id="参数一-updater函数-或者对象"><a href="#参数一-updater函数-或者对象" class="headerlink" title="参数一 updater函数 或者对象"></a>参数一 updater函数 或者对象</h4><blockquote><p>带有连个形参的函数 或者一个对象类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// updater function</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state,props</span>)=&gt;</span>(&#123;<span class="attr">name</span>:state.name+props.name&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// object type</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>:<span class="keyword">this</span>.state.name&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><p>updater 函数中 <code>state</code> 是对应组件 <code>state</code> 的引用，它不应直接被修改；须返回一个对象，会与state进行浅合并</p><p>object 类型中 <code>setState</code> 也是异步的，并在<strong>同一周期</strong>内对多个 <code>setState</code> 进行处理,如果后续状态取决于当前状态，建议使用 updater 函数的形式代替。<br><strong>example：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">  previousState,</span><br><span class="line">  &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;,</span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><a href="https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973">深入学习：何时以及为什么 setState() 会批量执行？</a><br><a href="https://github.com/facebook/react/issues/11527#issuecomment-360199710">深入：为什么不直接更新 this.state？</a></p><p><code>setState</code>的第二个参数为可选的回调函数，它将在<code>setState</code> 完成合并并重新渲染组件后执行，通常建议使用<code>componentDidMount</code>方法代替。</p><h3 id="forceUpdate-callback"><a href="#forceUpdate-callback" class="headerlink" title="forceUpdate(callback)"></a>forceUpdate(callback)</h3><blockquote><p>默认情况下，组件数据发生变化就会重新渲染，如果 render 方法依赖其他数据，可以使用 <code>forceUpdate</code> 强制让组件刷新</p></blockquote><p><strong>此方法会跳过 <code>shouldComponentUpdate</code>方法。但是子组件会正常触发。通常应该避免使用forceUpdate方法，尽量在render方法中使用 state 和 props。</strong></p><h3 id="Class属性"><a href="#Class属性" class="headerlink" title="Class属性"></a>Class属性</h3><h4 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h4><p>此属性可以给对应的组件添加 props,通常用于 prop未赋值且不能为null。<br><strong>example：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"> render()&#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;h3&gt;&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">            &lt;main&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Text text ='null'/</span>&gt; <span class="comment">// props.text 将是 null</span></span><br><span class="line">            &lt;<span class="regexp">/main&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">Example.defaultProps = &#123;</span><br><span class="line">  name:<span class="string">'Owen'</span>,</span><br><span class="line">  text:<span class="string">'Owen is a programmer '</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><h4 id="props-类似-vue中的-props"><a href="#props-类似-vue中的-props" class="headerlink" title="props 类似 vue中的 props"></a>props 类似 vue中的 props</h4><p><code>this.props</code> 包括被该组件调用者定义的 props。其中<code>this.props.children</code> 是一个特殊的 prop，通常由 JSX 表达式中的子组件组成，而非组件本身定义。</p><h4 id="state-类似-vue-中的data"><a href="#state-类似-vue-中的data" class="headerlink" title="state 类似 vue 中的data"></a>state 类似 vue 中的data</h4><p>组件中 state 包含随时可能发生变化的数据。由用户自定义，是一个普通的对象，<strong>永远不要直接改变 this.state，因为后续调用的 setState() 可能会替换掉你的改变。请把 this.state 看作是不可变的。</strong></p><h2 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a>React.PureComponent</h2><blockquote><p>React.PureComponent 与 React.Component 相似二者区别于 <code>shouldComponentUpdate</code>的实现</p><ul><li>React.Component 并未实现 <code>shouldComponentUpdate</code>方法</li><li>React.PureComponent 中以层对比 prop 和state 的方式实现<code>shouldComponentUpdate</code>方法</li></ul></blockquote><p>在某些情况下使用<code>React.PureComponent</code>可提高性能<br><strong>注意：如果对象中包含赋值的数据结构，可能因无法监测深层次的差别，产生错误的对比结果。所以仅在props和state较为简单时使用<code>React.PureComponent</code>。此外，<code>shouldComponentUpdate</code>方法会跳过所以子组件树的prop 更新</strong></p><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><blockquote><p><code>React.memo</code> 是高级函数组件，它与 React.pureComponent 相似，但不支持class组件。此方法仅做为<a href="https://zh-hans.reactjs.org/docs/optimizing-performance.html">性能优化</a>的方式存在<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyMemo = <span class="function">(<span class="params">props</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;li&gt;/* ... */&lt;/li&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> MemoComponent = React.memo(MyMemo)</span><br></pre></td></tr></table></figure></p></blockquote><p>如果函数组件在给定相同的 props 情况下渲染结果相同，就可将其保证在 <code>React.memo</code>中调用，这样就可通过记忆组件渲染结果的方式来提高组件的性能，意味着React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p><p><strong>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(MyComponent, areEqual);</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><a href="https://zh-hans.reactjs.org/docs/react-component.html#setstate">参考资料</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-Component&quot;&gt;&lt;a href=&quot;#React-Component&quot; class=&quot;headerlink&quot; title=&quot;React.Component&quot;&gt;&lt;/a&gt;React.Component&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用ES6
      
    
    </summary>
    
      <category term="React" scheme="https://owen027.github.io/categories/React/"/>
    
    
      <category term="React API" scheme="https://owen027.github.io/tags/React-API/"/>
    
  </entry>
  
  <entry>
    <title>React 基础学习</title>
    <link href="https://owen027.github.io/2019/07/23/react/"/>
    <id>https://owen027.github.io/2019/07/23/react/</id>
    <published>2019-07-23T12:35:20.000Z</published>
    <updated>2019-07-29T15:43:17.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><blockquote><p><code>React</code> 是一个声明式，高效且灵活的用于构建用户界面的 <code>JavaScript</code>库。可以将一些简短、独立的代码片段组合成复杂的UI界面，这些片段被称为“组件”。</p></blockquote><p><strong>React 大体包含下面这些概念：</strong></p><ul><li>组件</li><li>JSX</li><li>Virtual DOM</li><li>Data Flow</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote><p> 可以将UI 拆分为独立且复用的代码片段，每部分都可独立维护。<br>组件，从概念上类似于 <code>JavaScript</code> 函数。它接受任意的参数（即 “props”），并返回用于描述页面展示内容的<code>React 元素</code>。<br><strong>自定义组件命名：必须以大写字母开头，React 会将以小写字母开头的组件视为原生DOM标签。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>; <span class="comment">// React 的核心库</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>; <span class="comment">// 提供与 DOM 相关的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"shopping-list"</span>&gt;</span><br><span class="line">        &lt;h1&gt;Shopping List <span class="keyword">for</span> &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;Instagram&lt;/</span>li&gt;</span><br><span class="line">          &lt;li&gt;WhatsApp&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;Oculus&lt;/</span>li&gt;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ShoppingList name=<span class="string">"Mark"</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p></blockquote><p>React 应用都是构建在组件之上。<code>ShoppingList</code>就是一个React 组件类型，<code>ReactDOM.render</code> 函数会将组件方到页面上的某个节点元素中。(<code>render</code> 返回了一个 <code>React 元素</code> ，这是一种对渲染内容的轻量级描述。)<br><strong>大多数 <code>React</code>应用只会调用一次 <code>ReactDOM.render()</code>。</strong></p><p><strong>其中<code>props</code>（是 properties 的简写） 是组件包含的两个核心概念之一，另一个是<code>state</code>。</strong></p><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p><code>props</code>接收一些其他组件的参数（比如上方的 name )，来配置组件，<strong>所有 <code>React</code> 组件都必须像纯函数一样保护它们的 <code>props</code> 不被更改</strong>。</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><code>state</code> 来实现所谓“记忆”的功能。可以通过 <code>React</code> 组件的构造函数中设置 <code>this.state</code>;<code>this.state</code> 应该被视为一个组件的私有属性。<br><strong>修改<code>this.state</code>值需要通过<code>this.setState</code>方法赋值,有些 <code>props</code> 值或 <code>state</code> 值可能是异步更新的，使用对象赋值的方式更改 <code>state</code> 可能无效，可使用回调传参方式更新</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(  <span class="function">(<span class="params">state,props</span>)=&gt;</span> (&#123;<span class="attr">count</span>:state.count + props.count&#125;) );</span><br></pre></td></tr></table></figure></p><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><blockquote><p>通过 <code>class</code> 语法来定义组件，必须包含<code>render()</code> 方法,并且继承于 <code>React.Component</code>。<br><strong>类组件必须包含<code>render()</code>，并且return 只能返回一个父元素（类似vue中的template中必须要有一个父元素）。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @name constructor</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; props</span></span><br><span class="line"><span class="comment">   * 每次定义子类的构造函数时，都必须调用 super 方法。</span></span><br><span class="line"><span class="comment">   * 因此，在所有含有构造函数的React组件中，构造函数必须以super(props)开头</span></span><br><span class="line"><span class="comment">   * state 保存着组件中的数据 类似 vue 中的 data 属性</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value:<span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=<span class="string">"square"</span> onClick = &#123;()=&gt;&#123;<span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="string">'X'</span>&#125;)&#125;</span><br><span class="line">      &#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>render方法中的<code>onClick</code> 事件监听函数中调用<code>this.setState</code>方法，可以设置<code>this.state</code> 中的属性<br>推荐使用箭头函数，避免<a href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">this 造成困扰</a>。</p><h3 id="简单组件-函数组件"><a href="#简单组件-函数组件" class="headerlink" title="简单组件(函数组件)"></a>简单组件(函数组件)</h3><p>简单组件是一个函数，不需要使用<code>class</code>关键字，当然就没有<code>constructor和state</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Square =  <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span>  (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>= <span class="string">"square"</span></span></span></span><br><span class="line"><span class="xml">   onClick= &#123; props.onClick&#125; &gt;&#123; props.value  &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p><code>input</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code> 等表单的状态发生改变，都得同时通过<code>onChange</code>事件改变组件中的<code>state</code>值，否则表单不会发生变化。通过这种方式控制取值的表单叫做<code>受控组件</code>。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value:<span class="string">'3s'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render ()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span> = <span class="string">&#123;this.state.value&#125;</span> /&gt;</span>   // 用户在表单中输入任何信息都是无效的</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 使用事件来改变</span></span><br><span class="line"><span class="xml"> render ()&#123;</span></span><br><span class="line"><span class="xml">    return (</span></span><br><span class="line">      &lt;input</span><br><span class="line">          type="text"</span><br><span class="line">          value = &#123;this.state.value&#125;</span><br><span class="line">          onChange = &#123;(&#123;target&#125;) =&gt;&#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">              value:target.value</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><strong>React受控组件更新state的流程:</strong></p><ul><li>通过在初始化state中设置表单默认值；</li><li>每当表单值发生变化时，调用<code>onChange</code>事件</li><li>事件通过合成的事件对象来改变状态更新 <code>state</code></li><li>setState触发视图渲染更新，完成表单组件值的更新</li></ul><h3 id="渲染多个组件"><a href="#渲染多个组件" class="headerlink" title="渲染多个组件"></a>渲染多个组件</h3><p>将组件变成数组集合放入花括号中即可渲染多个组件,通常使用数组的<code>map()</code>方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Lis = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> lis = props.list.map(<span class="function">(<span class="params">val,key</span>)=&gt;</span> &lt;li key=&#123;key&#125;&gt;&#123;key+<span class="number">1</span>&#125;&lt;<span class="regexp">/li&gt;);</span></span><br><span class="line"><span class="regexp">    return &lt;ul&gt;&#123;lis&#125;&lt;/u</span>l&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> list = <span class="built_in">Array</span>(<span class="number">7</span>).fill(<span class="literal">null</span>);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Lis list = &#123;list&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><p>当多个组件发生数据联动时，建议将共享状态提升到最近的共同父组件中去。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Owen</span></span><br><span class="line"><span class="comment"> * @Date: 2019-07-23 23:55:17</span></span><br><span class="line"><span class="comment"> * @Last Modified by: Owen</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2019-07-29 16:06:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 温度转化器</span></span><br><span class="line"><span class="keyword">let</span> toConvert = <span class="function">(<span class="params">temperature,callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(temperature);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Number</span>.isNaN(num)) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">   num = callback(num)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round(num*<span class="number">1000</span>)/<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoilingVerdict = <span class="function">(<span class="params">props</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> text = props.temperature &gt; <span class="number">100</span>?<span class="string">''</span>:<span class="string">' not'</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    The water would&#123;text&#125; boil.</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共input组件只接收行为和状态</span></span><br><span class="line"><span class="keyword">const</span> TemperatureInput = <span class="function">(<span class="params">props</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;input</span><br><span class="line">    value =&#123;props.temperature&#125;</span><br><span class="line">    onChange = &#123;props.valueChange&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件设置行为和状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      temperature:<span class="string">''</span>,</span><br><span class="line">      scale:<span class="string">'C'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toFahrenheit(&#123;target&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      temperature:target.value,</span><br><span class="line">      scale:<span class="string">'F'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  toCelsius(&#123;target&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      temperature:target.value,</span><br><span class="line">      scale:<span class="string">'C'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;temperature,scale&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">let</span> celsius = scale === <span class="string">'F'</span>?toConvert(temperature,(val)=&gt;(val - <span class="number">32</span>)*<span class="number">5</span>/<span class="number">9</span>):temperature;</span><br><span class="line">    <span class="keyword">let</span> fahrenheit = scale === <span class="string">'C'</span>?toConvert(temperature,(val)=&gt;val*<span class="number">9</span>/<span class="number">5</span>+<span class="number">32</span>):temperature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          Celsius：</span><br><span class="line">          &lt;TemperatureInput</span><br><span class="line">          scale =<span class="string">'C'</span></span><br><span class="line">          temperature = &#123;celsius&#125;</span><br><span class="line">          valueChange = &#123;<span class="keyword">this</span>.toCelsius.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          Fahrenheit：</span></span><br><span class="line"><span class="regexp">          &lt;TemperatureInput</span></span><br><span class="line"><span class="regexp">          scale ='F'</span></span><br><span class="line"><span class="regexp">          temperature = &#123;fahrenheit&#125;</span></span><br><span class="line"><span class="regexp">          valueChange = &#123;this.toFahrenheit.bind(this)&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&lt;BoilingVerdict temperature = &#123;this.state.temperature&#125; /</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">render(&lt;Calculator /</span>&gt;,<span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>))</span><br></pre></td></tr></table></figure></p><p>在就<code>React</code> 应用中，任何科比数据应当只有一个相对应的数据源，通常，多个组件需要相同数据，可以将数据提升到这些组件的共同父组件中。依靠自上而下的数据流，去控制组件，而不是尝试在不同组件同步 <code>state</code>。<strong>这样会减少将来排查和隔离BUG所需要的工作量</strong></p><h3 id="组合（类似vue中的-slot）"><a href="#组合（类似vue中的-slot）" class="headerlink" title="组合（类似vue中的 slot）"></a>组合（类似vue中的 slot）</h3><p>有些组件无法提前知晓它们子组件的具体内容，需要留坑，那么也可以通过 <code>props</code>来占位。</p><h4 id="默认坑位props-children"><a href="#默认坑位props-children" class="headerlink" title="默认坑位props.children"></a>默认坑位<code>props.children</code></h4><p>件起始标签和结束标签之间的内容都会被将<code>{props.children}</code>替换。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;<span class="string">'FancyBorder FancyBorder-'</span> + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function WelcomeDialog() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;FancyBorder color="blue"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1 className="Dialog-title"&gt;</span></span><br><span class="line"><span class="regexp">        Welcome</span></span><br><span class="line"><span class="regexp">      &lt;/</span>h1&gt;</span><br><span class="line">      &lt;p className=<span class="string">"Dialog-message"</span>&gt;</span><br><span class="line">        Thank you <span class="keyword">for</span> visiting our spacecraft!</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="自定义坑位"><a href="#自定义坑位" class="headerlink" title="自定义坑位"></a>自定义坑位</h4><p>因为 <code>React元素</code> 本质就是对象，所以可以将它当中参数像其他数据一样传递。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SplitPane</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"SplitPane"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"SplitPane-left"</span>&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="SplitPane-right"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.right&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;SplitPane</span></span><br><span class="line"><span class="regexp">      left=&#123;</span></span><br><span class="line"><span class="regexp">        &lt;Contacts /</span>&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right=&#123;</span><br><span class="line">        &lt;Chat /&gt;</span><br><span class="line">      &#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><blockquote><p>每个 JSX 元素都是调用 React.createElement() 的语法糖。一般来说，如果你使用了 JSX，就不再需要调用<code>createElement()</code>或<code>createFactory()</code>方法。<br>React 提出的一种叫 JSX 的语法，这应该是最开始接触 React 最不能接受的设定之一,因为前端被“表现和逻辑层分离”这种思想“洗脑”太久了。实际上组件的 HTML 是组成一个组件不可分割的一部分，能够将 HTML 封装起来才是组件的完全体.</p></blockquote><blockquote><p>JSX是一个JavaScript语法扩展。它类似于模板语言，但它具有JavaScript 的全部能力。它最终会被编译为<code>React.createElement()</code>函数调用，返回称为 <code>React元素</code>的普通JavaScript`对象。</p></blockquote><p>推荐使用箭头函数，避免<a href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">this 造成困扰</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt; button className = <span class="string">"square"</span></span><br><span class="line">             onClick = &#123; props.onClick &#125; &gt;</span><br><span class="line">      &#123; props.value &#125;</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Board extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props)&#123;</span></span><br><span class="line"><span class="regexp">    super(props)</span></span><br><span class="line"><span class="regexp">    this.state = &#123;</span></span><br><span class="line"><span class="regexp">      squares: Array(9).fill(null),</span></span><br><span class="line"><span class="regexp">      xIsNext:true, /</span><span class="regexp">/ 先落子，并确认该哪位玩家落子</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  /</span>**</span><br><span class="line">   * 只接受一个squares副本，而不直接修改本身数据</span><br><span class="line">   * <span class="number">1.</span> 这样可以简化复杂的功能，不可变性使得复杂的特性更容易实现。</span><br><span class="line">   * <span class="number">2.</span> 可以跟踪数据的改变，如果直接修改源数据就很难跟踪变化的数据。</span><br><span class="line">   * <span class="number">3.</span> 可以帮助我们在 React 中创建 purecomponents。可以轻松的确定不可变数据是否发生了改变，</span><br><span class="line">   *    从而确定何时对组件进行重新渲染。</span><br><span class="line">   * @param &#123;*&#125; i</span><br><span class="line">   * @memberof Board</span><br><span class="line">   *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  handleClick(i) &#123;</span></span><br><span class="line"><span class="regexp">    const squares = this.state.squares.slice();</span></span><br><span class="line"><span class="regexp">    squares[i] = this.state.xIsNext? "X":"O";</span></span><br><span class="line"><span class="regexp">    this.setState(&#123; squares,xIsNext:!this.state.xIsNext &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  renderSquare(i) &#123; /</span><span class="regexp">/ 返回一个 Square 组件</span></span><br><span class="line"><span class="regexp">    return ( &lt; Square</span></span><br><span class="line"><span class="regexp">              value = &#123; this.state.squares[i] &#125;/</span><span class="regexp">/ 给子组件传递 value数据</span></span><br><span class="line"><span class="regexp">              onClick = &#123;()=&gt; this.handleClick(i)&#125; /</span><span class="regexp">/ 给子组件传递 onClick事件</span></span><br><span class="line"><span class="regexp">        /</span>&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;state&#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> status = <span class="string">`Next player: <span class="subst">$&#123;state.xIsNext?<span class="string">'X'</span>:<span class="string">'O'</span>&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div className=<span class="string">"status"</span>&gt;&#123;status&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="board-row"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(0)&#125;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(1)&#125;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(2)&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;div className=<span class="string">"board-row"</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.renderSquare(<span class="number">3</span>)&#125;</span><br><span class="line">          &#123;<span class="keyword">this</span>.renderSquare(<span class="number">4</span>)&#125;</span><br><span class="line">          &#123;<span class="keyword">this</span>.renderSquare(<span class="number">5</span>)&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="board-row"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(6)&#125;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(7)&#125;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(8)&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在 JSX 中你可以任意使用JavaScript表达式，只需要用一个<strong>大括号({})</strong>括起来；<br>事实上每个 React 元素都是一个<code>JavaScript</code> 对象，可以把它保存在变量中或者作为参数传递。</p><p>为避免遇到自动插入分号陷阱，<strong>最好将内容包裹在小括号中，如果只有一行代码则不需要括号</strong>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加括号</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"shopping-list"</span>&gt;</span><br><span class="line">        &lt;h1&gt;Shopping List <span class="keyword">for</span>&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;Instagram&lt;/</span>li&gt;</span><br><span class="line">          &lt;li&gt;WhatsApp&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;Oculus&lt;/</span>li&gt;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用加括号</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Instagram<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JSX 语法更接近于 JavaScript，所以 ReactDom 使用cameCase(小驼峰命名)来定义属性名称,并且不要使用引号将大括号包裹，两者是不能并存的。对于字符串值使用引号，对于表达式使用大括号</strong></p><p><strong><code>React</code> 中无法通过 <code>return false</code> 的方式阻止默认行为，必须使用<code>e.preventDefault()</code>阻止默认事件。但是不用担心<code>event事件</code>的兼容问题</strong></p><p><strong>JSX 本身就能防止<a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a>攻击</strong><br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生DOM</span></span><br><span class="line">&lt;a href=<span class="string">"#"</span> onclick=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span><br><span class="line">  Click me</span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ JSX</span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;a href="#" onclick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt; /</span><span class="regexp">/每次渲染时都会创建不同的回调函数。该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。</span></span><br><span class="line"><span class="regexp">            Click me</span></span><br><span class="line"><span class="regexp">        &lt;/</span>a&gt;;</span><br><span class="line">        &lt;a href=<span class="string">"#"</span> onclick=&#123;(e)=&gt;<span class="keyword">this</span>.handleClick(id,e)&#125;&gt; <span class="comment">// 向事件处理程序传递参数</span></span><br><span class="line">            Click me</span><br><span class="line">        &lt;<span class="regexp">/a&gt;;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="事件处理程序回调函数中的-this"><a href="#事件处理程序回调函数中的-this" class="headerlink" title="事件处理程序回调函数中的 this"></a><strong>事件处理程序回调函数中的 this</strong></h3><ul><li>在 <code>JavaScript</code> 中，<code>class</code> 的方法默认不会绑定 <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code>的值为 <code>undefined</code>。<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此语法确保 `handleClick` 内的 `this` 已被绑定。</span></span><br><span class="line">    <span class="comment">// 注意: 这是 **实验性** 语法。 使用 Create React App 默认会启用此语法</span></span><br><span class="line">    handleClick = <span class="function">(<span class="params">e</span>)=&gt;</span> &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;a href=<span class="string">"#"</span> onclick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">            Click me</span><br><span class="line">        &lt;<span class="regexp">/a&gt;;</span></span><br><span class="line"><span class="regexp">         &lt;a href="#" onclick=&#123;this.handleClick。bind(this,id)&#125;&gt; /</span><span class="regexp">/ 向事件处理程序传递参数, 事件对象会被隐式传递</span></span><br><span class="line"><span class="regexp">            Click me</span></span><br><span class="line"><span class="regexp">        &lt;/</span>a&gt;;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><blockquote><p>当组件状态<code>state</code>有更改的时候，<code>React</code>会自动调用组件的<code>render</code>方法重新渲染整个组件的<code>UI</code>。</p></blockquote><p><code>React</code>实现了一个<code>Virtual DOM</code>，组件 DOM 结构就是映射到这个<code>Virtual DOM</code> 上，<code>React</code> 在这个<code>Virtual DOM</code> 上实现了一个<code>diff</code>算法，<strong>当要重新渲染组件的时候，会通过<code>diff</code> 寻找到要变更的DOM 节点，再把这个修改更新到浏览器实际的DOM 节点上</strong>，所以实际上不是真的渲染整个<code>DOM</code>树(<code>React DOM</code> 只会更新实际改变了的内容)。这个 <code>Virtual DOM</code> 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;React&lt;/code&gt; 是一个声明式，高效且灵活的用于构建用户界面的 &lt;code&gt;JavaScrip
      
    
    </summary>
    
      <category term="React" scheme="https://owen027.github.io/categories/React/"/>
    
    
      <category term="basic" scheme="https://owen027.github.io/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 单例模式 （Singleton Pattern）</title>
    <link href="https://owen027.github.io/2019/07/21/singletonPattern/"/>
    <id>https://owen027.github.io/2019/07/21/singletonPattern/</id>
    <published>2019-07-21T15:46:04.000Z</published>
    <updated>2019-07-29T15:43:17.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>确保只有一个实例，并提供全局访问。</p></blockquote><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>一个类能返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法，通常命名为<code>getIntance</code>）；当我们调用这个方法时，类持有的引用不为空则返回这个引用，如果为空须创建该类实例并将实例的引用赋予该类保持的引用；同时将该类的构造函数定义为私有方法，那么其他环境就无法通过调用该类的构造函数来实例化该类的对象，只能通过该类提供的静态方法得到该类唯一的实例。</p><h3 id="实现-Java-语言中的单例模式"><a href="#实现-Java-语言中的单例模式" class="headerlink" title="实现 Java 语言中的单例模式"></a>实现 Java 语言中的单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton getInstance &#123;</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(INSTANCE = <span class="keyword">null</span>) &#123;</span><br><span class="line">                       INSTANCE = <span class="keyword">new</span> Singleton()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-JavaScript-语言中的单例模式"><a href="#实现-JavaScript-语言中的单例模式" class="headerlink" title="实现 JavaScript 语言中的单例模式"></a>实现 JavaScript 语言中的单例模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> instance;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(instance) <span class="keyword">return</span> instance;</span><br><span class="line">       <span class="keyword">return</span> instance = <span class="keyword">new</span> Singleton(name)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">let</span> s1 = Singleton.getInstance(<span class="string">'owen'</span>); <span class="comment">// Singleton &#123;name: "owen"&#125;</span></span><br><span class="line"><span class="keyword">let</span> s2 = Singleton.getInstance(<span class="string">'guowen'</span>); <span class="comment">// Singleton.getInstance('guowen');</span></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>JavaScript中单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。</p></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>使用命名空间可以降低全局变量带来的命名污染；<br>最简单的方法是对象字面量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalWeb = &#123;</span><br><span class="line">    a() &#123;&#125;,</span><br><span class="line">    b() &#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者使用闭包<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Singleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">let</span> init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">'owen'</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name,</span><br><span class="line">            data()&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            method:&#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getInstance() &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance) <span class="keyword">return</span> instance;</span><br><span class="line">            <span class="keyword">return</span> instance = init()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br><span class="line"><span class="keyword">let</span> app = Singleton.getInstance() <span class="comment">// &#123;name: "owen", data: ƒ, method: &#123;…&#125;&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h3><blockquote><p>惰性单例指在需要的时候才创建对象实例，在实现开发中非常有用，即目标对象只有在使用的时候才被创建，而不是页面加载好时创建。</p></blockquote><h4 id="模态框示例"><a href="#模态框示例" class="headerlink" title="模态框示例"></a>模态框示例</h4><p> 点击一个按钮弹窗一个模态框，很明显页面是唯一的，一次不会弹窗多个模态框的情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>modal box<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    * &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">   html&#123;</span></span><br><span class="line"><span class="css">   <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">   <span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.Owen</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:30</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:30</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span><span class="selector-pseudo">:10</span>% <span class="selector-tag">auto</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#modal</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">position</span><span class="selector-pseudo">:fixed</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">left</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">top</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.52</span>);</span></span><br><span class="line"><span class="css">        <span class="selector-tag">display</span><span class="selector-pseudo">:none</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:30</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:30</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span><span class="selector-pseudo">:10</span>% <span class="selector-tag">auto</span>;</span></span><br><span class="line"><span class="undefined">        text-align: center;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#b0e8ff</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"Owen"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>Owen<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"modal"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                我是弹框</span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> openModal = <span class="built_in">document</span>.querySelector(<span class="string">"button"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> modal = <span class="built_in">document</span>.querySelector(<span class="string">"#modal"</span>)</span></span><br><span class="line"><span class="javascript">    openModal.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">       modal.style.display = <span class="string">'block'</span></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 第一种方法是在页面加载完成时创建好这个弹框，一开始就是隐藏的，只有点击按钮的时候才显示，这种方式有一个问题，就是我们进入页面，只是看看其他内容，不做任何操作；这样就造成资源浪费</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>modal box<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    * &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">   html&#123;</span></span><br><span class="line"><span class="css">   <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">   <span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.Owen</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:30</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:30</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span><span class="selector-pseudo">:10</span>% <span class="selector-tag">auto</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#modal</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">position</span><span class="selector-pseudo">:fixed</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">left</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">top</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.52</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:30</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:30</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span><span class="selector-pseudo">:10</span>% <span class="selector-tag">auto</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">padding</span><span class="selector-pseudo">:20px</span>;</span></span><br><span class="line"><span class="undefined">        text-align: right;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#b0e8ff</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.main</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="undefined">        text-align: center;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.main</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="undefined">        display: inline-block;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">padding</span><span class="selector-pseudo">:5px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">cursor</span><span class="selector-pseudo">:pointer</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"Owen"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">    init()</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> openModal = <span class="built_in">document</span>.querySelector(<span class="string">"button"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> createModal =( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> flag;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 生成 Modal 容器</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">        div.id = <span class="string">"modal"</span></span></span><br><span class="line"><span class="javascript">        div.style.display = <span class="string">"none"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> div;</span></span><br><span class="line"><span class="javascript">            flag = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> fra = <span class="built_in">document</span>.createDocumentFragment();</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 添加 Modal 内容</span></span></span><br><span class="line"><span class="xml">            els = `<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span></span><br><span class="line"><span class="javascript">                    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"close"</span>&gt;×&lt;<span class="regexp">/span&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">                            我是弹框</span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">                    `</span></span><br><span class="line"><span class="undefined">            div.innerHTML = els;</span></span><br><span class="line"><span class="undefined">            fra.appendChild(div)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(fra)</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 关闭 Modal</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> close = <span class="built_in">document</span>.querySelector(<span class="string">'.close'</span>)</span></span><br><span class="line"><span class="javascript">            close.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                flag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.body.removeChild(div)</span></span><br><span class="line"><span class="undefined">            &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> div</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;())</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 显示 Modal</span></span></span><br><span class="line"><span class="javascript">    openModal.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">       createModal().style.display = <span class="string">"block"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种方法，只执行一次DOM的创建修改操作，不用频繁的创建和删除节点，提高资源利用率；</p><p><strong>参考资料</strong></p><p>《JavaScript设计模式与开发实践》<br><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">基维</a></p><p><a href="https://www.cnblogs.com/TomXu/archive/2012/02/20/2352817.html">大叔</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;确保只有一个实例，并提供全局访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实现思路&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="design patterns" scheme="https://owen027.github.io/categories/design-patterns/"/>
    
    
      <category term="Singleton" scheme="https://owen027.github.io/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 高阶函数（Heigher-order function）</title>
    <link href="https://owen027.github.io/2019/07/12/designPatterns3/"/>
    <id>https://owen027.github.io/2019/07/12/designPatterns3/</id>
    <published>2019-07-12T04:32:40.000Z</published>
    <updated>2019-07-29T15:43:17.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是高阶函数"><a href="#什么是高阶函数" class="headerlink" title="什么是高阶函数"></a>什么是高阶函数</h1><blockquote><p>《javascript设计模式和开发实践》中定义 函数既可作为参数被传递，也可以作为返回值输出</p></blockquote><p><strong>满足以下条件:</strong></p><ul><li>接受一个或多个函数作为输入</li><li>输出一个函数</li></ul><p>高阶函数一般是那些函数型包含多于函数。在函数式编程中，返回另一个函数的高阶函数被称为Curry化的函数。</p><h2 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h2><blockquote><p>将函数作为参数传递，我们就可以抽离以部分容易变化的业务逻辑，这样可以分离业务代码中变与不变的部分</p></blockquote><p><strong>回调函数：</strong></p><blockquote><p>将函数传进一个方法中，函数不会立即执行，等待出来结果之后在执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="string">'owen'</span>)&#123;</span><br><span class="line">        callback() <span class="comment">//回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">say</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'Hello Word'</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> func(say)</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>Array 对象常用的方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].forEach(iteration)</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">iteration</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(v)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="作为返回值输出"><a href="#作为返回值输出" class="headerlink" title="作为返回值输出"></a>作为返回值输出</h2><blockquote><p>让函数继续返回一个可执行的函数，意味着运行过程是可延续的。</p></blockquote><p><strong>判断数据类型</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> type = <span class="function"><span class="params">type</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> isArray = type(<span class="string">'Array'</span>),isString = type(<span class="string">'String'</span>),isNumber = type(<span class="string">'Number'</span>),isObject = type(<span class="string">'Object'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">let</span> Type = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type = &#123;&#125;,types = [<span class="string">'Object'</span>,<span class="string">'Array'</span>,<span class="string">'Number'</span>,<span class="string">'String'</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span>  types) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">            type[<span class="string">`is<span class="subst">$&#123;str&#125;</span>`</span>] = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">`[object <span class="subst">$&#123;str&#125;</span>]`</span></span><br><span class="line">        &#125;(val))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(type)</span><br><span class="line">    <span class="keyword">return</span> type</span><br><span class="line">&#125;())</span><br><span class="line">Type.isNumber(<span class="number">2</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="实现AOP（面向切片编程）"><a href="#实现AOP（面向切片编程）" class="headerlink" title="实现AOP（面向切片编程）"></a>实现AOP（面向切片编程）</h3><blockquote><p>AOP 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。<br>JAVA 语言中 AOP 将一些跟核心业务逻辑模块无关的功能抽离出来，通常包括日志统计、安全控制、异常处理灯。再通过“动态织入”的方式掺入业务逻辑中。<br><strong>好处：</strong> 可以保持业务逻辑模块的纯净和高内聚，方便复用日志统计等功能模块。</p></blockquote><p>JavaScript中实现AOP是指把一个函数“动态织入”到另一个函数之中<br><strong>具体实现：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforeFn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>; <span class="comment">// 谁调用指向谁 下面是由 func 函数调用所以是指向 func</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> ...args</span>)</span>&#123;</span><br><span class="line">        beforeFn.apply(<span class="keyword">this</span>,args) <span class="comment">// 执行回调函数 beforeFn</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(<span class="keyword">this</span>,args) <span class="comment">// 执行原函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterFn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>; <span class="comment">// 谁调用指向谁 下面是由befor函数调用所以是指向 befor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> ...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> ret = that.apply(<span class="keyword">this</span>,args) <span class="comment">// 执行并接收原对象</span></span><br><span class="line">        afterFn.apply(<span class="keyword">this</span>,args) <span class="comment">//  执行回调函数 beforeFn</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">func = func.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line">func()</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure></p><h3 id="函数柯里化-（function-currying）"><a href="#函数柯里化-（function-currying）" class="headerlink" title="函数柯里化 （function currying）"></a>函数柯里化 （function currying）</h3><blockquote><p>在数学和计算机科学中，柯里化是将多个参数的函数转换成一系列使用一个参数的函数，且返回接受余下的参数的新函数</p></blockquote><p><strong>curring 又称部分求值；一个 curring 函数首先会接收一些参数，该函数并不会立即求值，而是继续返回另外一个函数，而刚传入的参数会被保存在形成的闭包中，待函数真正需要求值的时候，之前的所以参数都会被一次性用于求值</strong></p><p><strong>简单示例：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果柯里化</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>接下来使用 currying 实现一个几天之内消费总和的函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通方法</span></span><br><span class="line"><span class="keyword">var</span> cost = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">arguments</span>.length)&#123;</span><br><span class="line">            <span class="keyword">let</span> money = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> args )&#123;</span><br><span class="line">                money += val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> money</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            [].push.apply(args,<span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">cost(<span class="number">100</span>);</span><br><span class="line">cost(<span class="number">100</span>);</span><br><span class="line">cost(<span class="number">100</span>);</span><br><span class="line">cost(); <span class="comment">// 300</span></span><br><span class="line"></span><br><span class="line">cost(<span class="number">100</span>)(<span class="number">100</span>)(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// currying</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存原函数参数返回到新函数中使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  func(100,100,100) //300</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span> (<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(args.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> args)&#123;</span><br><span class="line">             num +=v</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> num</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> args[<span class="number">0</span>]</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  curry = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = []</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...Args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Args.length)&#123;</span><br><span class="line">            [].push.apply(args,Args)</span><br><span class="line">            <span class="keyword">return</span> fn</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> func.apply(<span class="keyword">this</span>,args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cost = curry(count);</span><br><span class="line"></span><br><span class="line">cost(<span class="number">100</span>);</span><br><span class="line">cost(<span class="number">100</span>);</span><br><span class="line">cost(<span class="number">100</span>);</span><br><span class="line">cost(); <span class="comment">// 300</span></span><br></pre></td></tr></table></figure></p><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>JavaScript 中大多数情况都是用户主动出发函数，除非函数本身的实现不合理，否则一般不会遇到跟性能相关的问题，少数情况下，函数不是由用户直接触发控制，可能被频繁调用造成严重的性能问题。<br>比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// do something...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// do something...</span></span><br><span class="line">&#125;);</span><br><span class="line">Dom.addEventListener(<span class="string">'mousemove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// do something...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// progress</span></span><br><span class="line">xhr.upload.addEventListener(<span class="string">"progress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p><p><strong>上述事件1秒种触发很多次，并且常常操作DOM节点，非常损耗性能，浏览器会因此吃不消而卡顿；实际我们不需要触发如此高的频率因此我们可以在一段时间内忽略掉一些执行次数</strong></p><h4 id="节流原理："><a href="#节流原理：" class="headerlink" title="节流原理："></a>节流原理：</h4><blockquote><p>如果持续触发事件，可每隔一段时间只执行一次。</p></blockquote><h5 id="使用定时器实现节流"><a href="#使用定时器实现节流" class="headerlink" title="使用定时器实现节流"></a>使用定时器实现节流</h5><blockquote><p>将即将被执行的函数用 <code>setTimeout</code> 函数延迟一段时间执行，如果该定时器未执行完成则忽略接下下来的需被执行的函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> timer, firstFlag = <span class="literal">true</span>; <span class="comment">//第一次立即执行</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(timer)  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果存在定时器这不执行</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">          <span class="keyword">if</span>(firstFlag)&#123;</span><br><span class="line">              firstFlag = <span class="literal">false</span>;</span><br><span class="line">             <span class="keyword">return</span> func.apply(that,args);</span><br><span class="line">          &#125;</span><br><span class="line">          timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               clearTimeout(timer);</span><br><span class="line">               timer = <span class="literal">null</span>;</span><br><span class="line">               func.apply(that,args);</span><br><span class="line">            &#125;,wait)</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttle(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;,<span class="number">1000</span>));</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><blockquote><p>和节流一定时间段内只调用一次事件处理函数不同，防抖是一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。（用户不再触发对应事件才执行一次事件）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            func.apply(that,args)</span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;,<span class="number">1000</span>));</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>参考资料</strong></p><p>《JavaScript设计模式与开发实践》</p><p><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">基维 AOP</a></p><p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">基维 高阶函数</a></p><p><a href="https://github.com/mqyqingfeng/Blog/issues/26">JavaScript专题之跟着 underscore 学节流</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是高阶函数&quot;&gt;&lt;a href=&quot;#什么是高阶函数&quot; class=&quot;headerlink&quot; title=&quot;什么是高阶函数&quot;&gt;&lt;/a&gt;什么是高阶函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;《javascript设计模式和开发实践》中定义 函数既可作为参数被传递，
      
    
    </summary>
    
      <category term="design patterns" scheme="https://owen027.github.io/categories/design-patterns/"/>
    
    
      <category term="Heigher-order" scheme="https://owen027.github.io/tags/Heigher-order/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript  设计模式基础（二）</title>
    <link href="https://owen027.github.io/2019/07/09/designPatterns2/"/>
    <id>https://owen027.github.io/2019/07/09/designPatterns2/</id>
    <published>2019-07-09T05:13:34.000Z</published>
    <updated>2019-07-21T16:01:09.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>在以类为中心的面向对象编程语言中，类和对象的关系就像铸模和铸件的关系，对象总是从类中创建。而原型编程中，类不是必须的，对象未必从类中创建而来，可以拷贝另一个对象而变成新对象</p><blockquote><p>从设计模式角度讲，原型模式是用于创建对象的一种模式，找到一个对象，不需要关心对象的具体类型，通过克隆来创建一个一模一样的对象。 原型不单是一种设计模式，也被称为编程泛型</p></blockquote><p>原型模式实现的关键是语言本身是否提供了 clone 方法， ECMAScript 5 提供了 <code>Object.create</code> 方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plane</span> (<span class="params">propertys</span>)</span>&#123; <span class="comment">//工厂方法</span></span><br><span class="line">    <span class="keyword">this</span>.blood = propertys.blood;</span><br><span class="line">    <span class="keyword">this</span>.attackLevel = propertys.attackLevel;</span><br><span class="line">    <span class="keyword">this</span>.defenseLevel = propertys.defenseLevel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> Plane(&#123;</span><br><span class="line">    blood :<span class="number">100</span>,</span><br><span class="line">    attackLevel :<span class="number">10</span>,</span><br><span class="line">    defenseLevel :<span class="number">10</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> clonePlane = <span class="built_in">Object</span>.create(plane);</span><br><span class="line"><span class="built_in">console</span>.log(clonePlane.__proto__) <span class="comment">// Plane &#123;blood: 100, attackLevel: 10, defenseLevel: 10&#125;</span></span><br></pre></td></tr></table></figure></p><p>通过克隆 <code>plane 对象</code>得到 <code>clonePlane 对象</code>,那么 plane 就被称为 clonePlane 的原型；而 plane 中所有的属性和方法都将挂载到<code>__proto__</code> 原型属性上</p><p>每个 JS 对象都有 <code>__proto__</code> 属性(隐式原型属性)，指向创建该对象的构造函数的原型,这个属性可以访问到原型（<code>[[prototype]]</code>） 内部属性。这个属性在现在来说已经不推荐直接去使用它了。</p><p><strong>由于 JavaScript 作为一门基于原型的语言，没有类的概念，每一个对象都是基于另一个对象的克隆，因此语言最初只有一个根对象 <code>Object.prototype</code>,如果A对象是从B对象克隆而来，那么B就是A的原型，如果C又是B的原型。它们之间就形成了一条原型链</strong></p><label> <strong>原型编程中有一个重要特性：访问对象中某个属性或方法，而对象本身没有对应属性和方法，那么它会从自己的原型链上查找，一直查到根对象为止</strong><br></label><br><strong>一级级向上，对性能有影响，寻找的层级越多，性能影响越大</strong><br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(clonePlane) <span class="comment">// Plane &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(clonePlane.blood) <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(clonePlane.color) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(clonePlane.__proto__) <span class="comment">//原型 Plane &#123;blood: 100, attackLevel: 10, defenseLevel: 10&#125;</span></span><br></pre></td></tr></table></figure><br><br>上述代码中的<code>clonePlane 对象</code> 本身是没有 blood 和 color 属性，却能访问到blood的值而访问不到color的值，是因为 <code>clonePlane 对象</code> 原型链中有 blood 属性而没有color属性。<br><br><strong>原型编程基本规则：</strong><br>1. 所有数据都是对象<br>2. 对象会记住它的原型（类似于继承）<br>3. 要得到一个对象，需要将另一个对象作为原型并克隆它<br>4. 访问不到对象的某个属性或方法，那么它会从自己的原型链上查找，一直查到根对象为止<br><br>## 原型继承<br><br>在JavaScript中我们遇到的每一个对象都是从 <code>Object.prototype</code>克隆而来，通过<code>Object.getPrototypeOf</code>来判断对象的原型从属关系。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj) === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj1) === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><br><br>由于引擎内部会自动实现对 <code>Object.prototype</code> 的克隆，所有我们执行显示的使用<code>let obj = new Object(); let obj1 = {};</code><br> <code>prototype</code> 有一个属性 <code>constructor</code>，默认指向原型所在的构造函数<br>,<code>constructor</code>是一个公有且不可枚举的属性。一旦我们改变了函数的 prototype ，那么新对象就没有这个属性了,如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。<br><br>下面我们来看<code>new</code> 运算符<br><br> <label> <strong>JavaScript中没有类的概念，所以 <code>Object</code> 是一个构造函数，JavaScript 中的函数即可作为普通函数调用，又可作为构造器调用,当使用 new 运算调用函数时，函数就是构造器。</strong></label><h3 id="new命令的原理"><a href="#new命令的原理" class="headerlink" title="new命令的原理"></a><code>new</code>命令的原理</h3><ol><li>创建一个空对象，作为返回的对象实例</li><li>将构造函数指向原型<code>prototype</code>属性（继承构造函数）</li><li>绑定作用域（ this 指向空对象 ）</li><li>执行构造函数,如果构造函数return 为对象则使用该对象，否则 return 创建的空对象</li></ol><p>模拟 <code>new</code> 运算<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__new</span> (<span class="params">fun,args</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 获取构造函数</span></span><br><span class="line">  <span class="keyword">let</span> arr =[...arguments]</span><br><span class="line">  <span class="keyword">let</span> Con = arr.shift()</span><br><span class="line">  <span class="comment">// 创建对象，将构造函数的原型指向它</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(Con.prototype)</span><br><span class="line">  <span class="comment">// 绑定 this</span></span><br><span class="line">  <span class="keyword">let</span> ret = Con.apply(obj,arr)</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> ret === <span class="string">'object'</span> &amp;&amp; ret !== <span class="literal">null</span> )? ret : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = __new(<span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">&#123; name,sex,age &#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;,&#123;<span class="attr">name</span>:<span class="string">'owen'</span>,<span class="attr">sex</span>:<span class="string">'man'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// Person &#123;name: "owen", sex: "man", age: 18&#125;</span></span><br></pre></td></tr></table></figure></p><p><strong>new.target：</strong>  可利用 它来判断是否使用 new 命令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'请使用 new 命令调用！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func() <span class="comment">// Uncaught Error: 请使用 new 命令调用！</span></span><br></pre></td></tr></table></figure><h3 id="call，apply-and-bind"><a href="#call，apply-and-bind" class="headerlink" title="call，apply and bind"></a>call，apply and bind</h3><p>Javascript 编程中 <code>call，apply 和 bind</code> 方法被广泛运用，在学习设计模式前先理解这几个概念</p><blockquote><p>三者都可改变函数内部this的指向（即函数执行时所在的作用域）</p></blockquote><h4 id="call-and-apply"><a href="#call-and-apply" class="headerlink" title="call and apply"></a>call and apply</h4><blockquote><p>都是在改变this 指向后调用该函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//test() == test.call()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj =&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj) <span class="comment">//"[object Object]"</span></span><br><span class="line"><span class="comment">//因为call 和 apply 会将函数中的this指向第一个参数</span></span><br><span class="line"><span class="comment">//相当于 obj.toString()</span></span><br></pre></td></tr></table></figure></p></blockquote><p><strong><code>call and apply</code> 二者区别在于传参：</strong></p><ul><li>call 第二个参数开始单个单个参数传</li><li>apply 第二个参数为数组或类数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回数组中最大的数</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">15</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组的空元素变为undefined</span></span><br><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>,[<span class="number">1</span>,,<span class="number">3</span>,,<span class="number">4</span>])<span class="comment">//[1,undefined,3,undefined,4];</span></span><br></pre></td></tr></table></figure><p>空元素与undefined的差别</p><ul><li>forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。</li><li><label>转换类似数组的对象</label></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">Array</span>.protetype.slice.apply(obj);<span class="comment">//[1,undefined]</span></span><br></pre></td></tr></table></figure><label>被处理的对象必须有length属性，以及相对应的数字键。</label><h6 id="参数为空、null和undefined，则默认传入全局对象。"><a href="#参数为空、null和undefined，则默认传入全局对象。" class="headerlink" title="参数为空、null和undefined，则默认传入全局对象。"></a><label>参数为空、null和undefined，则默认传入全局对象。</label></h6><hr><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p><strong>bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = counter.func.bind(counter);</span><br><span class="line">func(); <span class="comment">// 相当于 count++</span></span><br><span class="line">counter.count <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="keyword">this</span>.m + y * <span class="keyword">this</span>.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  m: <span class="number">2</span>,</span><br><span class="line">  n: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newAdd = add.bind(obj, <span class="number">5</span>); <span class="comment">//将x 绑定为 5</span></span><br><span class="line">newAdd(<span class="number">5</span>) <span class="comment">// 20</span></span><br><span class="line">newAdd(<span class="number">1</span>,<span class="number">6</span>)<span class="comment">//12 6为起作用 相当于 5*2+1*2</span></span><br></pre></td></tr></table></figure><label>第一个参数是null或undefined，等于将this绑定到全局对象</label><h4 id="bind方法使用注意点"><a href="#bind方法使用注意点" class="headerlink" title="bind方法使用注意点"></a>bind方法使用注意点</h4><ul><li>bind方法每运行一次，就返回一个新函数 需要一个变量接收</li></ul><h4 id="模拟-bind"><a href="#模拟-bind" class="headerlink" title="模拟 bind"></a>模拟 bind</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">...Args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> that = <span class="keyword">this</span>, <span class="comment">//保存原函数</span></span><br><span class="line">  target = Args.shift(), <span class="comment">//提取须绑定的对像</span></span><br><span class="line">  func =  <span class="function">(<span class="params">...args</span>) =&gt;</span>that.apply(target ? <span class="keyword">this</span> : target || <span class="built_in">window</span>, aArgs.concat(args));  <span class="comment">//  aArgs.concat(args) 合并参数</span></span><br><span class="line">  func.prototype = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.prototype); <span class="comment">// 继承原函数的原型</span></span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>结合回调函数使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callIt</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callIt(counter.inc.bind(counter));</span><br><span class="line">counter.count <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>结合call方法使用</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].slice(<span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将Array.prototype.slice变成Function.prototype.call方法所在的对象</span></span><br><span class="line"><span class="comment">//调用时就变成了Array.prototype.slice.call。</span></span><br><span class="line"><span class="keyword">let</span> slice = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Array</span>.prototype.slice);</span><br><span class="line"><span class="built_in">Function</span>.prototype.slice.call([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="comment">//slice([1, 2, 3], 0, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> push = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Array</span>.prototype.push);</span><br><span class="line"><span class="keyword">let</span> pop = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Array</span>.prototype.pop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>];</span><br><span class="line">push(a, <span class="number">4</span>)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">pop(a)</span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><ul><li>将Function.prototype.bind方法变成Function.prototype.call的方法，就意味着bind的调用形式也可以被改写</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">v</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> bind = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Function</span>.prototype.bind);</span><br><span class="line">bind(f, o)() <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h1&gt;&lt;p&gt;在以类为中心的面向对象编程语言中，类和对象的关系就像铸模和铸件的关系，对象总是从类中创建。而原型编程中，类不是必须的，对象未
      
    
    </summary>
    
      <category term="design patterns" scheme="https://owen027.github.io/categories/design-patterns/"/>
    
    
      <category term="Pattern intro" scheme="https://owen027.github.io/tags/Pattern-intro/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 设计模式基础（一）</title>
    <link href="https://owen027.github.io/2019/07/08/designPatterns1/"/>
    <id>https://owen027.github.io/2019/07/08/designPatterns1/</id>
    <published>2019-07-08T05:13:34.000Z</published>
    <updated>2019-07-21T16:01:09.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h1><blockquote><p><code>模式</code> 起源于建筑学。20世纪70年代，哈佛大学建筑学博士<code>Christopher Alexander</code>和他的团队花大约20年，来研究为解决同一个问题而设计出的不同建筑结构，从中发现那些高质量设计中的相似性，并且用<code>模式</code>来指代这种相似性；</p></blockquote><p>受<code>Christopher Alexander</code>观点的启发，<code>Erich Gamma, Richard Helm, Ralph Johnson和 John Vlissides</code>(人称Gang Of Four, GoF),将这种 <code>模式</code> 观点应用于面向对象的软件设计中，并总结了23种常见的软件开发设计模式， 于 1995 年发布一本名叫《Design Patterns: Elements Of Reusable Object-Oriented Software》的书</p><blockquote><p>设计模式的定义：在面向对象软件设计过程种针对特定的问题的简洁而优雅的解决方案。就是给面向对象软件开发中一些 好的设计取个名。</p></blockquote><h2 id="为什么要给好设计取名？"><a href="#为什么要给好设计取名？" class="headerlink" title="为什么要给好设计取名？"></a>为什么要给好设计取名？</h2><p>在开发中，一些稍有经验的程序员也许在不知不觉中使用过设计模式，于是他向别人描述它时会遇到困难，沟通成本高、效率低。而 GoF 将这些好的设计从面向对象中挑选出来，这些都是久经考验的反应了开发者的经验和见解的使用模式来定义的技术，给它们一个好听又好记的名字，这样就方便我们更好的传播和学习，当遇到一个问题时，知道这是哪种设计模式，就能很快想出几种解决方案，提高工作效率。</p><p><strong>好处：</strong></p><ol><li>提供固定的解决方法来解决在软件开发中出现的问题。</li><li>很容易地重用，防止在应用程序开发过程中出现的一些可能导致重大问题的小问题，提高工作效率。</li><li>避免重复代码来减小我们文件大小。</li><li>模式善于表达，交流更快速，降低沟通成本。</li></ol><p> <strong>所有设计模式的实现都遵循一条原则：找出程序中变化的地方，将变化封装起来</strong>。一个程序的设计总是可以分为 可变部分和不变的部分；找出可变部分，将其封装，剩下的不变和稳定部分就非常容易复用。<br><strong>作用：</strong> 让人写出可复用和可维护的程序。<br>JavaScript是一门<code>面向对象语言</code><a href="https://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/">[1]</a><a href="https://www.infoq.cn/article/3*8POPcRSClQh1Cp9Sqg">[2]</a><a href="https://zhuanlan.zhihu.com/p/33658346">[3]</a>，设计模式通过对面向对象的特征<label><strong>封装、继承、组合、多态</strong></label>等技术的反复使用，提炼出可复用的面向对象设计技巧。</p><hr><h1 id="设计模式基础"><a href="#设计模式基础" class="headerlink" title="设计模式基础"></a>设计模式基础</h1><blockquote><p>JavaScript 在语言层面没有抽象类和接口的支持，没有类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。</p></blockquote><h2 id="编程语言类型"><a href="#编程语言类型" class="headerlink" title="编程语言类型"></a>编程语言类型</h2><p><strong>编程语言按数据类型大体可分两大类：静态类型语言和动态类型语言</strong> 。静态类型语言在编译时就已经确定变量的类型，动态类型语言只有在程序运行的时候才能确定变量的类型。而JavaScript就是动态类型语言。</p><p><strong>静态语言优点：</strong></p><ol><li>编译时就能发现类型不匹配的错误，可以避免程序运行时有可能发生的错误。</li><li>编译器可针对对应变量的类型进行优化，提高程序运行速度。</li></ol><p><strong>静态语言缺点：</strong></p><ol><li>迫使程序员按照对应的规则来写程序，为每个变量规定数据类型分散程序员注意力，增加代码量。</li></ol><p><strong>动态语言优点：</strong></p><ol><li>代码简洁，程序员可以把更多精力放在业务逻辑处理上，更加专注</li><li>无需类型检测，灵活性高，只关注须对象的行为，无需关注对象本身</li><li>不必借助超类型来实现”面向接口编程”</li></ol><p><strong>动态语言缺点：</strong></p><ol><li>无法保证变量的类型，程序可能发生意想不到的bug.</li></ol><h2 id="面向对象的特征-参考JAVA"><a href="#面向对象的特征-参考JAVA" class="headerlink" title="面向对象的特征(参考JAVA)"></a>面向对象的特征(参考JAVA)</h2><p><strong>多态、继承、封装</strong></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote><p>定义：同一操作作用于不同对象，产生不同的解释和不同的执行结果</p></blockquote><p>给不同对象发送同一个消息时，这些对象会根据这个消息分别给出不同的回应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sendInfo = <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( target <span class="keyword">instanceof</span> ObjOne) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> ObjOne)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> ObjTwo) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> ObjTwo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">ObjOne</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">ObjTwo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> sendInfo(<span class="keyword">new</span> ObjOne())</span><br><span class="line"> sendInfo(<span class="keyword">new</span> ObjTwo())</span><br></pre></td></tr></table></figure><p>上述代码段就体现了<code>多态性</code>,当发送 <code>sendInfo</code> 消息时每个对象做出不同的回应，但是这样的<code>多态性</code>很糟糕，如果再这个家一个对象 ObjThere 就得改动代码，对象越来越多时，<strong>修改的代码越多，出错的可能性越大。</strong></p><p>多态背后的思想是将 <code>做什么</code> 和 <code>谁去做以及怎样做</code>分开，也就是将 <code>不变的事物和可能变化的事</code> 分开。上述代码段中，每个对象都会打印日志,这是不变的，而各个对象输出哪些信息是变化的，将不变的隔离出来，把变化的封装起来，这样程序就又了扩展能力，是可生长的，这样就符合 <code>开发-封闭</code> 原则。<br><strong>下面是修改后的代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sendInfo = <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">  target.log()</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">ObjOne</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">ObjOne.prototype.log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjTwo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">ObjTwo.prototype.log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;;</span><br><span class="line"></span><br><span class="line"> sendInfo(<span class="keyword">new</span> ObjOne())</span><br><span class="line"> sendInfo(<span class="keyword">new</span> ObjTwo())</span><br></pre></td></tr></table></figure><p>现在我们增加一个对象就不需要修改 <code>sendInfo</code>里的代码了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjThere</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">ObjThere.prototype.log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;;</span><br><span class="line">sendInfo(<span class="keyword">new</span> ObjThere())</span><br></pre></td></tr></table></figure><h4 id="类型检查和多态"><a href="#类型检查和多态" class="headerlink" title="类型检查和多态"></a>类型检查和多态</h4><p>类型检查是再表现出对象多态性之前一个绕不开的话题，<code>JavaScript</code> 是一门不必进行类型检查的动态类型语言，为了真正了解多态的目的，须从静态语言说起。</p><p>以JAVA为例，由于在编译时会进行类型检查，所有不能给变量赋予不同类型的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str;</span><br><span class="line"></span><br><span class="line">str = <span class="string">'ab'</span></span><br><span class="line">str =<span class="number">2</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure></p><p>将之前的例子换成 Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">'a'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjTwo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">'b'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendInfo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span> <span class="params">(ObjOne objOne)</span> </span>&#123;</span><br><span class="line">      objOne.log()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[] )</span> </span>&#123;</span><br><span class="line">        SendInfo sendInfo = <span class="keyword">new</span> SnedInfo();</span><br><span class="line">        ObjOne objOne = <span class="keyword">new</span> ObjOne()</span><br><span class="line">        sendInfo(objOne) <span class="comment">// 'a'</span></span><br><span class="line">        ObjTwo objTwo = <span class="keyword">new</span> objTwo()</span><br><span class="line">        sendInfo(objTwo) <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码段中 <code>sendInfo(objOne)</code> 可以顺利输出，而<code>sendInfo(objTwo)</code>因为传入的类不同而报错，为了解决这一问题，静态类性的面向对象通常被设计为可向上转型：<strong>当给一个类变量赋值时，这个变量的类型既可以用这个类本身，也可以用这个类的超类</strong> 就像描述一只咖啡猫在跑、一只波斯猫在跑，如果忽略它们具体类型，可以说 一只猫在跑。</p><p>同理，当 ObjOne 和 ObjTwo 对象的类型都被隐藏在超类 Objects 身后时， ObjOne 和 ObjTwo就能被交换使用，这就让对象表现出多态性，这种表现正是实现众多设计模式的目标。<br><strong>要实现多态归根结底得先要消除类型之间的耦合关系。一个JavaScript对象即可表示<code>ObjOne</code>又可表示<code>ObjThere</code>,这意味着JavaScript对象的多态性是与生俱来的</strong></p><h4 id="多态在面向对象程序设计中的作用"><a href="#多态在面向对象程序设计中的作用" class="headerlink" title="多态在面向对象程序设计中的作用"></a>多态在面向对象程序设计中的作用</h4><p><code>Martin Fowler</code> 在重构一书中写到：</p><blockquote><p>  多态的最根本好处在于，你不必再向对象询问“你是什么类” 而后根据得到的答案调用对象的某个行为————你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。</p></blockquote><p><strong>多态最根本的作用就是把过程化的条件分支语句转化为对象的多态性，从而消除条件分支语句</strong></p><p>就好比如在电影拍摄现场，导演喊出“action”时，每个人都做自己应该做的事，而不用导演走到每个人面前确认他们的职责，然后告诉他们该做什么。<strong>对象应该做什么并不是临时决定的，而是事先约定排练好的，每个对象该做什么，已经成为该对象的一个方法，被安装在对像内部，每个对像负责自己的行为，然后这些对象通过同一个消息，有条不紊的工作</strong><br>将行为分布在各个对象中，让他们各自负责自己的行为，这便是面向对象设计的优点。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</strong>通过继承创建的新类称为“子类”或“派生类”,被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。</p><blockquote><p>使用继承来得到多态效果,是让对象表现出多态性最常用的手段。继承通常包括<strong>实现继承(使用基类的属性和方法而无需额外编码的能力)和接口继承( 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力)和可视继承(子窗体（类）使用基窗体（类）的外观和实现代码的能力)</strong></p></blockquote><p><strong>注意：</strong> 使用继承时,两个类之间的关系应该是“属于”关系。</p><p>将上述JAVA例子进一步封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Objects</span> </span>&#123; <span class="comment">//抽象出一个超类</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjOne</span> <span class="keyword">extends</span> <span class="title">Objects</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">'a'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjTwo</span> <span class="keyword">extends</span> <span class="title">Objects</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">'b'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendInfo</span> </span>&#123; <span class="comment">//让 log 方法接收 Objects 类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span> <span class="params">(Objects objects)</span> </span>&#123;</span><br><span class="line">      objects.log()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[] )</span> </span>&#123;</span><br><span class="line">        SendInfo sendInfo = <span class="keyword">new</span> SnedInfo();</span><br><span class="line">        Objects  objOne = <span class="keyword">new</span> ObjOne();</span><br><span class="line">        Objects  objTwo = <span class="keyword">new</span> objTwo();</span><br><span class="line">        sendInfo(objOne) <span class="comment">// 'a'</span></span><br><span class="line">        sendInfo(objTwo) <span class="comment">// 'b'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码段中 ObjOne 和 ObjTwo 继承自 Objects 类即可通过这个桥梁来使用对应的方法。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是实现面向对象程序设计的第一步，将数据或函数等集合在一个个单元中（在java中称之为类，JavaScript中就是一个函数对象）</p><blockquote><p>封装是隐藏数据、实现细节、设计细节以及对象的类型等，是代码模块化；是把过程和数据包围起来，只能通过已定义的方法访问数据。<strong>把客观事物封装成抽象的类，并且只对可信的类或对象来操作这个类的数据和方法，而对不可信的对象进行信息隐藏</strong></p></blockquote><p><strong>封装的意义：</strong></p><ol><li>保护数据成员，不然其他对象或类直接访问或修改，只能通过提供的接口访问，防止用户无意破坏（数据封装）</li><li>方法的细节对外是隐藏的，只要接口不变，内容的修改不会影响到外部的调用这（封装实现）</li></ol><h3 id="封装数据"><a href="#封装数据" class="headerlink" title="封装数据"></a>封装数据</h3><p>在许多语言的对象系统中，封装数据是由语法解析来实现的比如 JAVA 提供了 public 、private、protected等关键字来设置不同的访问权限。</p><p><strong>JavaScript 中并没有提供这些关键字，只能依赖作用域来实现封装特性，而且只能模拟出 public、和private</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject=<span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> __name = <span class="string">"owen"</span>; <span class="comment">// private</span></span><br><span class="line">    <span class="keyword">return</span> &#123;  <span class="comment">// publice 对象</span></span><br><span class="line">        getName()&#123;</span><br><span class="line">            <span class="keyword">return</span> __name</span><br><span class="line">        &#125;,</span><br><span class="line">        setName(value)&#123;</span><br><span class="line">            <span class="keyword">return</span> __name = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">myObject.getName() <span class="comment">// "owen"</span></span><br><span class="line">myObject.setName(<span class="string">'gao'</span>)</span><br><span class="line">myObject.getName() <span class="comment">// "gao"</span></span><br></pre></td></tr></table></figure></p><p>ES6 中除了 let 、const 外还可使用 Symbol 类型建立私有属性</p><h3 id="封装实现"><a href="#封装实现" class="headerlink" title="封装实现"></a>封装实现</h3><p>封装使对象内部的变化对其他对象或类而言是透明不可见的，对象对他自己的行为负责，其他对象或类不用关心他内部的实现，对象之间只通过暴露 API接口来通信。</p><p>比如 Array中的forEach 方法遍历一个聚合对象，我们不用关心 forEach 内部是争议实现的，只要它提供的功能正确就行，即使修改它内部的代码，只要调用方式没有变化就不用关系它内部实现的改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val))</span><br></pre></td></tr></table></figure><p>封装在更重要的层面体现为封装变化《设计模式》一书曾提到：</p><blockquote><p>考虑你的设计中哪些地方可能变法，这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变，而是考虑你怎么样才能够在不重新设计的情况下进行改变。这里的关键在于封装发送变化的概念，这是许多设计模式的主题</p></blockquote><p>《设计模式》一书中归纳总结了23种设计模式，从意图上可将这些模式划分为 <code>创建型模式</code>、<code>结构型模式</code>和<code>行为型模式</code>。</p><p>通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统演变过程中，只需替换哪些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易；这样可以很大程度的保证程序的稳定性或可扩展性。</p><h2 id="面向对象基本原则"><a href="#面向对象基本原则" class="headerlink" title="面向对象基本原则"></a>面向对象基本原则</h2><h3 id="单一职责原则（Single-Responsibility-Prunciple）"><a href="#单一职责原则（Single-Responsibility-Prunciple）" class="headerlink" title="单一职责原则（Single Responsibility Prunciple）"></a>单一职责原则（Single Responsibility Prunciple）</h3><blockquote><p>一个类只允许有一个职责，即只有一个导致该类变更的原因。</p></blockquote><p>简单来说一个类只专注做一件事。并不是说一个类只有一个函数，而是说这个类中的函数所做的工作必须高度相关（高内聚）</p><p><strong>不过这个原则很容易违背，因为可能由于某种原因，原来功能单一的类需要被细化成颗粒更小的职责1跟职责2，不过这个拆的粒度可能因人而已，有时候并不需要拆的过细，不要成了为设计而设计。所以在每次迭代过程中可能需要重新梳理重构之前编写的代码，将不同的职责封装到不同的类或者模块中。</strong></p><p><strong>优点：</strong></p><ol><li>类的复杂性降低，实现什么职责都有清晰明确的定义,可读性提高，可维护性提高；</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li></ol><h3 id="开发关闭原则（Open-Closed-Principle）"><a href="#开发关闭原则（Open-Closed-Principle）" class="headerlink" title="开发关闭原则（Open Closed Principle）"></a>开发关闭原则（Open Closed Principle）</h3><blockquote><p>一个软件实体应该是可以扩展的，但是不可修改。</p></blockquote><p><strong>在软件开发过程中，永远不变的就是变化。因此当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象。</strong><br><strong>优点：</strong></p><ol><li>增加稳定性。</li><li>可扩展性高。</li></ol><h3 id="里氏替换原则-（Liskov-Substitution-Principle）"><a href="#里氏替换原则-（Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则 （Liskov Substitution Principle）"></a>里氏替换原则 （Liskov Substitution Principle）</h3><blockquote><p>子类必须能够替换掉它们的基类，而程序执行效果不变。</p></blockquote><p><strong>所有使用基类代码的地方，如果换成子类对象的时候还能够正常运行，则满足这个原则，否则就是继承关系有问题，应该废除两者的继承关系，这个原则可以用来判断我们的对象继承关系是否合理。</strong>尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法.</p><p><strong>优点：</strong></p><ol><li>提高代码的重用性；</li><li>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；</li><li>提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，很多开源框架的扩展接口都是通过继承父类来完成的；</li><li>可以用来判断我们的对象继承关系是否合理,约束继承在使用上的泛滥。</li></ol><p><strong>缺点：</strong></p><ol><li>降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；</li><li>增强了耦合性。当父类的常量、变量和方法被修改时，必需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大片的代码需要重构。</li></ol><h3 id="依赖倒置原则-（Dependence-Inversion-Principle）"><a href="#依赖倒置原则-（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒置原则 （Dependence Inversion Principle）"></a>依赖倒置原则 （Dependence Inversion Principle）</h3><blockquote><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p></blockquote><p>我们经常说“针对接口编程”，这里的接口就是抽象，我们应该依赖接口，而不是依赖具体的实现来编程。<br>假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖</p><p><strong>高低应该是从开发者当前的角度来看的，不过DIP原则从不同角度来看它都适合且需要被遵守。假如我们高层模块直接依赖于底层模块，带来的后果是每次底层模块改动，高层模块就会受到影响，整个系统就变得不稳定，这也违反了开放关闭原则。</strong></p><p> <strong>通常我们会通过引入中间层的方式来解决这个问题，这个中间层相当于一个抽象接口层，高层模块和底层模块都依赖于这个中间层来交互，这样只要中间抽象层保持不变，底层模块改变不会影响到高层模块，这就满足了开放关闭原则；而且假如高层模块跟底层模块同时处于开发阶段，这样有了中间抽象层之后，每个模块都可以针对这个抽象层的接口同时开发，高层模块就不需要等到底层模块开发完毕才能继续了。</strong></p><p><strong>优点：</strong> 通过抽象来搭建框架，建立类和类的关联，以减少类间的耦合性。而且以抽象搭建的系统要比以具体实现搭建的系统更加稳定，扩展性更高，同时也便于维护。</p><h3 id="接口隔离原则-（Interface-Segregation-Principle）"><a href="#接口隔离原则-（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则 （Interface Segregation Principle）"></a>接口隔离原则 （Interface Segregation Principle）</h3><blockquote><p>多个特定的客户端接口要好于一个通用性的总接口。</p></blockquote><p><strong>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</strong></p><p><strong>需要注意的是：</strong>接口的粒度也不能太小。如果过小，则会造成接口数量过多，使设计复杂化。<br><strong>优点：</strong> 避免同一个接口里面包含不同类职责的方法，接口责任划分更加明确，符合高内聚低耦合的思想。<br>接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><h3 id="迪米特法则-（Law-Of-Demeter）-或-最少知识原则（Least-Knowledge-Principle）"><a href="#迪米特法则-（Law-Of-Demeter）-或-最少知识原则（Least-Knowledge-Principle）" class="headerlink" title="迪米特法则 （Law Of Demeter） 或 最少知识原则（Least Knowledge Principle）"></a>迪米特法则 （Law Of Demeter） 或 最少知识原则（Least Knowledge Principle）</h3><blockquote><p>一个对象应该对其他对象有最少的了解;一个类应该对自己需要耦合或调用的类知道得最少。<br><strong>类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</strong><br><strong>优点：</strong></p><ol><li>降低复杂度；降低耦合度；增加稳定性。</li><li>减少类与类之间的关联程度，让类与类之间的协作更加直接。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是设计模式？&quot;&gt;&lt;a href=&quot;#什么是设计模式？&quot; class=&quot;headerlink&quot; title=&quot;什么是设计模式？&quot;&gt;&lt;/a&gt;什么是设计模式？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;模式&lt;/code&gt; 起源于建筑学。20世纪70年代，哈
      
    
    </summary>
    
      <category term="design patterns" scheme="https://owen027.github.io/categories/design-patterns/"/>
    
    
      <category term="Pattern intro" scheme="https://owen027.github.io/tags/Pattern-intro/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 学习</title>
    <link href="https://owen027.github.io/2019/07/05/nginx/"/>
    <id>https://owen027.github.io/2019/07/05/nginx/</id>
    <published>2019-07-05T03:12:21.000Z</published>
    <updated>2019-07-21T15:53:32.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-Nginx"><a href="#什么是-Nginx" class="headerlink" title="什么是 Nginx"></a>什么是 Nginx</h1><p>  Nginx 是一款轻量级高性能的web 和 反向代理服务器，类似于<code>Apache</code>，也是一个 IMAP/POP3/SMTP （电子邮件）代理服务器。，由俄罗斯程序设计师 <code>Igor Sysoev</code>开发；<br>在高连接并发的情况下，Nginx能够支持高达 50000 个并发连接数的响应，是 Apache 服务器不错的替代品。</p><p><strong>nginx做为HTTP服务器，有以下几项基本特性：</strong></p><pre><code>1. 处理静态文件，索引文件以及自动索引；打开文件描述符缓冲．2. FastCGI和反向代理加速(无缓存)，简单的负载均衡和容错．3. 模块化的结构。包括gzipping, byte ranges, chunked responses,以及 SSI-filter等filter。如果由FastCGI或其它代理服务器处理单页中存在的多个SSI，则这项处理可以并行运行，而不需要相互等待。4. 支持SSL 和 TLSSNI．</code></pre><p>Nginx支持热部署。它的启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。<br>nginx是异步的，多个连接（万级别）可以对应一个进程。 apache是同步多进程模型，一个连接对应一个进程；<br><strong>nginx的优势是处理静态请求，cpu内存使用率低，apache适合处理动态请求，所以现在一般前端用nginx作为反向代理抗住压力，apache 作为后端处理动态请求。</strong></p><p><strong>正向代理：</strong> 服务器代理客户端向服务端发送请求，并将数据分发给客户端，服务端无法知道客户端的信息<br><strong>反向代理：</strong> 服务器代理服务端接收客户端的请求，并分发给服务器（分布式部署），反向代理隐藏了服务器的信息。<br><strong>负载均衡：</strong>  客户端发送的、Nginx反向代理服务器接收到的请求数量，就是负载量。请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则，即代理服务器将请求按一定的规则分发的过程就是负载均衡。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>下载</strong><br><a href="http://nginx.org/en/download.html">点击进入官网下载</a> Windows版本,解压至 C盘</p><p><strong>启动</strong><br>双击 <code>nginx.exe</code> 或者 打开 CMD 进入 nginx 目录 输入 <code>start nginx</code>,如果启用防火墙，允许访问即可</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>须使用CMD 进入跟目录才能使用 nginx<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nginx -h //查看帮助</span><br><span class="line">nginx -v // 查看版本</span><br><span class="line">nginx -s stop  //停用</span><br><span class="line">nginx -s reload //重载配置，重启进程</span><br><span class="line">nginx -s reopen //重启日志</span><br></pre></td></tr></table></figure></p><h2 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="comment">#开启进程数 &lt;=CPU数   </span></span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"><span class="comment">#进程号保存文件  </span></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    <span class="comment">#每个进程最大连接数（最大连接=连接数x进程数）每个worker允许同时产生多少个链接，默认1024 </span></span><br><span class="line">    worker_connections  <span class="number">1024</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="comment">#文件扩展名与文件类型映射表  </span></span><br><span class="line">    include       mime.types;</span><br><span class="line">    <span class="comment">#默认文件类型  </span></span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#日志文件输出格式 这个位置相对于全局设置  </span></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#请求日志保存位置</span></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#打开发送文件 </span></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#连接超时时间  </span></span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#打开gzip压缩  </span></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="comment">#监听端口，默认是80端口  </span></span><br><span class="line">        <span class="keyword">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="comment">#监听域名 </span></span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line">        <span class="comment">#nginx访问日志放在logs/host.access.log下，并且使用main格式（可以自定义格式）</span></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#如果没有location更明确的匹配访问路径的话，访问请求都会被该location处理</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="comment">#root指定nginx的根目录为/usr/local/nginx/html  </span></span><br><span class="line">            root   html;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#默认访问文件，欢迎页先去html目录下找index.html，如果找不到再去找index.htm</span></span><br><span class="line">            <span class="keyword">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#错误页面及其返回地址，错误码为500、502、503、504都会返回50.html错误页面</span></span><br><span class="line">        error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">        <span class="comment">#location后面是"="的话，说明是精确匹配  </span></span><br><span class="line">        location = <span class="regexp">/50x.html &#123;</span></span><br><span class="line"><span class="regexp">            root   html;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line"><span class="regexp">        #</span></span><br><span class="line"><span class="regexp">        #location ~ \.php$ &#123;</span></span><br><span class="line"><span class="regexp">        #    proxy_pass   http:/</span><span class="regexp">/127.0.0.1;</span></span><br><span class="line"><span class="regexp">        #&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line"><span class="regexp">        #</span></span><br><span class="line"><span class="regexp">        #location ~ \.php$ &#123;</span></span><br><span class="line"><span class="regexp">        #    root           html;</span></span><br><span class="line"><span class="regexp">        #    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line"><span class="regexp">        #    fastcgi_index  index.php;</span></span><br><span class="line"><span class="regexp">        #    fastcgi_param  SCRIPT_FILENAME  /scripts</span>$fastcgi_script_name;</span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx's one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要监听多个端口和域名 可配置多个 <code>server</code>。</p><p><strong>参考文章:</strong><br><a href="http://www.nginx.cn/doc/">Nginx 中文文档</a><br><a href="https://www.cnblogs.com/wcwnina/p/8728391.html">Nginx 相关介绍</a><br><a href="https://www.jianshu.com/p/5eab0f83e3b4">深入浅出Nginx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是-Nginx&quot;&gt;&lt;a href=&quot;#什么是-Nginx&quot; class=&quot;headerlink&quot; title=&quot;什么是 Nginx&quot;&gt;&lt;/a&gt;什么是 Nginx&lt;/h1&gt;&lt;p&gt;  Nginx 是一款轻量级高性能的web 和 反向代理服务器，类似于&lt;code&gt;A
      
    
    </summary>
    
      <category term="Nginx" scheme="https://owen027.github.io/categories/Nginx/"/>
    
    
      <category term="nginx" scheme="https://owen027.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>for,for...of, for...in, array iteration 运行速度测试</title>
    <link href="https://owen027.github.io/2019/07/03/performance/"/>
    <id>https://owen027.github.io/2019/07/03/performance/</id>
    <published>2019-07-03T14:35:43.000Z</published>
    <updated>2019-07-29T15:43:17.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="for-for…of-for…in-array-iteration-运行速度测试"><a href="#for-for…of-for…in-array-iteration-运行速度测试" class="headerlink" title="for,for…of, for…in, array iteration 运行速度测试"></a>for,for…of, for…in, array iteration 运行速度测试</h1><ul><li>由于不同浏览器，不同版本性能不一，且控制台本质是是套用了一大堆<a href="https://www.zhihu.com/question/29352114/answer/44050599">eval</a>，沙盒化程度高,所以需使用<a href="https://nodejs.org/en/">node</a>环境测试来提高准确性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 准备待测数组</span></span><br><span class="line"><span class="keyword">const</span> NUM = <span class="number">1e7</span>;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(NUM).fill(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// for 测试</span></span><br><span class="line"><span class="keyword">let</span> arr1 =[];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'for'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  arr1.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'for'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome/75.0.3770.100 Safari/537.36 环境</span></span><br><span class="line"><span class="comment">//VM1324:10 for: 576.733154296875ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// node v10.11.0 环境</span></span><br><span class="line"><span class="comment">// for:  412.087ms</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="for-几种写法"><a href="#for-几种写法" class="headerlink" title="for 几种写法"></a>for 几种写法</h2><ul><li><p><strong>常规写法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = []</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'one'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++ )&#123;</span><br><span class="line">    arr1.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'one'</span>)</span><br></pre></td></tr></table></figure><p>   数组长度是会动态变化，每次循环会重新计算length长度，可能会出现死循环</p></li><li><p><strong>cache arr.length</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++ )&#123;</span><br><span class="line">     arr1.push(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   缓存length 值，无需重新计算length</p></li><li><p><strong>倒序</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">     arr1.push(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   比第二种方法更简洁</p></li><li><p><strong>倒叙简洁版</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length<span class="number">-1</span>; i--;)&#123;</span><br><span class="line">     arr1.push(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  两个分号之间的表达式为 true 会一直执行直到 判断为 false (i = 0)</p></li><li><p><strong>正序简洁版</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len;len = arr[i++]; )&#123;</span><br><span class="line">     arr1.push(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   当 i 大于等于数组长度或arr[i++]值为false时 将停指循环，同时由于arr.length动态变化时可能会造成死循环</p></li></ul><h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr)&#123;</span><br><span class="line">     arr1.push(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>es6推出的迭代器，最简洁，可以是用 break，continue和return 终止循环</p><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">     arr1.push(arr[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for…in 一般用于遍历对象，他会将本身属性和原型链上的属性（除系统内置属性）全部遍历出来即便是不可枚举属性（enumerable:false), 可以通过 <code>items.hasOwnProperty</code>来遍历本身属性,由于查询到自己的原型链上，所以性能方面比较差</p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    arr1.push(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>数组的迭代方法，没有返回值</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  arr1.push(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>浅拷贝原数组，并且返回一个新数组</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><table><thead><tr><th>测试次数</th><th>常规for</th><th>cache for</th><th>倒序 for</th><th>倒叙简版 for</th><th>正序简版 for</th><th>for..of</th><th>for..in</th><th>forEach</th><th>map</th></tr></thead><tbody><tr><td>1</td><td>542.121ms</td><td>573.618ms</td><td>764.181ms</td><td>755.961ms</td><td>571.464ms</td><td>945.199ms</td><td>4077.020ms</td><td>625.859ms</td><td>3573.946ms</td></tr><tr><td>2</td><td>430.008ms</td><td>541.933ms</td><td>524.474ms</td><td>668.276ms</td><td>553.475ms</td><td>897.442ms</td><td>4402.246ms</td><td>605.271ms</td><td>2732.859ms</td></tr><tr><td>3</td><td>409.531ms</td><td>661.765ms</td><td>534.167ms</td><td>655.481ms</td><td>600.939ms</td><td>1141.093ms</td><td>3806.704ms</td><td>584.712ms</td><td>2779.192ms</td></tr><tr><td>4</td><td>412.972ms</td><td>643.868ms</td><td>536.026ms</td><td>674.081ms</td><td>725.149ms</td><td>930.655ms</td><td>3201.387ms</td><td>599.780ms</td><td>3152.499ms</td></tr><tr><td>5</td><td>417.034ms</td><td>624.323ms</td><td>520.674ms</td><td>799.568ms</td><td>574.713ms</td><td>943.449ms</td><td>3261.512ms</td><td>587.182ms</td><td>2954.195ms</td></tr><tr><td>6</td><td>525.771ms</td><td>955.737ms</td><td>526.208ms</td><td>771.443ms</td><td>531.962ms</td><td>954.199ms</td><td>4351.009ms</td><td>608.264ms</td><td>2888.752ms</td></tr><tr><td>7</td><td>498.039ms</td><td>602.703ms</td><td>555.588ms</td><td>531.464ms</td><td>541.599ms</td><td>916.678ms</td><td>3264.334ms</td><td>596.168ms</td><td>2834.663ms</td></tr><tr><td>8</td><td>431.694ms</td><td>523.381ms</td><td>544.974ms</td><td>527.472ms</td><td>517.833ms</td><td>1049.283ms</td><td>3744.972ms</td><td>600.286ms</td><td>3467.499ms</td></tr><tr><td>9</td><td>417.521ms</td><td>518.093ms</td><td>547.404ms</td><td>611.024ms</td><td>594.503ms</td><td>767.059ms</td><td>4979.348ms</td><td>601.420ms</td><td>3638.023ms</td></tr><tr><td>10</td><td>424.806ms</td><td>557.961ms</td><td>535.541ms</td><td>837.561ms</td><td>541.882ms</td><td>772.686ms</td><td>3284.424ms</td><td>602.443ms</td><td>3599.642ms</td></tr><tr><td>11</td><td>409.402ms</td><td>521.131ms</td><td>534.265ms</td><td>517.709ms</td><td>551.397ms</td><td>752.101ms</td><td>3228.123ms</td><td>629.625ms</td><td>3535.545ms</td></tr><tr><td>12</td><td>425.362ms</td><td>532.882ms</td><td>406.637ms</td><td>522.287ms</td><td>570.259ms</td><td>914.135ms</td><td>3449.256ms</td><td>800.857ms</td><td>3429.123ms</td></tr><tr><td>平均值</td><td>439.2738ms</td><td>578.3565ms</td><td>553.1468ms</td><td>651.7057ms</td><td>507.8718ms</td><td>909.0785ms</td><td>3,686.96ms</td><td>605.6298ms</td><td>3,221.5056ms</td></tr><tr><td>堆值差</td><td>357245536 Byte</td><td>357245808 Byte</td><td>357245624 Byte</td><td>357245872 Byte</td><td>357246824 Byte</td><td>199268080 Byte</td><td>757187208 Byte</td><td>357244456 Byte</td><td>437247640 Byte</td></tr></tbody></table><p><strong>测试总结</strong></p><ol><li><strong>运行效率:</strong> <code>常规for</code> &gt; <code>正序简版 for</code>&gt; <code>倒序 for</code> &gt; <code>cache for</code> &gt; <code>倒叙简版 for</code>&gt; <code>forEach</code> &gt; <code>for..of</code>    &gt; <code>map</code> &gt; <code>for..in</code></li><li>几种普通 for 循环占用内存相差不大, 而 <code>for..of</code> 占用运行内存最小</li><li><code>for..in</code> 性能最差，内存占用高，速度很慢</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;for-for…of-for…in-array-iteration-运行速度测试&quot;&gt;&lt;a href=&quot;#for-for…of-for…in-array-iteration-运行速度测试&quot; class=&quot;headerlink&quot; title=&quot;for,for…of, 
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://owen027.github.io/categories/JavaScript/"/>
    
    
      <category term="Iteration" scheme="https://owen027.github.io/tags/Iteration/"/>
    
  </entry>
  
</feed>
