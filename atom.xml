<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Owen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://owen027.github.io/"/>
  <updated>2019-12-25T16:06:01.996Z</updated>
  <id>https://owen027.github.io/</id>
  
  <author>
    <name>Owen Gao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>uniapp的路由配置</title>
    <link href="https://owen027.github.io/2019/12/25/uniappPagesConfigs/"/>
    <id>https://owen027.github.io/2019/12/25/uniappPagesConfigs/</id>
    <published>2019-12-25T06:36:18.000Z</published>
    <updated>2019-12-25T16:06:01.996Z</updated>
    
    <content type="html"><![CDATA[<p><code>uniapp</code>通过根目录中的<code>pages.json</code>文件决定页面文件的路径、窗口样式、原生导航栏、底部原生tarBar等</p><h2 id="配置像列表"><a href="#配置像列表" class="headerlink" title="配置像列表"></a>配置像列表</h2><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">是否必填</th><th style="text-align:center">功能</th><th style="text-align:center">兼容</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://uniapp.dcloud.io/collocation/pages?id=globalstyle">globalStyle</a></td><td style="text-align:center">Object</td><td style="text-align:center">否</td><td style="text-align:center">设置默认页面的窗口表现,可设置应用的状态栏、导航条、标题、窗口背景色等。</td></tr><tr><td style="text-align:center"><a href="https://uniapp.dcloud.io/collocation/pages?id=pages">pages</a></td><td style="text-align:center">Object,Array</td><td style="text-align:center">是</td><td style="text-align:center">设置页面的路径及窗口表现</td></tr><tr><td style="text-align:center"><a href="https://uniapp.dcloud.io/collocation/pages?id=easycom">easycom</a></td><td style="text-align:center">Object</td><td style="text-align:center">否</td><td style="text-align:center">组件自动引入规则</td><td style="text-align:center">2.5.0+</td></tr><tr><td style="text-align:center"><a href="https://uniapp.dcloud.io/collocation/pages?id=tabBar">tabBar</a></td><td style="text-align:center">Object</td><td style="text-align:center">否</td><td style="text-align:center">设置底部tab的表现</td></tr><tr><td style="text-align:center"><a href="https://uniapp.dcloud.io/collocation/pages?id=condition">condition</a></td><td style="text-align:center">Object</td><td style="text-align:center">否</td><td style="text-align:center">启动模式配置</td></tr><tr><td style="text-align:center"><a href="https://uniapp.dcloud.io/collocation/pages?id=subPackages">subPackages</a></td><td style="text-align:center">Object,Array</td><td style="text-align:center">否</td><td style="text-align:center">分包加载配置</td></tr><tr><td style="text-align:center"><a href="https://uniapp.dcloud.io/collocation/pages?id=preloadRule">preloadRule</a></td><td style="text-align:center">Object</td><td style="text-align:center">否</td><td style="text-align:center">分包预下载规则</td><td style="text-align:center">微信小程序</td></tr><tr><td style="text-align:center"><a href="https://uniapp.dcloud.io/collocation/pages?id=workers">workers</a></td><td style="text-align:center">Scring</td><td style="text-align:center">否</td><td style="text-align:center">Worker 代码放置目录</td><td style="text-align:center">微信小程序</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"pages"</span>: [&#123; <span class="comment">// pages节点的第一项为应用入口页（即首页）,应用中新增/减少页面，都需要对 pages 数组进行修改,文件名不需要写后缀，框架会自动寻找路径下的页面资源</span></span><br><span class="line">        <span class="string">"path"</span>: <span class="string">"pages/component/index"</span>, <span class="comment">// 配置页面路径</span></span><br><span class="line">        <span class="string">"style"</span>: &#123; <span class="comment">// 配置页面窗口表现,用于设置对应页面的状态栏、导航条、标题、窗口背景色等。 其配置项与 globalStyle 一致，此配置会覆盖 globalStyle</span></span><br><span class="line">            <span class="string">"disableScroll"</span>: <span class="literal">false</span>,<span class="comment">//禁用滚动 全局中无此设置 //仅支持微信小程序（iOS）、百度小程序（iOS）</span></span><br><span class="line">            <span class="string">"navigationBarShadow"</span>:&#123;</span><br><span class="line">                <span class="comment">//导航栏阴影</span></span><br><span class="line">                <span class="string">"colorType"</span>:<span class="string">"grey"</span> <span class="comment">// 支持颜色：grey、blue、green、orange、red、yellow</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">"path"</span>: <span class="string">"pages/API/index"</span>,</span><br><span class="line">        <span class="string">"style"</span>: &#123;</span><br><span class="line">            <span class="string">"navigationBarTitleText"</span>: <span class="string">"接口"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">"path"</span>: <span class="string">"pages/component/view/index"</span>,</span><br><span class="line">        <span class="string">"style"</span>: &#123;</span><br><span class="line">            <span class="string">"navigationBarTitleText"</span>: <span class="string">"view"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">"condition"</span>: &#123; <span class="comment">//模式配置，仅开发期间生效</span></span><br><span class="line">        <span class="string">"current"</span>: <span class="number">0</span>, <span class="comment">//当前激活的模式（list 的索引项）</span></span><br><span class="line">        <span class="string">"list"</span>: [&#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"test"</span>, <span class="comment">//模式名称</span></span><br><span class="line">            <span class="string">"path"</span>: <span class="string">"pages/component/view/index"</span> <span class="comment">//启动页面，必选</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"globalStyle"</span>: &#123;</span><br><span class="line">        <span class="string">"navigationBarTextStyle"</span>: <span class="string">"black"</span>, <span class="comment">// 导航栏标题颜色及状态栏前景颜色，仅支持 black/white</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"navigationBarTitleText"</span>: <span class="string">"演示"</span>, <span class="comment">// 导航栏标题文字内容</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"navigationBarBackgroundColor"</span>: <span class="string">"#F8F8F8"</span>, <span class="comment">// 导航栏背景色</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"backgroundColor"</span>: <span class="string">"#F8F8F8"</span>,</span><br><span class="line">        </span><br><span class="line">        <span class="string">"navigationStyle"</span>:<span class="string">"default"</span>, <span class="comment">// 导航栏样式，仅支持 default/custom。custom即取消默认的原生导航栏 //仅支持 微信小程序 7.0+、百度小程序、H5、App（2.0.3+）</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"backgroundColor"</span>:<span class="string">"#ffffff"</span>, <span class="comment">//窗口背景色 //仅支持微信小程序</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"backgroundTextStyle"</span>:<span class="string">"dark"</span>, <span class="comment">// 下拉loading样式，仅支持dark/light //仅支持微信小程序</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"enablePullDownRefresh"</span>:<span class="literal">false</span>,<span class="comment">// 是否开启下拉刷新</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"onReachBottomDistance"</span>:<span class="number">50</span>,<span class="comment">// 上拉触底事件触发时距离页面底部距离，单位仅支持px</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"backgroundColorTop"</span>:<span class="string">"#ffffff"</span>,<span class="comment">// 顶部窗口的背景色（bounce回弹区域）//仅支持iOS</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"backgroundColorBottom"</span>:<span class="string">"#ffffff"</span>,<span class="comment">// 底部部窗口的背景色（bounce回弹区域）//仅支持iOS</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"titleImage"</span>:<span class="string">""</span>, <span class="comment">// 导航栏图片地址（替换当前文字标题），支付宝小程序内必须使用https的图片链接地址 //仅支持支付宝小程序、H5、APP</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"transparentTitle"</span>:<span class="string">"none"</span>, <span class="comment">// 导航栏透明设置。支持 always 一直透明 / auto 滑动自适应 / none 不透明//仅支持支付宝小程序、H5、APP</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"titlePenetrate"</span>:<span class="string">"NO"</span>,<span class="comment">// 导航栏点击穿透</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"pageOrientation"</span>:<span class="string">"portrait"</span>, <span class="comment">// 横屏配置，屏幕旋转设置，仅支持 auto/portrait/landscape // 仅支持App 2.4.7+、微信小程序</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"animationType"</span>:<span class="string">"pop-in"</span>, <span class="comment">// 窗口显示的动画效果 // 仅支持App</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"animationDuration"</span>:<span class="number">300</span>, <span class="comment">// 窗口动画的持续时间 // 仅支持App</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"app-plus"</span>:&#123;<span class="comment">//编译到APP 平台的特定样式 详情见uniapp官网 https://uniapp.dcloud.io/collocation/pages?id=app-plus // 仅支持App</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">"h5"</span>:&#123;<span class="comment">//编译到h5 平台的特定样式 // 仅支持h5</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">"mp-alipay"</span>:&#123;<span class="comment">//编译到mp-alipay 平台的特定样式 // 仅支持mp-alipay 支付包</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">"mp-weixin"</span>:&#123;<span class="comment">//编译到mp-weixin平台的特定样式 // 仅支持微信小程序</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">"mp-baidu"</span>:&#123;<span class="comment">//编译到"mp-baidu 平台的特定样式 // 仅支持百度小程序</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">"mp-toutiao"</span>:&#123;<span class="comment">//编译到mp-toutiao 平台的特定样式 // 仅支持字节跳动小程序</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">"mp-qq"</span>:&#123;<span class="comment">//编译到mp-qq 平台的特定样式 // 仅支持QQ小程序</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">"usingComponents"</span>:&#123; <span class="comment">// 引用小程序组件</span></span><br><span class="line">            <span class="string">"collapse-tree-item"</span>:<span class="string">"/components/collapse-tree-item"</span></span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="string">"pageOrientation"</span>: <span class="string">"portrait"</span><span class="comment">//横屏配置，全局屏幕旋转设置(仅 APP/微信/QQ小程序)，支持 auto / portrait / landscape</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"tabBar"</span>: &#123;</span><br><span class="line">        <span class="string">"color"</span>: <span class="string">"#7A7E83"</span>,</span><br><span class="line">        <span class="string">"selectedColor"</span>: <span class="string">"#3cc51f"</span>,</span><br><span class="line">        <span class="string">"borderStyle"</span>: <span class="string">"black"</span>,</span><br><span class="line">        <span class="string">"backgroundColor"</span>: <span class="string">"#ffffff"</span>,</span><br><span class="line">        <span class="string">"height"</span>: <span class="string">"50px"</span>,</span><br><span class="line">        <span class="string">"fontSize"</span>: <span class="string">"10px"</span>,</span><br><span class="line">        <span class="string">"iconWidth"</span>: <span class="string">"24px"</span>,</span><br><span class="line">        <span class="string">"spacing"</span>: <span class="string">"3px"</span>,</span><br><span class="line">        <span class="string">"list"</span>: [&#123;</span><br><span class="line">            <span class="string">"pagePath"</span>: <span class="string">"pages/component/index"</span>,</span><br><span class="line">            <span class="string">"iconPath"</span>: <span class="string">"static/image/icon_component.png"</span>,</span><br><span class="line">            <span class="string">"selectedIconPath"</span>: <span class="string">"static/image/icon_component_HL.png"</span>,</span><br><span class="line">            <span class="string">"text"</span>: <span class="string">"组件"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="string">"pagePath"</span>: <span class="string">"pages/API/index"</span>,</span><br><span class="line">            <span class="string">"iconPath"</span>: <span class="string">"static/image/icon_API.png"</span>,</span><br><span class="line">            <span class="string">"selectedIconPath"</span>: <span class="string">"static/image/icon_API_HL.png"</span>,</span><br><span class="line">            <span class="string">"text"</span>: <span class="string">"接口"</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="string">"midButton"</span>: &#123;</span><br><span class="line">            <span class="string">"width"</span>: <span class="string">"80px"</span>,</span><br><span class="line">            <span class="string">"height"</span>: <span class="string">"50px"</span>,</span><br><span class="line">            <span class="string">"text"</span>: <span class="string">"文字"</span>,</span><br><span class="line">            <span class="string">"iconPath"</span>: <span class="string">"static/image/midButton_iconPath.png"</span>,</span><br><span class="line">            <span class="string">"iconWidth"</span>: <span class="string">"24px"</span>,</span><br><span class="line">            <span class="string">"backgroundImage"</span>: <span class="string">"static/image/midButton_backgroundImage.png"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="string">"easycom"</span>: &#123;</span><br><span class="line">    <span class="string">"uni-(.*)"</span>: <span class="string">"@/components/uni-$1/uni-$1.vue"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义导航栏使用注意事项"><a href="#自定义导航栏使用注意事项" class="headerlink" title="自定义导航栏使用注意事项"></a>自定义导航栏使用注意事项</h3><p>当 <code>navigationStyle&quot;:custom</code>或<code>titleNView:false</code>时，原生导航栏不显示同时需注意：</p><ul><li>非H5段，手机顶部状态栏区域会被页面内容覆盖。<code>uniapp</code>提供状态栏css变量，可使用view占用其位置</li><li>如果原生导航不满足要求，可使用自定义导航栏 <a href="https://ext.dcloud.net.cn/plugin?id=52">NavBar</a></li><li>导航栏搭配原生下拉刷新问题：微信小程序ios端需要拉更长才能看到下来刷新，Android则从屏幕底部下拉，无法从状态栏下拉，如需，请前端模拟， <a href="https://ext.dcloud.net.cn/plugin?id=343">推荐插件</a></li><li>非H5段，前端导航盖不住原生组件，如页面有viedo,map等原生组件，滚动时会覆盖导航栏，小程序可使用<code>cover-view</code>来解决，APP可使用titleNView 或subNVue</li><li>前端组件渲染不如原生导航，原生导航可保证动画期间不白屏</li><li>页面禁用原生导航后想，改变状态栏前景字体，可设置<code>navigationBarTextStyle</code>,部分低端手机不支持</li></ul><p>鉴于以上问题，原生导航等满足业务需求，使用原生导航，甚至可牺牲一些不重要的需求。<a href="https://ask.dcloud.net.cn/article/34921">更多详情</a></p><h3 id="easycom-配置说明"><a href="#easycom-配置说明" class="headerlink" title="easycom 配置说明"></a>easycom 配置说明</h3><ul><li>通过正则匹配来自动引入组件</li><li>此方式引入的组件无需在页面内<code>import</code>,也无需在<code>components</code>中声明，即可在页面中使用</li><li>组件名完全一致的情况下，优先级低于手动</li><li>修改easycom 不会重新编译，须手动改动页面触发</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"easycom"</span>: &#123;</span><br><span class="line">  <span class="string">"uni-(.*)"</span>: <span class="string">"@/components/uni-$1/uni-$1.vue"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tabBar-配置说明"><a href="#tabBar-配置说明" class="headerlink" title="tabBar 配置说明"></a>tabBar 配置说明</h3><ul><li>position为top时 不显示ICON, top值仅支持微信小程序</li><li>tabBar中list是数组最少配置2个，最多5个tab,按数组顺序排列</li><li>切换第一次加载时可能渲染不及时，可在每个Tabbar页面的onLoad生命周期中先弹出一个loading</li><li>页面出现过后，保存在内存中，切换tabbar,之后触发onShow,不在触发onLoad</li></ul><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">是否必选</th><th style="text-align:center">值类型</th><th style="text-align:center">默认值</th><th style="text-align:center">描述</th><th style="text-align:center">平台差异</th></tr></thead><tbody><tr><td style="text-align:center">color</td><td style="text-align:center">是</td><td style="text-align:center">HexColor</td><td style="text-align:center"></td><td style="text-align:center">tab字体默认颜色</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">selectedColor</td><td style="text-align:center">是</td><td style="text-align:center">HexColor</td><td style="text-align:center"></td><td style="text-align:center">选中颜色</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">backgroundColor</td><td style="text-align:center">是</td><td style="text-align:center">HexColor</td><td style="text-align:center"></td><td style="text-align:center">背景色</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">borderStyle</td><td style="text-align:center">否</td><td style="text-align:center">String</td><td style="text-align:center">black</td><td style="text-align:center">边框颜色仅支持black/white</td><td style="text-align:center">App最新版支持其它颜色</td></tr><tr><td style="text-align:center">list</td><td style="text-align:center">是</td><td style="text-align:center">Array</td><td style="text-align:center"></td><td style="text-align:center">tab列表最少2，最多5</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">position</td><td style="text-align:center">否</td><td style="text-align:center">String</td><td style="text-align:center">bottom</td><td style="text-align:center">位置 bottom\top</td><td style="text-align:center">仅微信支持top</td></tr><tr><td style="text-align:center">fontSize</td><td style="text-align:center">否</td><td style="text-align:center">String</td><td style="text-align:center">10px</td><td style="text-align:center">字体大小</td><td style="text-align:center">App2.3.4+</td></tr><tr><td style="text-align:center">iconWidth</td><td style="text-align:center">否</td><td style="text-align:center">String</td><td style="text-align:center">24px</td><td style="text-align:center">icon默认宽度</td><td style="text-align:center">App2.3.4+</td></tr><tr><td style="text-align:center">spacing</td><td style="text-align:center">否</td><td style="text-align:center">String</td><td style="text-align:center">3px</td><td style="text-align:center">图标与文字间间距</td><td style="text-align:center">App2.3.4+</td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">否</td><td style="text-align:center">String</td><td style="text-align:center">50px</td><td style="text-align:center">默认高度</td><td style="text-align:center">App2.3.4+</td></tr><tr><td style="text-align:center">mindButton</td><td style="text-align:center">否</td><td style="text-align:center">Object</td><td style="text-align:center"></td><td style="text-align:center">中间按钮仅在list为偶数时生效</td><td style="text-align:center">App2.3.4+</td></tr></tbody></table><h4 id="list-属性说明"><a href="#list-属性说明" class="headerlink" title="list 属性说明"></a>list 属性说明</h4><p>list数组中的子项都为对象，其属性为：<br>|属性|值类型|是否必选|说明<br>|:-:|:-:|:-:|:-:|<br>|pagePath|String|是|页面路径，须在pages中选定义|<br>|text|String|是|tab是按钮文字，H5、5+APP平台非必填|<br>|iconPath|String|否|图片路径，大小40kB,尺寸81*81，只支持静态图片，不支持字体图|<br>|selectedIconPath|String|否|选中时的图片|</p><h4 id="midButton"><a href="#midButton" class="headerlink" title="midButton"></a>midButton</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;uniapp&lt;/code&gt;通过根目录中的&lt;code&gt;pages.json&lt;/code&gt;文件决定页面文件的路径、窗口样式、原生导航栏、底部原生tarBar等&lt;/p&gt;
&lt;h2 id=&quot;配置像列表&quot;&gt;&lt;a href=&quot;#配置像列表&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="uniappPages" scheme="https://owen027.github.io/tags/uniappPages/"/>
    
  </entry>
  
  <entry>
    <title>uniapp 开发文档</title>
    <link href="https://owen027.github.io/2019/12/24/uniappStudy/"/>
    <id>https://owen027.github.io/2019/12/24/uniappStudy/</id>
    <published>2019-12-24T02:33:23.000Z</published>
    <updated>2019-12-25T15:58:07.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><p><code>uni-app</code>是基于vueJS框架开发的微端应用框架，可一套代码跨ios\Android\H5\小程序等多个平台运行</p><p>可通过官方开发的<a href="https://www.dcloud.io/hbuilderx.html">HBuilderX</a> IDE 创建<code>uni-app</code>项目，开箱即用，可<a href="https://uniapp.dcloud.io/quickstart">快速上手</a>。</p><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><ul><li>页面文件遵循Vue 单文件组件<a href="https://vue-loader.vuejs.org/zh/spec.html">规范</a>，数据绑定及数据处理支持<code>vue</code>规范</li><li>组件标签靠近小程序<a href="https://uniapp.dcloud.io/component/README">规范</a></li><li>接口API靠近微信小程序<a href="https://uniapp.dcloud.io/api/README">规范</a>，将前缀<code>wx</code>改为<code>uni</code></li><li>推荐使用<code>Flex</code>布局</li></ul><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>┌─common                uni-app公共资源目录<br>│  └─com-a.js<br>│  └─com-a.css<br>┌─components            uni-app组件目录<br>│  └─comp-a.vue         可复用的a组件<br>├─hybrid                存放本地网页的目录，<a href="https://uniapp.dcloud.io/component/web-view">详见</a><br>├─platforms             存放各平台专用页面的目录，<a href="https://uniapp.dcloud.io/platform">详见</a><br>├─pages                 业务页面文件存放的目录<br>│  ├─index<br>│  │  └─index.vue       index页面<br>│  └─list<br>│     └─list.vue        list页面<br>├─static                存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此<br>├─wxcomponents          存放小程序组件的目录，<a href="https://uniapp.dcloud.io/frame?id=%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E6%94%AF%E6%8C%81">详见</a><br>├─main.js               Vue初始化入口文件<br>├─App.vue               应用配置，用来配置App全局样式以及监听 应用生命周期 <a href="https://uniapp.dcloud.io/frame?id=%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">详见</a><br>├─manifest.json         配置应用名称、appid、logo、版本等打包信息，<a href="https://uniapp.dcloud.io/collocation/manifest">详见</a><br>└─pages.json            配置页面路由、导航条、选项卡等页面类信息，<a href="https://uniapp.dcloud.io/collocation/pages">详见</a></p><blockquote><p>static中的 js文件不会被编译，如果使用ES6将会报错<br>css、less等资源放入公共资源目录中</p></blockquote><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h3><p>应用生命周期仅只 <code>App.vue</code>中可监听</p><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">onLaunch</td><td style="text-align:center">初始化项目完成时触发（仅触发一次）</td></tr><tr><td style="text-align:center">onShow</td><td style="text-align:center">启动项目或从后台进入前台显示时触发</td></tr><tr><td style="text-align:center">onHide</td><td style="text-align:center">从前台隐藏至后台时触发</td></tr><tr><td style="text-align:center">onError</td><td style="text-align:center">程序出错时触发</td></tr><tr><td style="text-align:center">onuniViewMessage</td><td style="text-align:center">对 nvue 页面发送数据进行监听 <a href="https://uniapp.dcloud.io/use-weex?id=nvue-%e5%90%91-vue-%e9%80%9a%e8%ae%af">详情</a></td></tr></tbody></table><h3 id="页面生命周期-详情"><a href="#页面生命周期-详情" class="headerlink" title="页面生命周期 详情"></a>页面生命周期 <a href="https://uniapp.dcloud.io/frame?id=%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">详情</a></h3><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">onLoad</td><td style="text-align:center">监听页面加载，可接受上个页面传递的数据，param[Object], <a href="https://uniapp.dcloud.io/api/router?id=navigateto">详情</a></td></tr><tr><td style="text-align:center">onShow</td><td style="text-align:center">监听页面显示，每次出现在屏幕时触发</td></tr><tr><td style="text-align:center">onReady</td><td style="text-align:center">页面初次渲染完成时触发，可能会在页面进入动画完成前触发</td></tr><tr><td style="text-align:center">onHide</td><td style="text-align:center">从隐藏至后台时触发</td></tr><tr><td style="text-align:center">onUnload</td><td style="text-align:center">监听页面卸载</td></tr><tr><td style="text-align:center">onResize</td><td style="text-align:center">监听窗口变化 仅支持 5+App、微信小程序</td></tr><tr><td style="text-align:center">onPullDownRefresh</td><td style="text-align:center">监听用户下拉动作，<a href="https://uniapp.dcloud.io/api/ui/pulldown">详情</a></td></tr><tr><td style="text-align:center">onReachBottom</td><td style="text-align:center">监听页面上拉触底事件</td></tr><tr><td style="text-align:center">onTabItemTap</td><td style="text-align:center">点击Tab触发，param[Object]：( &nbsp;{index:String,pagePath:String,text:String} &nbsp;)。仅支持 微信小程序、百度小程序、H5、5+App（自定义组件模式）</td></tr><tr><td style="text-align:center">onShareAppMessage</td><td style="text-align:center">用户点击右上角分享触发  仅支持 微信小程序、百度小程序、头条小程序、支付宝小程序</td></tr><tr><td style="text-align:center">onPageScroll</td><td style="text-align:center">监听页面滚动，param[Object]：（ &nbsp; {scrollTop:Number} 页面在垂直方向已滚动的距离（单位px） ）</td></tr><tr><td style="text-align:center">onNavigationBarButtonTap</td><td style="text-align:center">监听原生标题栏按钮点击事件，param[Object]:(&nbsp; {index:Number} &nbsp;) 原生标题栏按钮数组的下标 仅支持     5+ App、H5</td></tr><tr><td style="text-align:center">onBackPress</td><td style="text-align:center">监听页面返回，event对象为 {from:backbutton,navigateBack},backbutton:来源于左上角按钮或android返回键，navigateBack:来源于uni.navigateBack。<a href="https://ask.dcloud.net.cn/article/35120">详情</a> 仅支持     5+ App、H5</td></tr><tr><td style="text-align:center">onNavigationBarSearchInputChanged</td><td style="text-align:center">监听原生标题栏搜索输入框内容变化，param[Object] 仅支持     5+ App、H5</td></tr><tr><td style="text-align:center">onNavigationBarSearchInputConfirmed</td><td style="text-align:center">监听原生标题栏搜索输入框搜索事件，点击软键盘上的搜索按钮，param[Object] 仅支持     5+ App、H5</td></tr><tr><td style="text-align:center">onNavigationBarSearchInputClicked</td><td style="text-align:center">监听原生标题栏搜索输入框点击事件，param[Object] 仅支持     5+ App、H5</td></tr></tbody></table><ul><li>onTabItemTap 常用于点击当前tabItem,滚动或刷新当前页面。</li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p><code>uni-app</code> 的路由全权由框架统一管理，通过<code>pages.json</code>配置每个路由页面路径及样式，不支持 <code>vueRouter</code><br>其路由有两种方式可跳转：使用 <a href="https://uniapp.dcloud.io/component/navigator">navigation</a> 组件跳转、调用<a href="https://uniapp.dcloud.io/api/router">API</a>跳转<br>框架是以栈的形式管理所有页面，当路由切换时，页面栈的表现详见<a href="https://uniapp.dcloud.io/frame?id=%e9%a1%b5%e9%9d%a2%e6%a0%88">详情</a></p><h2 id="运行环境的判断"><a href="#运行环境的判断" class="headerlink" title="运行环境的判断"></a>运行环境的判断</h2><ul><li><p>判断开发生产环境（process.env.NODE_ENV）<a href="https://uniapp.dcloud.io/frame?id=%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e5%92%8c%e7%94%9f%e4%ba%a7%e7%8e%af%e5%a2%83">详情</a></p></li><li><p>判断平台通过编辑条件判断编译出包后的代码<a href="https://uniapp.dcloud.io/platform">详情</a>,通过API <code>uni.getSystemInfoSync().platform</code> 判断客户端环境 android/ios/devtools （小程序）</p></li></ul><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="单位-详见"><a href="#单位-详见" class="headerlink" title="单位 详见"></a>单位 <a href="https://uniapp.dcloud.io/frame?id=%e9%a1%b5%e9%9d%a2%e6%a0%b7%e5%bc%8f%e4%b8%8e%e5%b8%83%e5%b1%80">详见</a></h3><p><code>uni-app</code>支持通用单位<code>px</code>,<code>rpx</code><br><code>px</code>：固定的屏幕像素<br><code>rpx</code>：响应式像素，是相对于基准宽度的单位，可以根据屏幕宽度进行自适应，<code>uni-app</code> 规定屏幕基准宽度 750rpx。转化公式（750 * 元素在设计稿中的宽度 / 设计稿基准宽度）</p><ul><li>rpx和宽度相关，屏幕越框，实际像素越大，它不支持动态横竖屏切换计算，如果使用<code>rpx</code>建议锁定屏幕方向</li><li>设计师可用iphone6作为视稿标准</li><li>如果设计稿不是 750px，HBuilderX提供了工具自动换算，<a href="https://ask.dcloud.net.cn/article/35445">详见</a></li></ul><h4 id="H5单位"><a href="#H5单位" class="headerlink" title="H5单位"></a>H5单位</h4><ul><li>rem: 默认根字体大小为 屏幕宽度/20 (支持 微信小程序、头条小程序、App、H5)</li><li>vh: 1vh等于视窗高度的1%</li><li>vw: 1vw等于视窗宽度的1%</li></ul><p><strong>nvue 不支持百分比，App端，在 pages.json仅支持px</strong></p><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>静态样式统一写至class中，style只接受动态样式，这样可以避免性能的消耗</p><p>目前支持的选择器<br>class,id,element,::before:/::after(仅微信小程序和5+APP生效)</p><p><strong>无法使用<code>*</code>,page相当于body</strong><br>App.vue 中的样式为全局样式，nvue不支持全局样式</p><h4 id="css变量"><a href="#css变量" class="headerlink" title="css变量"></a>css变量</h4><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">–status-bar-height</td><td style="text-align:center">系统状态栏高度，小程序为25px，H5为0</td></tr><tr><td style="text-align:center">–window-top</td><td style="text-align:center">内容区域距离顶部的距离，小程序为0 ，H5为NavigationBar高度</td></tr><tr><td style="text-align:center">–window-bottom</td><td style="text-align:center">内容区域距离底部部的距离，小程序为0 ，H5为TabBar高度</td></tr></tbody></table><ul><li>当设置 <code>navigationStyle:&quot;custom&quot;</code>取消原生导航栏，由于窗体沉浸式，占据了状态栏位置。此时可使用<code>var(--status-bar-height)</code>的view放在页面顶部，避免页面内容出现在状态栏。</li><li>由于H5端部存在原生导航栏和tabBar,因此由前端模拟</li><li>目前 nvue 不支持<code>--status-bar-height</code>,可在页面onLoad时通过<code>uni.getSystemInfoSync().statusBarHeight</code>获取状态栏高度，然后通过style绑定方式给占位view设定高度。</li></ul><p><strong>NavigationBar导航栏( 固定高度<code>44px</code> 不可修改),TabBar 底部选项卡( 固定高度<code>50px</code> 不可修改)</strong></p><h4 id="背景图注意点"><a href="#背景图注意点" class="headerlink" title="背景图注意点"></a>背景图注意点</h4><ul><li>支持base64、网络路径图</li><li>本地路径图小于40Kb,自动转化为base64,大于则须手动转化，或使用网络路径的方式引用。</li><li>推荐以<code>~@</code>的方式引用图片，而V3版本设定为不自动转化成base64</li><li><strong>微信小程序不支持相对路径</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'~@/static/logo.png'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字体图"><a href="#字体图" class="headerlink" title="字体图"></a>字体图</h5><ul><li>网络路径必须加协议头 <code>https</code></li><li>字体文件大于等于 40kb， 需开发者自己转换，否则使用将不生效；<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> @<span class="keyword">font-face</span> &#123;</span><br><span class="line">     <span class="attribute">font-family</span>: test1-icon;</span><br><span class="line">     <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'~@/static/iconfont.ttf'</span>);</span><br><span class="line"> &#125;</span><br><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line"><span class="attribute">font-family</span>: <span class="string">'iconfont'</span>;</span><br><span class="line"><span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'https://at.alicdn.com/t/font_865816_17gjspmmrkti.ttf'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p><a href="https://cn.vuejs.org/v2/guide/typescript.html">Vue.js 对 TypeScript 支持详情</a></p><h2 id="对应小程序自定义组件存放目录"><a href="#对应小程序自定义组件存放目录" class="headerlink" title="对应小程序自定义组件存放目录"></a><a href="https://uniapp.dcloud.io/frame?id=%e5%b0%8f%e7%a8%8b%e5%ba%8f%e7%bb%84%e4%bb%b6%e6%94%af%e6%8c%81">对应小程序自定义组件存放目录</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概叙&quot;&gt;&lt;a href=&quot;#概叙&quot; class=&quot;headerlink&quot; title=&quot;概叙&quot;&gt;&lt;/a&gt;概叙&lt;/h2&gt;&lt;p&gt;&lt;code&gt;uni-app&lt;/code&gt;是基于vueJS框架开发的微端应用框架，可一套代码跨ios\Android\H5\小程序等多个平台运
      
    
    </summary>
    
    
      <category term="uniapp" scheme="https://owen027.github.io/tags/uniapp/"/>
    
  </entry>
  
  <entry>
    <title>javascript_events</title>
    <link href="https://owen027.github.io/2019/12/18/javascript_events/"/>
    <id>https://owen027.github.io/2019/12/18/javascript_events/</id>
    <published>2019-12-18T05:55:26.000Z</published>
    <updated>2019-12-25T13:34:08.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是某事发生的信号，它可以被系统侦测到，从而触发某个函数或程序</p><p>DOM 事件标准描述了事件传播的 3 个阶段：</p><ul><li>捕获阶段 —— 事件（从 Window）向下到达元素上。</li><li>目标阶段 —— 事件到达目标元素。</li><li>冒泡阶段 —— 事件从元素上开始冒泡。</li></ul><p>事件首先通过祖先链向下传递到元素（捕获），然后到达目标，最后上升（冒泡），在途中调用处理器。</p><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><p>冒泡：当事件发生再元素上，它首先会运行元素本身的处理器，然后运行父级上同类型的处理器，之后运行其它祖级上同类型的处理器(大多数事件都是冒泡行为，forcus等例外)；可通过 <code>event.stopPropagation()</code><br>通过 JS<code>on&lt;event&gt;</code>属性、<code>addEventListener(event,handler,false)</code>或HTML属性添加的函数，发生在冒泡阶段和目标阶段</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  body * &#123;</span></span><br><span class="line"><span class="undefined">    margin: 10px;</span></span><br><span class="line"><span class="undefined">    border: 1px solid blue;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"alert('forbear')"</span>&gt;</span>FORBEAR</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"alert('parent')"</span>&gt;</span>Parent</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">"alert('son')"</span>&gt;</span>SON<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JS中与鼠标相关事件：<code>click</code>左击、<code>dblclick</code>左双击、<code>contextmenu</code>右击、<code>mouseover / mouseenter(不会冒泡)</code>鼠标移入元素、<code>mousemove / mouseleave(不会冒泡)</code>鼠标移出元素、<code>mousedown</code>按下、<code>mouseup</code>松开</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h2&gt;&lt;p&gt;事件是某事发生的信号，它可以被系统侦测到，从而触发某个函数或程序&lt;/p&gt;
&lt;p&gt;DOM 事件标准描述了事件传播的 3 个阶段：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="notes" scheme="https://owen027.github.io/categories/notes/"/>
    
    
      <category term="js events" scheme="https://owen027.github.io/tags/js-events/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 的更新和查询</title>
    <link href="https://owen027.github.io/2019/10/16/mysql_data_update_and_query/"/>
    <id>https://owen027.github.io/2019/10/16/mysql_data_update_and_query/</id>
    <published>2019-10-16T03:18:24.000Z</published>
    <updated>2019-12-25T13:34:08.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>数据更新有三种操作：插入数据（INSERT）、修改表中的数据(UPDATE)、删除数据(DELETE)</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="INSERT-…-VALUES-插入多行或单行元组数据"><a href="#INSERT-…-VALUES-插入多行或单行元组数据" class="headerlink" title="INSERT … VALUES 插入多行或单行元组数据"></a>INSERT … VALUES 插入多行或单行元组数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] tbl_name [col_name,...]</span><br><span class="line">    &#123;<span class="keyword">VALUES</span>|<span class="keyword">VALUE</span>&#125;(&#123;expr|<span class="keyword">DEFAULT</span>&#125;,...),(...),...</span><br></pre></td></tr></table></figure><p>col_name :指定需要插入数据的列名列表。 如果向表中所有列插入数据，则全部列名可省略，这样做是不安全的，如果表结构发生变化，数据将会错乱。</p><p>向表的部分列插入数据，对于没被指定的列，其规则如下：</p><ol><li>对于具有标识（IDENTITY）属性的列，系统会自动生成序号值类唯一标识该列</li><li>具有默认值的列，通过 INSERT 中指定关键字 DEFALUT 将其设为默认值</li><li>没默认值的列，若允许空值，则通过 INSERT 指定 NULL 设为空，否则执行语句报错</li><li>对于类型为 TIMESTAMP 的列，系统自动赋值</li><li>AUTO_INCREMENT 属性列的值在表中其它列被赋值之 后生成，因此对表中其他列做赋值操作时，该属性列的引用只会返回数字 0</li></ol><p><code>VALUES 或 VALUE</code>：包含各列需要插入数据的清单。 数据的顺序必须与列的顺序相对应，该子句的值可以是：</p><ul><li>‘expr’: 一个常量、变量或表达式，也可以是NULL，其值的数据类型须与列的数据类型一致，否则报错</li><li>‘DEFAULT’：指定默认该列值为该列的默认值，前提该列已经明确指定了默认值，否则报错</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO mysql_test.customers</span><br><span class="line">    -&gt; Values(901,'张三','F','北京市')</span><br><span class="line">Query OK, 1 row affected(0.09 sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO mysql_test.customers</span><br><span class="line">    -&gt; Values(0,'李四',DEFAULT,'北京市')</span><br><span class="line">Query OK, 1 row affected(0.09 sec)</span><br></pre></td></tr></table></figure><p>上述中未给出待插入表的列清单，这样的操作是不安全的须改成：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO mysql_test.customers(cust_Id,cust_name,cust_sex,cust_address)</span><br><span class="line">    -&gt; Values(0,'李四',DEFAULT,'北京市')</span><br><span class="line">Query OK, 1 row affected(0.09 sec)</span><br></pre></td></tr></table></figure></p><p>当表的结构发生改变, INSERT 语句任能正确执行。</p><h4 id="INSERT…SET"><a href="#INSERT…SET" class="headerlink" title="INSERT…SET"></a>INSERT…SET</h4><p><code>INSERT...SET</code> 可以直接给表中的某些列指定对应的列值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] tbl_name</span><br><span class="line">    <span class="keyword">SET</span> col_name1=&#123;expr|<span class="keyword">DEFAULT</span>&#125;,col_name2=&#123;expr|<span class="keyword">DEFAULT</span>&#125;,....</span><br></pre></td></tr></table></figure></p><p>对于未指定的列为默认值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO mysql_test.customers</span><br><span class="line">    -&gt; SET cust_address='武汉',cust_name="李四"，cust_sex=DEFAULT</span><br><span class="line">Query OK, 1 row affected(0.09 sec)</span><br></pre></td></tr></table></figure></p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>使用<code>DELETE FROM tbl_name</code> 可删除行数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</span><br><span class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</span><br></pre></td></tr></table></figure><p>-<code>WHERE</code>：限定删除条件，从而删除特定的行，如不指定条件则删除指定表的所有行数据</p><ul><li><code>ORDER BY</code>：各行按指定顺序进行删除</li><li><code>LIMIT</code>：告知服务器在控制命令被返回到客户端前被删除行的最大值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mysql_test.customers</span><br><span class="line">   <span class="keyword">WHERE</span> cust_name=<span class="string">'王五'</span></span><br><span class="line"><span class="keyword">Query</span> OK, <span class="number">1</span> <span class="keyword">row</span> affected(<span class="number">0.09</span> sec)</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>使用<code>UPDATE</code> 更新表中的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  tbl_name</span><br><span class="line">    <span class="keyword">SET</span> col_name=&#123;expr|<span class="keyword">DEFAULT</span>&#125;[,col_name=&#123;expr|<span class="keyword">DEFAULT</span>&#125;]...</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</span><br><span class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</span><br></pre></td></tr></table></figure><p>-<code>WHERE</code>：限定修改条件，从而修改特定的行，如不指定条件则修改指定表的所有行数据</p><ul><li><code>ORDER BY</code>：各行按指定顺序进行修改</li><li><code>LIMIT</code>：限定被修改的行数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  mysql_test.customers</span><br><span class="line">   <span class="keyword">SET</span> cust_address = <span class="string">'北京'</span>,cust_sex = <span class="literal">NULL</span></span><br><span class="line">   <span class="keyword">WHERE</span> cust_name=<span class="string">'王五'</span></span><br><span class="line"><span class="keyword">Query</span> OK, <span class="number">1</span> <span class="keyword">row</span> affected(<span class="number">0.09</span> sec)</span><br></pre></td></tr></table></figure><hr><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>数据查询是SQL 语言的核心功能，是使用最多的操作</p><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>SELECT 可以从数据库中检索、统计或输出数据<br>执行过程是从数据库中选取匹配的特定行和列，并组成一个结果集放到临时表中返回。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>|<span class="keyword">DISTINCTROW</span>]</span><br><span class="line"> select_expr[,select_expr ...]</span><br><span class="line"> <span class="keyword">FROM</span> table_references</span><br><span class="line"> [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line"> [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name|expr|<span class="keyword">position</span>&#125;</span><br><span class="line">    [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>],...[<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>]]</span><br><span class="line"> [<span class="keyword">HAVING</span> where_condition]</span><br><span class="line"> [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name|expr|<span class="keyword">position</span>&#125;</span><br><span class="line">    [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>],...]</span><br><span class="line"> [<span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,]<span class="keyword">row_count</span>|<span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</span><br></pre></td></tr></table></figure></p><p>SELECT 子句用于指定输出的字段； （必选）<br>FROM 子句用于指定数据的来源；   （从表选择数据时使用）<br>WHERE 用于指数据的选择条件；<br>GROUP BY 用于对检索到的记录进行分组；（在按组计算聚合时使用）<br>HAVING 用于指定组的选择条件；<br>ORDER BY 用于对查询结果的排序；</p><label>必须按照SELECT 语句的语法格式所罗列的顺序格式查找数据。</label><p>如 HAVING 语句必须位于BROUP BY之后 OREDR BY 之前。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;p&gt;数据更新有三种操作：插入数据（INSERT）、修改表中的数据(UPDATE)、删除数据(DELETE)&lt;/p&gt;
&lt;h3 id=&quot;插入数据&quot;&gt;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://owen027.github.io/categories/MySQL/"/>
    
    
      <category term="Database definition syntax" scheme="https://owen027.github.io/tags/Database-definition-syntax/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的表索引定义</title>
    <link href="https://owen027.github.io/2019/10/15/mysql_index_definition/"/>
    <id>https://owen027.github.io/2019/10/15/mysql_index_definition/</id>
    <published>2019-10-15T07:38:24.000Z</published>
    <updated>2019-12-25T13:34:08.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>索引是 DBMS 根据表中的一列或若干列按一定的顺序建立的列值与记录行之间的对应关系表，方便 DBA 管理</p><ul><li>索引是以文件的形式存储，DBMS 将一张表的所有所有保存在同一个索引文件中，需要占用磁盘空间，如果有大量索引，可能比数据文件更快达到最大的文件尺寸。</li><li>索引提高查询速度的同时，会降低更新表的速度。更新表中索引列上的数据时，索引会被自动更新，确保索引树与表中的内容完全保持一致，因此索引越多，则更新时长更长。</li></ul><p>根据用途，索引在逻辑上大体分为三类</p><ol><li><p>普通索引（INDEX）: 最基本的索引类型，没有任何限制。通常使用关键字 INDEX 或 KEY</p></li><li><p>唯一性索引（UNIQUE）：索引中所有的值只能出现一次，必须唯一 通常使用关键字 UNIQUE</p></li><li><p>主键（PRIMARY KEY）：主键是一种唯一性索引。创建主键时，必须指定关键字 PRIMARY KEY，且不能有空值，一般在创建表的时候指定，也可通过修改表的方式添加，每张表只能有一个主键</p></li></ol><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>分别有三种方式创建索引</p><h3 id="CREATE-INDEX"><a href="#CREATE-INDEX" class="headerlink" title="CREATE INDEX"></a><code>CREATE INDEX</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> index_name</span><br><span class="line">    <span class="keyword">NO</span> tbl_name(index_col_name,...)</span><br></pre></td></tr></table></figure><ol><li><code>UNIQUE</code>：指定创建唯一性索引，一张表可以创建多个索引，每个索引在该表中名称唯一</li><li><code>tabl_name</code>: 数据库的表名</li><li><code>index_col_name</code> ：关于索引的描述。格式为<code>col_name[(length)][ASC|DESC]</code></li></ol><h4 id="索引的描述三个语法要素"><a href="#索引的描述三个语法要素" class="headerlink" title="索引的描述三个语法要素"></a>索引的描述三个语法要素</h4><ul><li><code>col_name</code>：指定要创建索引的列名，</li><li><code>lenght</code>:指定使用列的前length 个字符创建索引，有利于减小索引文件的大小</li><li><code>ASC|DESC</code>指定按升序（ASC）或降序（DESC）排列，默认 ASC</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;CREATE INDEX index_customers</span><br><span class="line">    -&gt;  NO mysql_test.customers (cust_name(3)ASC)</span><br><span class="line">Query OK, 0 rows affected (0.20 sec)</span><br><span class="line">Records:0 Duplicates:0 Warning:0</span><br></pre></td></tr></table></figure><h4 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a><code>CREATE TABLE</code></h4><ul><li><code>[CONSTRAINT [symbol]] PRIMARY KEY (index_col_name,...)</code>：创建新表的同时创建该表主键</li><li><code>{INDEX|KEY}[index_name](index_col_name,...)</code> ：创建表的同时创建该表索引</li><li><code>[CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] (index_col_name,...)</code>:用于创建表时创建唯一性索引</li><li><p><code>[CONSTRATIN [symbol]] FOREIGN KEY[index_name] (index_col_name,...)</code>:创建表的同时创建外键</p></li><li><p><code>KEY</code>: 关键字 INDEX的同义词</p></li><li><code>CONSTRAINT</code>：为主键、UNIQUE键、外键定义一个名字，使用 CREATE TABLE 定义列选项时，可以通过直接在某个列定义后面添加<code>PRIMARY KEY</code> 添加主键，主键由多列组成的多列索引时，不能使用此方法。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE mysql_test</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE seller</span><br><span class="line">    -&gt;(</span><br><span class="line">    -&gt; seller_id int NOT NULL AUTO_INCREMENT</span><br><span class="line">    -&gt; seller_name char(50) NOT NLULL,</span><br><span class="line">    -&gt; seller_address char(50) null,</span><br><span class="line">    -&gt; product_type int(5) NULL</span><br><span class="line">    -&gt; sales int NULL</span><br><span class="line">    -&gt; PRIMARY KEY (seller_id,product_type)</span><br><span class="line">    -&gt; INDEX index_seller(salse)</span><br><span class="line">   -&gt;)</span><br><span class="line">Query OK, 0 rows affected (0.20 sec)</span><br></pre></td></tr></table></figure><h4 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a><code>ALTER TABLE</code></h4><ul><li><code>ADD {INDEX|KEY} [index_name] (index_col_name,...)</code>: 新增表列的同时添加索引</li><li><code>ADD [CONTRAIN [smbol]] PRIMARY KEY [index_name] (index_col_name,...)</code>：新增列的同时添加主键</li><li><code>ADD [CONTRAIN [smbol]] UNIQUE [INDEX|KEY] [index_name] (index_col_name,...)</code>: 新增列的同时添加唯一性索引</li><li><code>ADD [CONTRAIN [smbol]] FOREIGN KEY [index_name] (index_col_name,...)</code>: 新增列的同时添加外键<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mysql_test.seller</span><br><span class="line">    -&gt; ADD INDEX index_seller_name(seller_name)</span><br><span class="line">Query OK, 0 rows affected (0.20 sec)</span><br><span class="line"> Records: 0 Duplicates: 0 Warning: 0</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p>使用 SHOW INDEX 查看索引<br>语法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">INDEX</span>|<span class="keyword">INDEXES</span>|<span class="keyword">KEYS</span>&#125;</span><br><span class="line"> &#123;<span class="keyword">FROM</span>|<span class="keyword">IN</span>&#125; tbl_name</span><br><span class="line"> [&#123;<span class="keyword">FROM</span>|<span class="keyword">IN</span>&#125;db_name]</span><br><span class="line"> [<span class="keyword">WHERE</span> expr]</span><br></pre></td></tr></table></figure></p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>使用 DROP INDEX 或 ALTER TABLE 删除索引</p><ul><li>DROP INDEX</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> tbl_name</span><br></pre></td></tr></table></figure><ul><li>ALTER TABLE</li></ul><ol><li><p>DROP PRIMARY KEY 删除表中主键</p></li><li><p>DROP INDEX 删除对应索引</p></li><li><p>DROP FOREIGN KEY 删除外键</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mysql_test.customers</span><br><span class="line">    -&gt; DROP PRIMARY KEY</span><br><span class="line">    -&gt; DROP INDEX index_custormes</span><br><span class="line">Query OK, 0 rows affected (0.20 sec)</span><br><span class="line"> Records: 0 Duplicates: 0 Warning: 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;索引是 DBMS 根据表中的一列或若干列按一定的顺序建立的列值与记录行之间的对应关系表，方便 DBA 管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引是
      
    
    </summary>
    
      <category term="MySQL" scheme="https://owen027.github.io/categories/MySQL/"/>
    
    
      <category term="Database definition syntax" scheme="https://owen027.github.io/tags/Database-definition-syntax/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的数据库定义语法</title>
    <link href="https://owen027.github.io/2019/10/14/mysql_database_definition_syntax/"/>
    <id>https://owen027.github.io/2019/10/14/mysql_database_definition_syntax/</id>
    <published>2019-10-14T12:19:31.000Z</published>
    <updated>2019-12-25T13:34:08.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>在MySQL中，使用 CREATE DATABASE 或 CREATE SCHEMA 语句创建数据库<br>语法结构：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;<span class="keyword">DATABASE</span>|<span class="keyword">SCHEMA</span>&#125;[<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name</span><br><span class="line">[<span class="keyword">DEFAULT</span>]<span class="built_in">CHARACTER</span> <span class="keyword">SET</span> [=]charest_name</span><br><span class="line">|[<span class="keyword">DEFAULT</span>]<span class="keyword">COLLATE</span> [=]collation_name</span><br></pre></td></tr></table></figure></p><p><code>[]</code>: 表示为可选<br><code>|</code>: 用于分隔花括号中的选项，表示任选一项语法<br><code>db_name</code>: 标识具体的数据库命名，必须符合操作系统文件夹命名规则，在MySQL中不区分大小写<br><code>DEFAULT</code>: 默认值<br><code>CHAREST SET</code>: 指定数据库字符集<br><code>COLLATE</code>: 指定字符集校对规则<br><code>IF NOT EXISTS</code>：创建数据库前进行判断，只有该数据库不存在时才能创建数据库</p><p><strong>Example：</strong><br>创建名称位 mysql_test 的数据库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> mysql_test;</span><br></pre></td></tr></table></figure></p><p>在次输入同样的命令 将会报错 可添加 <code>IF NOT EXISTS</code> 避免报错</p><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p> MySQL 中创建数据库之后，不会自动使用新创建的数据库，可使用 <code>USE</code> 语句从当前环境切换换至新创建的数据库或其它数据库<br><strong>Example：</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql_test;</span><br></pre></td></tr></table></figure></p><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><p>MySQL 中使用 ALTER DATABASE 或使用 ALTER SCHEMA 语句，修改数据库的相关参数<br>语法结构：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">DATABASE</span>|<span class="keyword">SCHEMA</span>&#125;[db_name]</span><br></pre></td></tr></table></figure></p><p><strong>Example：</strong><br>修改已有数据库默认字符集和校对规则<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER DATABASE mysqle_test</span><br><span class="line">-&gt; DEFAULT CHARACTER SET gb2312</span><br><span class="line">-&gt; DEFAULT COLLATE gb2312_chinese_ci;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>MySQL 中使用 DROP DATABASE 或 DROP SCHEMA 来删除数据库,其数据永久删除<br>语法结构：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">DATABASE</span>|<span class="keyword">SCHEMA</span>&#125;[<span class="keyword">IF</span> EXISITS]db_name</span><br></pre></td></tr></table></figure></p><p><strong>Example：</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> EXISITS  mysqle_test</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><p>MySQL 中使用 SHOW DATABASE 或 SHOW SCHEMA 来看可用数据库列表，只会列从出权限范围内的数据库<br>语法结构：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">DATABASE</span>|<span class="keyword">SCHEMA</span>&#125;[<span class="keyword">LIKE</span><span class="string">'pattern'</span>|<span class="keyword">WHERE</span> expr]</span><br></pre></td></tr></table></figure></p><p><code>LIKE</code>: 匹配指定数据库名称<br><code>WHERE</code>: 指定数据库名称查询范围</p><p><strong>Example：</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASE</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;创建数据库&quot;&gt;&lt;a href=&quot;#创建数据库&quot; class=&quot;headerlink&quot; title=&quot;创建数据库&quot;&gt;&lt;/a&gt;创建数据库&lt;/h3&gt;&lt;p&gt;在MySQL中，使用 CREATE DATABASE 或 CREATE SCHEMA 语句创建数据库&lt;br&gt;语法结构
      
    
    </summary>
    
      <category term="MySQL" scheme="https://owen027.github.io/categories/MySQL/"/>
    
    
      <category term="Database definition syntax" scheme="https://owen027.github.io/tags/Database-definition-syntax/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的表定义语法</title>
    <link href="https://owen027.github.io/2019/10/14/mysql_table_definition_syntax/"/>
    <id>https://owen027.github.io/2019/10/14/mysql_table_definition_syntax/</id>
    <published>2019-10-14T12:15:35.000Z</published>
    <updated>2019-12-25T13:34:08.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表定义"><a href="#表定义" class="headerlink" title="表定义"></a>表定义</h2><p>只有成功创建数据库后，才能创建数据表，数据表是字段的集合，在表中数据按行和列的格式存储</p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>MySQL 使用 CREATE TABLE 创建表。其中有多个选择，主要由表创建定义（create definition）、表选项定义（table options） 和区分选项（partition options）等内容构成。</p><p>表创建定义：由表列的名字、列的定义集可能的一个空值声明、一个完整性约束或表索引项组成，表索引项主要定义表的索引、主键、外键等。</p><p>语法结构：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>[<span class="keyword">TEMPORARY</span>]<span class="keyword">TABLE</span> tbl_name</span><br><span class="line">(</span><br><span class="line">    字段名|数据类型[列级完整性约束条件][默认值]</span><br><span class="line">    [,字段名<span class="number">2</span> 数据类型[列级完整性约束条件][默认值]]</span><br><span class="line">    [,....]</span><br><span class="line">    [,表级完整性约束条件]</span><br><span class="line">)[<span class="keyword">ENGINE</span>=引擎类型]</span><br></pre></td></tr></table></figure></p><p><strong>Example:</strong><br>新建一个客户信息<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE mysql_test</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CRATE TABLE customers</span><br><span class="line">    -&gt;(</span><br><span class="line">    -&gt; cust_id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; cust_name CHAR(50) NOT NULL,</span><br><span class="line">    -&gt; cust_sex CHAR(1) NOT NULL DEFAULT 0,</span><br><span class="line">    -&gt; cust_address CHAR(50) NULL</span><br><span class="line">    -&gt; cust_contact CHAR(50) NULL</span><br><span class="line">    -&gt; PRIMARY KEY(CUST_ID)</span><br><span class="line">    -&gt;)</span><br><span class="line">Query OK, 0 rows affected(0.11 sec)</span><br></pre></td></tr></table></figure></p><h4 id="临时表与持久表"><a href="#临时表与持久表" class="headerlink" title="临时表与持久表"></a>临时表与持久表</h4><p>TEMPORARY：表示临时表，如果不选用则为持久表。<br>持久表一直存在，多个用户或应用程序可同时使用持久表，如果只需临时存放数据可添加 TEMPORARY 关键字<br>临时表只能对创建它的用户可见，断开数据库连接时，表会自动清除</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>数据类型指系统中所允许的数据的类型。每列都应有适当的数据类型，来限制或允许该列的数据。 建表时必须为每列指定正确的数据类型及数据长度 （CHAR(50)）</p><p>MySQL 主要数据类型:</p><ul><li>数值类型：整型 int、浮点 double、布尔 bool</li><li>日期和时间类型：日期型、时间戳 timestamp、时间型 time</li><li>字符串类型：定长字符类型char、可变长字符类型varchrar</li><li>空间数据类型:单个几何类型 GEOMETRY等</li></ul><h4 id="关键字-AUTO-INCREMENT"><a href="#关键字-AUTO-INCREMENT" class="headerlink" title="关键字 AUTO_INCREMENT"></a>关键字 AUTO_INCREMENT</h4><p>AUTO_INCREMENT: 表中数据类型为整型的列设置自增属性 （++i）,从当前指或 1 开始，表中只能有一个 AUTO_INCREMENT。</p><p>当一个表列被指定为 AUTO_INCREMENT 后，其值可被覆盖，即可在表数据插入语句中为该列指定一个值（必须唯一），则该值将替换系统自动生成的值，后续增量基于该插入的值</p><h4 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h4><p>DEFAULT:用于指定MySQL在未给值的情况下默认的值（DEFAULT 0）</p><p>如果未指定默认值，则自动为其分配一个值，如若该列可取值NULL，则默认NULL，若定义 NOT NULL，则默认取决于该列的类型：</p><ul><li>一个没有声明 AUTO_INCREMENT 列 为数字类型，默认 0</li><li>一个 AUTO_INCREMENT 列 默认为顺序中的下一个值</li><li>对于除 TIMESTAMP 以外的日期和时间类型，默认为该类型适当的’零’值、</li><li>对于表中第一个 TIMESTAMP 列，默认值为当前日期和时间</li></ul><h4 id="NULL值"><a href="#NULL值" class="headerlink" title="NULL值"></a>NULL值</h4><p>NULL：没有值或缺值，允许NULL的列，插入行时可以不给该列的值；不允许NULL值的列，则该列必须有数据<br><code>NULL</code> 和 <code>&#39;&#39;</code>是不对等的 NOT NULL 列中允许<code>&#39;&#39;</code> 不允许 NULL</p><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>PRIMARY KEY :指定主键，主键必须唯一且不能为NULL， 如果是单列，值必须唯一，如果是组合列，则其组合的值必须唯一</p><h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><p>通过使用 ALTER TABLE 来修改数据库</p><ul><li><code>ADD[COLUMN]</code>：新增表列，可增多列使用逗号分隔即可<br><strong>Example:</strong><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mysqle_test.customers</span><br><span class="line">    -&gt; ADD COLUMN cust_city char(10) NOT NULL DEFAULT'ShenZhen' AFTER cust_sex;</span><br><span class="line">Query OK,0 rows affected(0.61 sec)</span><br><span class="line">Records:0 Duplicates:0 Warning:0</span><br></pre></td></tr></table></figure></li></ul><p>AFTER：将新增的列添加到cut_sexl 列之后<br>FIRST：将新增的列添加到表的第一列</p><p>若使用上述关键字则将新增的列添加至表最后</p><p>类似的 可以使用 ADDPRIMARY KEY 、ADDFOREIGN KEY 、ADD INDEX 添加对应的 主键、外键、索引</p><ul><li><code>CHANGE[COLUMN]</code>: 修改表中列的名称或数据类型，可修改多列使用逗号分隔即可</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mysqle_test.customers</span><br><span class="line">    -&gt; CHANGE COLUMN cust_sex sex char(1) NULL DEFAULT 'M'</span><br><span class="line">Query OK,0 rows affected(0.66 sec)</span><br><span class="line">Records:0 Duplicates:0 Warning:0</span><br></pre></td></tr></table></figure><p>如果将数据类型更换，可能会丢失该列原有的数据，如果视图改变的数据类型于原有的数据类型不兼容，则SQL命令不会执行，且抛出错误。<br>再兼容的情况下，该列的数据可能会被截断，如：一列的数据类型为 varchart(10),改为char(1),则该列中的数据’ShenZhen’会变为’S’</p><ul><li><p><code>ALTER [COLUMN]</code>: 修改或删除指定列的默认值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mysqle_test.customers</span><br><span class="line">    -&gt; ALTER COLUMN cust_city SET  DEFAULT 'ShangHai'</span><br><span class="line">Query OK,0 rows affected(0.36 sec)</span><br><span class="line">Records:0 Duplicates:0 Warning:0</span><br></pre></td></tr></table></figure></li><li><p><code>MODIFY [COLUMN]</code>: 修改指定列的数据类型，通过 ‘FIRST’ 或 ‘AFTER’ 修改列的位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mysqle_test.customers</span><br><span class="line">    -&gt; MODIFY COLUMN cust_name char(30)  FIRST</span><br><span class="line">Query OK,0 rows affected(0.20 sec)</span><br><span class="line">Records:0 Duplicates:0 Warning:0</span><br></pre></td></tr></table></figure></li><li><p><code>DROP [COLUMN]</code>: 删除列，该列所有数据一并删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mysqle_test.customers</span><br><span class="line">    -&gt; DROP COLUMN cust_city</span><br><span class="line">Query OK,0 rows affected(0.42 sec)</span><br><span class="line">Records:0 Duplicates:0 Warning:0</span><br></pre></td></tr></table></figure></li></ul><p>同样 可使用 DROP PRIMARY KEY 、DROP FOREIGN KEY、DROP INDEX 删除对应的主键、外键、索引</p><ul><li><code>RENAME[TO]</code>:表重命名<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE mysqle_test.customers</span><br><span class="line">    -&gt; RENAME TO</span><br><span class="line">Query OK,0 rows affected(0.42 sec)</span><br></pre></td></tr></table></figure></li></ul><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><p>除了 ALTER TABLE 中的 RENAME TO 修改表名，还可通过 RENAME TABLE 来修改单张和多张表（以逗号分隔）<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; RENAME TABLE mysql_test.back.customers TO mysqle_test.customers</span><br></pre></td></tr></table></figure></p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p><code>DROP[TEMPORARY]TABLE[IF EXISTS]</code>删除一个已存在的表,可以删除多张表，前提操作人必须有权限，但是操作人在该张表上的权限不会被删除</p><h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><ul><li><code>SHOW [FULL] TABLES [{FROM|IN}db_name] [LIKE&#39;pattern&#39;|WHERE expr]</code>：  显示指定数据库中所有表名</li></ul><p><strong>Example：</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE mysql_test</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; SHOW TABLES:</span><br><span class="line"> Tables_in_mysql_test</span><br><span class="line"> customers</span><br><span class="line"> 1 row in <span class="keyword">set</span> &lt;<span class="number">0.01</span> sec&gt;</span><br></pre></td></tr></table></figure></p><ul><li><code>SHOW [FULL] COLUMNS {FROM|IN}tb_name[{FROM|IN}db_name] 或 {DESCRIBE|DESC} tbl_name[col_name|wild]</code>: 显示指定数据库表结构。</li></ul><p>MySQL 支持使用 DESCRIBE 代替 SHOW COLUMNS FROM 来查看表结构</p><p><strong>Example:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC mysql_test.custormes</span><br><span class="line">Field         Type       Null key  Default Extra</span><br><span class="line">cust_id       int&lt;11&gt;    NO   PRI  NULL    auto_increment</span><br><span class="line">cust_name     char&lt;50&gt;   NO        Null</span><br><span class="line">cust_sex      int&lt;1&gt;     NO        0</span><br><span class="line"></span><br><span class="line">3 row in <span class="keyword">set</span> &lt;<span class="number">1.56</span> sec&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;表定义&quot;&gt;&lt;a href=&quot;#表定义&quot; class=&quot;headerlink&quot; title=&quot;表定义&quot;&gt;&lt;/a&gt;表定义&lt;/h2&gt;&lt;p&gt;只有成功创建数据库后，才能创建数据表，数据表是字段的集合，在表中数据按行和列的格式存储&lt;/p&gt;
&lt;h3 id=&quot;创建表&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="MySQL" scheme="https://owen027.github.io/categories/MySQL/"/>
    
    
      <category term="Table definiton syntax" scheme="https://owen027.github.io/tags/Table-definiton-syntax/"/>
    
  </entry>
  
  <entry>
    <title>SQL和MySQL 基础</title>
    <link href="https://owen027.github.io/2019/10/09/SQL_basic_operations/"/>
    <id>https://owen027.github.io/2019/10/09/SQL_basic_operations/</id>
    <published>2019-10-09T10:18:47.000Z</published>
    <updated>2019-12-25T13:34:08.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Struture Query Langue （结构化查询语言，SQL），于1974年 Boyce 和 Chamberlin 提出。其已成为关系数据库的标准语言，是一种数据库查询和程序设计语言，用于存取数据及查询、更新和管理关系数据库系统，具有数据库定义、数据操作和数据控制等功能</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>SQL不是特点的数据库专有语言，几乎所有重要的关系数据库管理系统都支持 SQL。</li><li>SQL简单易学，SQL语句不区分大小写。</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>SQL集数据查询（Data Query）、数据定义（Data Definition）、数据操纵（Data Manipulation）和数据控制（Data Control）四大功能于一体</p><h4 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h4><p>主要用于对数据库及数据库中的各种对象进行创建、修改、删除等操作。数据库对象主要为 表、默认约束、规则、视图、触发器、存储过程等</p><p><strong>关键字：</strong></p><ol><li>CREATE: 创建数据库或数据库对象</li><li>ALTER：修改数据库或数据库对象</li><li>DORP： 删除数据库或数据库对象</li></ol><h4 id="数据操作语言（DML）"><a href="#数据操作语言（DML）" class="headerlink" title="数据操作语言（DML）"></a>数据操作语言（DML）</h4><p>主要用于操作数据库中的各种对象，主要是检索和修改数据</p><p><strong>关键字：</strong></p><ol><li>SELECT：从表或视图中检索数据，使用最为频繁</li><li>INSERT：将数据插入到表或视图中</li><li>UPDATE：修改表或视图中的数据，可修改单行，也可修改多行</li><li>DELETE：删除表或视图中的数据，可跟据条件删除指定数据</li></ol><h4 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="数据控制语言（DCL）"></a>数据控制语言（DCL）</h4><p>用于安全管理（权限）</p><ol><li>GRANT：授予权限</li><li>REVOKE：回收权限</li></ol><hr><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>MySQL是一个关系数据库管理系统（RDBMS),具有客户/服务器体系结构，由瑞典MySQL AB公司开发。 具有体积小、速度快、开源、遵循GPL（GNU通用公共许可证）等特点</p><p>MySQL在SQL标准的基础上增加了部分扩展的语言要素包括常量、变量、运算符、表达式、函数、流程控制语句和注解等。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><!-- 1. 算术运算符: +、-、*、/、%2. 位运算符：&（位与）、|（位或）、^（位异或）、~（位取反）、>>（位右移）、<<（位左移）3. 比较运算符：=、>、<、>=、<=、<>（不等于）、!=（不等于）、<=>（相等或都等于空）4. 逻辑运算符：NOT 或 ! （逻辑非）、AND 或 &&（逻辑与）、OR 或 ||（逻辑或）、XOR（逻辑异或） --><table><thead><tr><th style="text-align:center">算术运算符</th><th style="text-align:center">位运算符</th><th style="text-align:center">比较运算符</th><th style="text-align:center">逻辑运算符</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">&amp;（位与）</td><td style="text-align:center">=</td><td style="text-align:center">NOT 或 ! （逻辑非）</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">l（位或）</td><td style="text-align:center">&gt;</td><td style="text-align:center">AND 或 &amp;&amp;（逻辑与）</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">^（位异或）</td><td style="text-align:center">&lt;</td><td style="text-align:center">OR 或 ll（逻辑或）</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">~（位取反）</td><td style="text-align:center">&gt;=</td><td style="text-align:center">XOR（逻辑异或）</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">&gt;&gt;（位右移）</td><td style="text-align:center">&lt;=</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">&lt;&lt;（位左移）</td><td style="text-align:center">&lt;&gt;（不等于）或 !=（不等于）</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">&lt;=&gt;（相等或都等于空）</td><td style="text-align:center"></td></tr></tbody></table><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><ul><li>数学函数，如ABS()、SORT()</li><li>聚合函数，如COUNT()</li><li>字符串函数，如ASCII()、CHAR()</li><li>日期和时间函数，NOW()、YEAR()</li><li>加密函数，ENCODE()、ENCRYPT()</li><li>控制流程函数，IF()、IFNULL()</li><li>格式化函数，FORMAT()</li><li>类型转换函数，CAST()</li><li>系统信息函数，USER(),VERSION()</li></ul><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>SQL 的数据定义功能包括数据库模式、表、索引和视图的定义<br>SQL 标准不提供修改数库模式定义和修改视图定义的操作，如需修改对象，可先删除再创建，或通过RDBMS提供的扩展语句实现<br>SQL 标准不提供索引相关的语句</p><h3 id="数据库模式定义"><a href="#数据库模式定义" class="headerlink" title="数据库模式定义"></a>数据库模式定义</h3><p>对数据库的增、删、改、查、选择等操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#SQL&quot; class=&quot;headerlink&quot; title=&quot;SQL&quot;&gt;&lt;/a&gt;SQL&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="MySQL" scheme="https://owen027.github.io/categories/MySQL/"/>
    
    
      <category term="SQL basis" scheme="https://owen027.github.io/tags/SQL-basis/"/>
    
  </entry>
  
  <entry>
    <title>关系数据库设计方法</title>
    <link href="https://owen027.github.io/2019/10/08/relational_database_design_method/"/>
    <id>https://owen027.github.io/2019/10/08/relational_database_design_method/</id>
    <published>2019-10-08T10:59:17.000Z</published>
    <updated>2019-12-25T13:34:08.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念结构设计方法（概念模式）"><a href="#概念结构设计方法（概念模式）" class="headerlink" title="概念结构设计方法（概念模式）"></a>概念结构设计方法（概念模式）</h2><p>概念模式通常采取自顶向下法（实体分析法），通过两个步骤完成概念设计：</p><p>1.建立局部信息结构<br>2.将局部信息合并为全局信息结构并优化，使用 E-R 模型作为概念模型的描述工具</p><h3 id="E-R-图的表示方法"><a href="#E-R-图的表示方法" class="headerlink" title="E-R 图的表示方法"></a>E-R 图的表示方法</h3><p>概念结构设计是将需求分析得到的用户需求抽象为信息结构（概念模型）的过程，通常使用E-R图作为建模工具具体由三部分组成：</p><ol><li>实体型：用矩形表示，矩形内写明实体名称</li><li>属性：用椭圆表示，用无向边将其与响应实体连接起来</li><li>联系：用菱形表示，菱形内写明联系的名称，并用无向边分别和有关实体连接，同时无向边旁备注联系类型，如果联系也有属性，则同样使用无向边连接。</li></ol><h4 id="实体间的联系"><a href="#实体间的联系" class="headerlink" title="实体间的联系"></a>实体间的联系</h4><p>实体间的联系通常指不同实体型的实体集之间的联系一般有三种情形</p><h5 id="两个实体型之间的联系"><a href="#两个实体型之间的联系" class="headerlink" title="两个实体型之间的联系"></a>两个实体型之间的联系</h5><p>设两个实体集 A、B，两个实体型间的联系可分为 一对一、一对多、多对多</p><p>1&gt; 一对一（1:1）</p><p>对于 A 中每一天实体， B 中最多有一个与之联系，反之亦然，则 A与B 记为 1:1</p><p>2&gt; 一对多（1:N）<br>对于 A 中每一个实体，B 中有N个实体与之联系，反之，B的每一个实体，A中至多有一个实体与之对应，则记为 1:N</p><p>3&gt; 多对多（M:N）</p><p>对于 A 中每个实体，B 中有N个实体与之联系，反之 B 中每个实体，A 中有M个实体与之联系，记为 （M:N）</p><p><strong>example：</strong></p><pre class="mermaid">graph TBA[系] --1--> B{隶属}B --1--> C[系主任]a[班级] --1--> b{包含}b --N--> c[学生]q[学生] --M--> w{选课}w --N--> e[课程]</pre><h5 id="两个实体以上的实体型之间的联系"><a href="#两个实体以上的实体型之间的联系" class="headerlink" title="两个实体以上的实体型之间的联系"></a>两个实体以上的实体型之间的联系</h5><p>同两个实体之间的联系一样存在以上三种联系</p><p><strong>example：</strong></p><pre class="mermaid">graph TBA[课程] --1--> B{讲授}B --M--> C[教师]B --N--> D[参考书]a[供应商] --M--> b{供应}b --N--> c[项目]b --P--> d[零件]</pre><h5 id="单个实体型内的联系"><a href="#单个实体型内的联系" class="headerlink" title="单个实体型内的联系"></a>单个实体型内的联系</h5><p>同一个实体集内的各实体间也可以存在以上三种联系</p><p><strong>example：</strong></p><pre class="mermaid">graph LRA[职工] --1--> B{领导}B --N--> A</pre><h3 id="局部信息结构设计"><a href="#局部信息结构设计" class="headerlink" title="局部信息结构设计"></a>局部信息结构设计</h3><p>局部信息结构设计：根据需求分析报告中标明的不同用户视图范围所建立的满足该范围内用户需求的信息结构。通常为五个步骤</p><h4 id="确定局部范围"><a href="#确定局部范围" class="headerlink" title="确定局部范围"></a>确定局部范围</h4><p>主要依据需求分析报告中标明的用户视图范围来确定局部范围；基本准则：部门和功能相对独立，同其他局部范围相互影响较小，且实体个数适量。</p><h4 id="选择实体"><a href="#选择实体" class="headerlink" title="选择实体"></a>选择实体</h4><p>在确定的局部范围内选择一些合适的信息单位作为局部信息结构的基本实体</p><h4 id="选择实体的关键字属性"><a href="#选择实体的关键字属性" class="headerlink" title="选择实体的关键字属性"></a>选择实体的关键字属性</h4><p>实体的存在依赖于关键字的存在。关键字属性确定后，实体的非关键字就易于确定了。</p><h4 id="确定实体间联系"><a href="#确定实体间联系" class="headerlink" title="确定实体间联系"></a>确定实体间联系</h4><p>数据间的联系必须在概念设计时确定。<br>分析实体间是否存在联系的方法：将局部范围内的实体逐一取出与该范围内的其他实体试行匹配，能否找到与两个参加试匹配的实体都有关的问题或同一任务同时使用到参与试匹配的两个实体，存在则它们之间存在联系。</p><h4 id="确定实体属性"><a href="#确定实体属性" class="headerlink" title="确定实体属性"></a>确定实体属性</h4><p>属性分为标识属性和说明属性两类。<br>标识属性作用实体的关键字，说明属性作用描述实体的一般特征</p><p>确定说明属性的基本原则: 说明属性的存在和使用依赖于标识属性。值为单值，不允许嵌套属性和重复组的现象出现在实体中。</p><h3 id="全局信息结构设计"><a href="#全局信息结构设计" class="headerlink" title="全局信息结构设计"></a>全局信息结构设计</h3><p>将所有局部信息结构合并为一个全局信息结构。其必须是所有局部信息结构的全面准确的映像，形成的全局信息结构仍能实现各局部信息结构能实现的需求</p><p>合并是在假设各局部信息结构都说完全一致的前提下进行，即各局部信息结构能满足对于的需求，其内部不存在需要合并的成分。</p><p>由于局部信息结构仅以满足局部应用需求为目标，各个局部信息结构对同一数据对象因各自应用特征不同而可能采取不同处理，及每个开发人员对数据语义理解的差别等待，合并中会出现各种各样的冲突，需要合理的解决冲突才能进行合理的合并产出一个合理的全局信息结构。因此合并是一个不断发现和解决冲突的过程。</p><h4 id="冲突的种类"><a href="#冲突的种类" class="headerlink" title="冲突的种类"></a>冲突的种类</h4><h5 id="属性冲突"><a href="#属性冲突" class="headerlink" title="属性冲突"></a>属性冲突</h5><p>属性值域的冲突，如属性值的类型、取值范围、取值集合的不同<br>属性取值单位冲突，如某个属性有的值用 M 为度量单位，有的用 CM 为度量单位</p><h5 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h5><p>同名异义：不同意义的实体类型或联系类型名在不同的局部应用中具有相同的名字<br>异名同义: 相同意义的实体类型或联系类型名在不同局部应用中具有不同的名字</p><h4 id="结构冲突"><a href="#结构冲突" class="headerlink" title="结构冲突"></a>结构冲突</h4><p>同一对象在一个局部E-R图中作为实体，在另一个局部E-R途中作为属性<br>同一实体在不同E-R图中属性个数和类型不同<br>实体之间的联系在不同的E-R图中是不同的类型</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>对于属性、命名冲突，通常采用讨论、协商等行政手段解决<br>对于结构冲突，须通过认真分析，采用技术手段加以解决</p><p>一个好的全局E-R模型除能反映用户功能需求之外，实体类型个数尽可能少，实体类型所含属性尽可能少，实体间联系无冗余。</p><p>全局E-R模型的优化可通过上述三个条件来完成</p><h2 id="逻辑结构设计方法"><a href="#逻辑结构设计方法" class="headerlink" title="逻辑结构设计方法"></a>逻辑结构设计方法</h2><p>逻辑结构设计是将概念模型转换为具体的 DBMS 所支持的逻辑数据模型，即将E-R图转换为关系模型、对关系数据模型进行优化、设计面向用户的外模式。</p><h3 id="E-R图转换为关系模型"><a href="#E-R图转换为关系模型" class="headerlink" title="E-R图转换为关系模型"></a>E-R图转换为关系模型</h3><h4 id="转换原则"><a href="#转换原则" class="headerlink" title="转换原则"></a>转换原则</h4><ul><li><p>一个实体型转换为一个关系模式。实体的属性转换为关系的属性，实体码作为关系码</p></li><li><p>一个一对一（1:1）联系转换为一个独立的关系模式，可与任意一端对应的关系模式合并。该联系相连的各实体码及联系本身的属性转换为关系的属性，每个实体码为关系候选码</p></li><li><p>一个一对多（1:N）联系转换为一个独立关系模式，可与N端对应的关系模式合并。同样相连的各实体码及联系本身属性均转换为关系的属性，关系的码为N端实体的码</p></li><li><p>一个多对多（M:N）联系转换为一个关系模式，与该联系相连的各实体码及联系本身的实现转换为关系属性，关系的码为各个实体码的组合</p></li><li><p>三个及三个以上实体间的一个多元联系转换为一个关系模式。与该多元联系相连的实体码及联系本身的属性转换为关系的属性，关系码为各个实体的组合</p></li><li><p>相同码的关系模式可合并</p></li></ul><h3 id="数据模型的优化"><a href="#数据模型的优化" class="headerlink" title="数据模型的优化"></a>数据模型的优化</h3><p>关系数据模型的优化通常参考关系规范化理论</p><h4 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h4><ul><li>确定各属性间的函数依赖关系</li><li>对于各关系模式之间的数据依赖进行极小化处理，消除冗余的联系。</li><li>判断每个关系模式的范式，根据实际需要确定最合适的范式</li><li>按需求分析阶段得到的处理要求，分析模式对于应用环境是否合适，去掉是否要对某些模式进行合并或分解</li></ul><h3 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h3><p>将概念模型转换为全局逻辑模型后，可根据局部应用需求，利用视图设计更符合局部用户需要的用户外模式<br>定义数据库全局模式主要从系统时间效率、空间效率、以为会角度出发，用户外模式与模式是相对独立的，因此外模式可注重考虑用户的习惯于方便。</p><ul><li>可通过视图机制在设计用户视图时，重新定义某些属性的别名</li><li>可对不同级别的用户定义不同的视图，保证系统安全性</li><li>简化用户对系统的使用。</li></ul><h2 id="物理设计方法"><a href="#物理设计方法" class="headerlink" title="物理设计方法"></a>物理设计方法</h2><ul><li><p>建立索引，通过 DBMS 提供的有关命令实现（有静态（频率高才用）和动态两种方式）</p></li><li><p>建立聚集，将相关数据集中存放的物理存储技术</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念结构设计方法（概念模式）&quot;&gt;&lt;a href=&quot;#概念结构设计方法（概念模式）&quot; class=&quot;headerlink&quot; title=&quot;概念结构设计方法（概念模式）&quot;&gt;&lt;/a&gt;概念结构设计方法（概念模式）&lt;/h2&gt;&lt;p&gt;概念模式通常采取自顶向下法（实体分析法），通
      
    
    </summary>
    
      <category term="Database basis" scheme="https://owen027.github.io/categories/Database-basis/"/>
    
    
      <category term="database design" scheme="https://owen027.github.io/tags/database-design/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计</title>
    <link href="https://owen027.github.io/2019/09/22/database_design/"/>
    <id>https://owen027.github.io/2019/09/22/database_design/</id>
    <published>2019-09-22T06:04:03.000Z</published>
    <updated>2019-12-25T13:34:08.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><blockquote><p>针对具体的应用场景，使用现有的 DBMS 构建适合的数据库模式，建立数据库及其应用系统，使之能有效的收集、存储、操作和管理数据，满足实际业务中各类用户的应用需求、信息需求和处理需求，这个过程称为数据库设计。</p></blockquote><p>1.数据库生命周期，从演变过程的角度分为两个阶段：分析与设计阶段 和 实现与操作阶段</p><p>1.1 分析与设计阶段细分为四个环节：需求方分析、概念设计、逻辑结构设计和物理结构设计。<br>1.2 实现与操作阶段细分为3个环节：数据库的实现、操作与监督和修改与调整。</p><ol start="2"><li><p>数据库设计主要以满足应用的功能需求和良好的数据库性能为目标。</p></li><li><p>数据库设计是从用户对数据的需求出发，研究并构造数据库的过程，包括两个方面：数据库结构设计（概念、逻辑和物理结构设计）和行为设计（对数据库的操作）</p></li><li><p>数据库设计的优劣，会直接影响当前的应用、数据库应用过程中的维护和生命周期，为使数据库设计更加合理，需要一个有效的指导原则（方法），大体分为三类：直观设计法、规范设计法和计算机辅助设计法。</p></li></ol><p>4.1 直观设计法：利用设计者的经验和技巧来设计数据库模式。此方法缺乏科学理论指导，质量很难保证。<br>4.2 规范设计法：又细分为 新奥尔良设计法、基于 E-R 模型的数据库设计法和基于第三范式的设计方法。<br>4.2.1 新奥尔良设计法：将数据库设计为四个阶段（需求分析、概念结构设计、逻辑结构设计和物理结构设计，注重结构设计）<br>4.2.2 E-R模型数据设计法：在需求分析的基础上用E-R图像构造一个反应现实世界实体之间联系的企业模式，然后将模式转换成某一特定 DBMS 下的概念模式。<br>4.2.3 基于第三范式的设计方法：在需求分析的基础上先确定数据库的模式，属性及属性间的依赖概念性，进行模式分解，规范成若干个第三范式关系模式的集合。</p><ol start="5"><li><p>计算机辅助设计方法：以领域专家的知识或经验为主导，模拟某一规范化设计的方法，通常通过人机交互的方式来完成设计的某些过程。</p></li><li><p>数据库设计的过程六大阶段：需求分析 -&gt; 结构设计（概念、逻辑和物理结构设计）∪ 行为设计（功能、事务和程序设计） -&gt; 数据库实施（加载数据库数据和调试运行应用程序） -&gt; 数据库运行和维护</p></li></ol><pre class="mermaid">graph LRA(需求分析) --> B(结构设计)A --> C(行为设计)B --> D(数据库实施)C --> D(数据库实施)D --> E(数据库运行与维护)</pre><p>数据库设计过程实际是一个反复修改、反复设计的迭代过程。</p><h2 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><blockquote><p>需求分析是数据库设计的起点，直接影响后续阶段的设计和数据库系统能否被合理使用。分四个步骤：确定数据库范围、分析数据应用过程、收集与分析数据和编写需求分析报告。<br>需求分析的目标是了解与分析用户的信息及应用处理的要求，并将结果按一定格式整理形成需求分析报告。</p></blockquote><p><span class="skyblue">数据库设计人员进行需求分析基本方法：听取数据库应用部们人员的报告，并沟通。同时需求分析人员提交一份需求调查表，该表内容主要包括调查的内容和要求提供资料的格式，应用部门的业务人员可根据该表进行准备和提交材料；此外数据库设计人员还需查阅原始资料，及跟班作业等</span></p><h4 id="确定数据库范围"><a href="#确定数据库范围" class="headerlink" title="确定数据库范围"></a>确定数据库范围</h4><p>范围指数据库应支持哪些应用功能。该范围应尽可能的考虑较为广泛的应用部门或领域，充分满足用户的应用功能要求，有效地利用计算机设备及数据库系统的潜在能力。同时还应尽可能考虑将来的应用需求，提高数据库应变能力，避免以后频繁修改。</p><p>满足上述要求的数据库是复杂而庞大的，由于诸多因素的影响，设计人员当首先考虑支持用户工作需要所必须的应用要求。</p><h4 id="应用过程分析"><a href="#应用过程分析" class="headerlink" title="应用过程分析"></a>应用过程分析</h4><p>此过程分析指了解并分析数据与数据处理间的关系。在确定数据库范围后，设计人员应逐次地了解分析每一部门或功能要用到哪些数据、数据的使用顺序、对数据作何处理和处理的策略及处理结果等</p><p>过程分析的结果是数据库结构设计的重要依据。</p><h4 id="收集与分析数据"><a href="#收集与分析数据" class="headerlink" title="收集与分析数据"></a>收集与分析数据</h4><p> 数据收集与分析是指了解并分析数据的组成格式及操作特征，每个数据元素的语义及关系等，并将它们收集起来整理归档。<br> 可从三个方面展开工作：静态结构、动态结构及数据约束。</p><h5 id="静态结构"><a href="#静态结构" class="headerlink" title="静态结构"></a>静态结构</h5><p>静态结构指不施加应用操作于其上时数据的原始状况。通过数据分类表和数据元素表来说明</p><p>1）数据分类表用于数据的总体描述。对于每一客观存在的具有独立意义的单类数据单位应给出其名称、用途、编制者及使用者等说明：</p><table><thead><tr><th style="text-align:center">数据ID</th><th style="text-align:center">数据名</th><th style="text-align:center">用途</th><th style="text-align:center">主人</th><th style="text-align:center">用户</th><th style="text-align:center">来源</th><th style="text-align:center">去向</th><th style="text-align:center">存档时间</th><th style="text-align:center">数据量</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>2）数据元素表<br>数据元素表指通常意义下的数据项或属性。数据分类表中的每一类数据的所有数据元素名称、类型、长度、意义及算法等都应在数据元素表中进行详尽说明。格式如下：</p><table><thead><tr><th style="text-align:center">数据ID</th><th style="text-align:center">数据元素ID</th><th style="text-align:center">元素名</th><th style="text-align:center">意义</th><th style="text-align:center">类型</th><th style="text-align:center">长度</th><th style="text-align:center">算法</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>类型：描述元素的数据特征（字符串、整数型、实数型）</p><h5 id="动态结构"><a href="#动态结构" class="headerlink" title="动态结构"></a>动态结构</h5><p>动态结构指将应用操作施加于数据之上的数据状况，可通过任务分类表和数据操作特征表进行说明</p><p>1）任务分类表<br>根据对数据流程图的分析，可将业务处理过程划分不同任务。 一个任务指为完成某一特定处理功能的相对独立的操作序列。格式如下：</p><table><thead><tr><th style="text-align:center">任务ID</th><th style="text-align:center">名称</th><th style="text-align:center">功能</th><th style="text-align:center">类型</th><th style="text-align:center">主人</th><th style="text-align:center">用户</th><th style="text-align:center">执行日期</th><th style="text-align:center">频率</th><th style="text-align:center">操作过程</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>类型：输入、查询、制表、统计、修改、删除等</p><p>2）数据操作特征表<br>数据操作特征表用来描述任务和数据之间的关系，包括不同任务对数据执行不同操作的频率。一条任务或数据分类表须建立对应的操作特征表。格式如下：</p><table><thead><tr><th style="text-align:center">任务ID</th><th style="text-align:center">数据ID</th><th style="text-align:center">建立</th><th style="text-align:center">查询</th><th style="text-align:center">插入</th><th style="text-align:center">修改</th><th style="text-align:center">删除</th><th style="text-align:center">数据量</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><h5 id="数据约束"><a href="#数据约束" class="headerlink" title="数据约束"></a>数据约束</h5><p>数据约束指使用数据时的特殊要求。主要有四个方面：</p><ol><li>数据的安全保密性，针对不同类型数据的操作权限。</li><li>数据完整性，指数据正确性的约束和验证准则，及一致性保护的要求</li><li>响应时间，主要指某些特点应用要求的数据存取时间限制</li><li>数据恢复，主要指转储及恢复的时机与范围等</li></ol><h4 id="编写需求分析报告"><a href="#编写需求分析报告" class="headerlink" title="编写需求分析报告"></a>编写需求分析报告</h4><p>需求分析报告要求包括6个方面（数据库的应用功能目标（明确数据库应用范围及应达到的应用处理功能）、标明不同用户视图范围）、应用处理过程需求说明、数据字典、数据量、数据约束：</p><h4 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h4><ol><li>要求有数据流程图，反映应用部门原始业务处理的工作流程</li><li>任务分类表，标明不同任务的功能及使用状况</li><li>数据库特征表，标明任务和数据间的联系及不同数据的不同澳洲特征与执行频率</li><li>操作过程说明书，根据流程图、任务分类表及数据特征表等，标明各个任务的主要逻辑执行步骤</li></ol><h4 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h4><p>数据字典是DBS中存储三级结构定义的数据库，通常指数据库系统中各类数据详细描述的集合。功能是存储和检索各种数据描述（元数据），提供对各类数据的集中管理，是一种数据分析、系统设计和管理的有力工具。</p><p>数据字典包括数据分类表、数据元素表和各类原始资料（所有单据、报表、文件及设计所需的原始资料，并根据数据分类表的数据ID统一分类编号）。</p><h3 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h3><p>概念设计结构是在需求分析中产生的需求分析报告基础上按照特定的方法设计满足应用需求的用户信息结构，通常称为概念模型</p><p>概念模型独立于任何软件硬件，主要目标是最大限度的满足应用需求，完全不顾忌软件硬件的限制，尤其是DBMS 的限制，它是一个符合用户要求的趋于理想化的信息结构，常用方法有实体分析法（自顶向下）和属性综合法（自顶向上）</p><h3 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h3><p>逻辑模型是将概念模型转换为等价的、并为特定 DBMS 所支持数据模型的结构。主要有层次、网状、关系模型</p><h4 id="逻辑模型的输入与输出信息"><a href="#逻辑模型的输入与输出信息" class="headerlink" title="逻辑模型的输入与输出信息"></a>逻辑模型的输入与输出信息</h4><p>逻辑模型是在需求分析与概念模型的基础上进行的，主要提供如下输入信息：</p><ol><li>独立于特定 DBMS 的概念模型。</li><li>有关响应时间、安全保密性、数据完整性及恢复方面的要求说明，包括数据的一致性的规则说明。</li><li>数据量及使用频率</li><li>特定 DBMS 特性，包括其支持的数据模型及数据定义语言的说明。</li></ol><p>输出信息：</p><ol><li>一个特定 DBMS 支持的模式（概念模式）</li><li>一个或多个外部视图（子模式）</li><li>物理设计说明，主要有存入数据库中的数据量、使用频率及响应时间要求</li><li>程序设计说明，在需求分析的基础上，根据逻辑模型，编制各程序名、执行逻辑步、存取数据的名、顺序及操作特征（读、写、改、删）的说明。</li></ol><h4 id="逻辑结构设计的步骤"><a href="#逻辑结构设计的步骤" class="headerlink" title="逻辑结构设计的步骤"></a>逻辑结构设计的步骤</h4><pre class="mermaid">graph LRA(概念设计) --> B(模型转换)B --> C(子模型设计)B --> D(应用程序设计说明)C --> E(设计评价)D --> EE --> F(物理设计)</pre><ol><li>模型转换：将概念模型等价转换为特定 DBMS 支持的关系、层次或网站模型</li><li>子模式设计的目标是抽取或导出模式的子集，以构造不同用户使用的局部数据逻辑结构</li><li>应用程序说明是为可实际运行的应用程序设计提供依据与指导，作为设计评价的基础</li><li>设计评价任务是分析并检验模式及子模式的正确性与合理性。</li></ol><h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><p>物理设计指对于一个给定的数据库逻辑结构，研究并构造物理结构的过程，主要是确定数据库在存储设备上的存储结构及存储方法， 因 DBMS 不同可能包括建立索引和聚集等待。</p><h3 id="数据库实施"><a href="#数据库实施" class="headerlink" title="数据库实施"></a>数据库实施</h3><p>本阶段需要完成 加载数据、应用程序设计和数据库试的运行工作</p><p>加载数据：将符合要求的初始数据装载到数据库中，包括数据的收集、分类、整理校验和输入等过程</p><h3 id="数据库运行和维护"><a href="#数据库运行和维护" class="headerlink" title="数据库运行和维护"></a>数据库运行和维护</h3><p>经过试运行后，确认系统无故障或暂未发现故障时，系统才可投入生成实际中运行，随着应用的深入和拓展，可能会暴露原未发现的问题，也有可能对数据的不断增、删、改使系统的物理结构变坏或存取效率下降，或者需要拓展应用功能，这些都需要开发人员做好维护工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概叙&quot;&gt;&lt;a href=&quot;#概叙&quot; class=&quot;headerlink&quot; title=&quot;概叙&quot;&gt;&lt;/a&gt;概叙&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;针对具体的应用场景，使用现有的 DBMS 构建适合的数据库模式，建立数据库及其应用系统，使之能有效的收集、存储、操
      
    
    </summary>
    
      <category term="Database basis" scheme="https://owen027.github.io/categories/Database-basis/"/>
    
    
      <category term="database design" scheme="https://owen027.github.io/tags/database-design/"/>
    
  </entry>
  
  <entry>
    <title>关系数据库的规范化理论</title>
    <link href="https://owen027.github.io/2019/09/19/normalization_theory/"/>
    <id>https://owen027.github.io/2019/09/19/normalization_theory/</id>
    <published>2019-09-19T12:00:02.000Z</published>
    <updated>2019-12-25T13:34:08.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><p>规范化理论研究的是关系模式中各属性间的依赖关系及对其概念性模式性能的影响，它提供了判断关系模式优劣的理论标准，能帮助数据库设计人员预测可能出现的问题。</p><p>规范化理论主要应用于数据库设计中的概念设计阶段。</p><h2 id="关系模式中可能存在的冗余或异常问题"><a href="#关系模式中可能存在的冗余或异常问题" class="headerlink" title="关系模式中可能存在的冗余或异常问题"></a>关系模式中可能存在的冗余或异常问题</h2><p>关系模式可能存在如下问题：</p><ul><li>数据冗余</li></ul><p>数据冗余指同一数据被反复存储的情况。如在一个供应商关系模式中，一个供应商每供应一种货物，其地址就存储一次，如果供应成千上万种货物，地址就会反复成千上完成。</p><ul><li><p>更新异常<br>数据冗余将导致存储空间的浪费和潜 在数据不一致性及修改麻烦问题。如供应1000种货物的供应商的地址信息发生变化，那么需要对这些供应商的地址进行逐一修改，这样就有可能在一个元组中修改了地址，而没修改该另一个元组中同一供应商的地址，从而导致与实际情况不相符</p></li><li><p>插入异常<br>插入异常指应该插入到数据库中的数据不能只需插入操作的情形。</p></li><li><p>删除异常<br>数据的删除操作异常指不应该删除的数据被删除的情形。</p></li></ul><p>产生上述问题的原因，及消除这些问题的方法，都与数据库依赖的概念密切相关。数据依赖是可以作为关系模式的取值的任何一个关系所必须满足的一种约束条件，是通过一个关系中各个元组的某些属性值之间的相等与否体现出来的相互关系。</p><h2 id="函数依赖与关键字"><a href="#函数依赖与关键字" class="headerlink" title="函数依赖与关键字"></a>函数依赖与关键字</h2><p>函数依赖指关系中属性间的对应关系</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设R 为任一给定关系，如果对于 R 中属性 X 的每个值，R 中的属性 Y 只有唯一值与之对应，则称 X 函数决定 Y （Y 函数依赖于 X） 记作 $X\to Y$。 X称为决定因素<br><strong>example:</strong><br><strong>表 T1</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">李梅</td><td style="text-align:center">女</td><td style="text-align:center">C101</td></tr></tbody></table><p>T1中存在如下函数依赖：<br>$SNO\to SName$<br>$SNO\to SSEX$<br>$SNO\to SROOM$</p><p>T1 中的函数依赖关系仅当SNO作为决定因素时存在</p><label>函数依赖是针对关系的所有元组，只要有一个元组的属性值不满足函数依赖的定义，则相对应的依赖就不成立。</label><h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h3><p>设 R 为任一给定定关系，X、Y 为其属性集， 若$X\to Y$,且 X 中的任一真子集 $X^{‘}$都有 Y 函数不依赖于 $X^{‘}$，则 Y 完全依赖于 X</p><p><strong>Example：</strong></p><p><strong>表 T2</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">课程编号（CNO）</th><th style="text-align:center">课程名（CTITLE）</th><th style="text-align:center">授课老师（INAME）</th><th style="text-align:center">成绩（GRADE）</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">201</td><td style="text-align:center">语</td><td style="text-align:center">张三</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">202</td><td style="text-align:center">数</td><td style="text-align:center">李四</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">203</td><td style="text-align:center">英</td><td style="text-align:center">王五</td><td style="text-align:center">60</td></tr></tbody></table><p>T2 中，函数依赖：$（SNO,CNO）\to GRADE$ ，它为完全函数依赖。因为其中单个属性 SNO/CNO 都不能单独决定GRADE</p><h3 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h3><p>设 R 为任一给定关系， X、Y 为其属性集合，若$X\to Y$,且 X 中存在某个真子集 $X^{‘}$满足  $X^{‘}\to Y$  ，则 Y 部分函数依赖于 X。</p><p>T1 中 函数依赖$（SNO,SNAME）\to SSEX$,而其中$SNO\to SSEX$ ,那么 SSEX部分函数依赖于（SNO,SNAME）</p><h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><p>设 R 为任一给定关系， X、Y、Z为不同属性子集，若$X\to Y$,X函数不依赖于Y，$Y\to Z$,则 $X\to Z$,即 Z传递函数依赖于X。</p><p><strong>Example：</strong></p><p>有一个关系模式 T2（BNO(书号),PNAME（出版社名）,PADDRESS（出版社地址））,一种书对应一个唯一的书号，且只能为某一出版社出版；<br>一个出版社只有唯一名称和地址，但一个出版社可出版多种书。<br>那么该关系中存在函数依赖：$BNO \to PNAME$, $PNAME\to PADDRESS$, PNAME函数不依赖于BNO，所以$BNO\to PADDRESS$</p><h3 id="严格的关键字定义"><a href="#严格的关键字定义" class="headerlink" title="严格的关键字定义"></a>严格的关键字定义</h3><p>设 R 为任一给定关系，U 为所有属性集合， X 为 U 的子集，若 U 完全依赖于 X，则 X 为 R 的候选关键字。</p><h2 id="范式与关系规范化过程"><a href="#范式与关系规范化过程" class="headerlink" title="范式与关系规范化过程"></a>范式与关系规范化过程</h2><p>关系数据库中的关系需要满足一定的要求，不同程度的要求称为不同的范式（Normal Form,NF）。</p><h3 id="第一范式-1FN"><a href="#第一范式-1FN" class="headerlink" title="第一范式 1FN"></a>第一范式 1FN</h3><p>设 R 为任一给定关系， R 中每个列和行的交点处的取值都是不可再分的基本元素，则 R 为 1FN。 1FN是范式的最低要求,是一个不含重复组的关系，不存在嵌套结构。</p><p><strong>表 T3 </strong></p><table><caption>学生选课信息表</caption><thead> <tr>    <th>SNO</th>    <th>CNO</th>    <th>CTITLE</th>    <th>INAME</th>    <th>IPLACE</th>    <th>GRADE</th> </tr></thead><tbody><tr><td>1027</td><td>C01</td><td>操作系统</td><td>王五</td><td>东01</td><td>100</td></tr><tr><td>1028</td><td>C02</td><td>数据库</td><td>刘备</td><td>东02</td><td>91</td></tr><tr><td rowspan="2">1029</td><td>C01</td><td>操作系统</td><td>王五</td><td>东01</td><td>88</td></tr><tr><td>C03</td><td>人工智能</td><td>曹操</td><td>东03</td><td>100</td></tr><tr><td>1030</td><td>C04</td><td>C语言</td><td>刘备</td><td>东02</td><td>97</td></tr></tbody></table><p>T3关系是一个非归范式关系，因为 SNO属性中 1029出现重复的组，可将T3转化为 1FN</p><p><strong>T4 1FN</strong></p><table><thead><tr><th style="text-align:center">SNO</th><th style="text-align:center">CNO</th><th style="text-align:center">CTITLE</th><th style="text-align:center">INAME</th><th style="text-align:center">IPLACE</th><th style="text-align:center">GRADE</th></tr></thead><tbody><tr><td style="text-align:center">1027</td><td style="text-align:center">C01</td><td style="text-align:center">操作系统</td><td style="text-align:center">王五</td><td style="text-align:center">东01</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">1028</td><td style="text-align:center">C02</td><td style="text-align:center">数据库</td><td style="text-align:center">刘备</td><td style="text-align:center">东02</td><td style="text-align:center">91</td></tr><tr><td style="text-align:center">1029</td><td style="text-align:center">C01</td><td style="text-align:center">操作系统</td><td style="text-align:center">王五</td><td style="text-align:center">东01</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">1029</td><td style="text-align:center">C03</td><td style="text-align:center">人工智能</td><td style="text-align:center">曹操</td><td style="text-align:center">东03</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">1030</td><td style="text-align:center">C04</td><td style="text-align:center">C语言</td><td style="text-align:center">刘备</td><td style="text-align:center">东02</td><td style="text-align:center">97</td></tr></tbody></table><h3 id="第二范式-2FN"><a href="#第二范式-2FN" class="headerlink" title="第二范式 2FN"></a>第二范式 2FN</h3><p>设 R 为任一给定关系，如果 R 为 1FN，且所有非主属性都完全函数依赖于候选关键字，则 R为 2FN。</p><p><strong>Example：</strong></p><p>T4 中存在着冗余度高、插入和删除操作异常等问题，CTITLE 中都某一课程被多人选修，那么对应的授课老师和地址将反复存储（数据冗余）；若新增一门课程，而没人任何同学选修，则这们课程将无法存储（插入异常）；如果将最后一元组删除，同时会删除C语言这门课程及相关老师和地址等信息（删除异常）；</p><p><span class="red">存在这些问题的原因在于仅有非主属性 GEEADE 完全 依赖于（SNO,CNO）,其他非主属性都只依赖于 CNO ，对于主键（SNO,CNO）为部分依赖</span></p><p><span class="skyblue">通过分解 T4 将部分函数依赖分解成完全函数依赖，得到 2FN</span><br><strong>T4.1</strong></p><table><thead><tr><th style="text-align:center">SNO</th><th style="text-align:center">CNO</th><th style="text-align:center">GRADE</th></tr></thead><tbody><tr><td style="text-align:center">1027</td><td style="text-align:center">C01</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">1028</td><td style="text-align:center">C02</td><td style="text-align:center">91</td></tr><tr><td style="text-align:center">1029</td><td style="text-align:center">C01</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">1029</td><td style="text-align:center">C03</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">1030</td><td style="text-align:center">C04</td><td style="text-align:center">97</td></tr></tbody></table><p><strong>T4.2</strong></p><table><thead><tr><th style="text-align:center">CNO</th><th style="text-align:center">CTITLE</th><th style="text-align:center">INAME</th><th style="text-align:center">IPLACE</th></tr></thead><tbody><tr><td style="text-align:center">C01</td><td style="text-align:center">操作系统</td><td style="text-align:center">王五</td><td style="text-align:center">东01</td></tr><tr><td style="text-align:center">C02</td><td style="text-align:center">数据库</td><td style="text-align:center">刘备</td><td style="text-align:center">东02</td></tr><tr><td style="text-align:center">C03</td><td style="text-align:center">人工智能</td><td style="text-align:center">曹操</td><td style="text-align:center">东03</td></tr><tr><td style="text-align:center">C04</td><td style="text-align:center">C语言</td><td style="text-align:center">刘备</td><td style="text-align:center">东02</td></tr></tbody></table><p>此时的 T4.2依然存在插入、删除操作及修改麻烦等异常问题。如:将一位新老师插入 T4.2表中，但这位老师暂无任何教学工作，因缺关键字 CNO的值而不能执行插入操作。</p><p><span class="red">原因在于：T4.2 关系中存在非主属性对主属性的传递函数依赖，须进一步分解。</span></p><h3 id="第三范式-3FN"><a href="#第三范式-3FN" class="headerlink" title="第三范式 3FN"></a>第三范式 3FN</h3><p>设 R 未任一给定关系， 如 R 未 2FN，且每一个非主属性都不传递依赖于候选关键字，则 R 为3FN。</p><p><strong>Example：</strong></p><p><span class="skyblue">通过分解 T4.2 将传递函数依赖分解成完全函数依赖，得到 3FN</span></p><p><strong>T4.2.1</strong></p><table><thead><tr><th style="text-align:center">CNO</th><th style="text-align:center">CTITLE</th><th style="text-align:center">INAME</th></tr></thead><tbody><tr><td style="text-align:center">C01</td><td style="text-align:center">操作系统</td><td style="text-align:center">王五</td></tr><tr><td style="text-align:center">C02</td><td style="text-align:center">数据库</td><td style="text-align:center">刘备</td></tr><tr><td style="text-align:center">C03</td><td style="text-align:center">人工智能</td><td style="text-align:center">曹操</td></tr><tr><td style="text-align:center">C04</td><td style="text-align:center">C语言</td><td style="text-align:center">刘备</td></tr></tbody></table><p><strong>T4.2.2</strong></p><table><thead><tr><th style="text-align:center">INAME</th><th style="text-align:center">IPLACE</th></tr></thead><tbody><tr><td style="text-align:center">王五</td><td style="text-align:center">东01</td></tr><tr><td style="text-align:center">刘备</td><td style="text-align:center">东02</td></tr><tr><td style="text-align:center">曹操</td><td style="text-align:center">东03</td></tr></tbody></table><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>通常 3FN 大多数能解决插入和删除操作异常的问题，数据冗余也能得到有效控制。为解决3FN有时出现的操作问题，R.F.Boyce和E.F.Codd 提出 改进范式 BCNF</p><p>设 R 为任一给定关系，X、Y 为属性集，F为其函数依赖集， 若 R 为 3NF，且 F 中所有函数依赖 $X\to Y$ (Y 不属于 X)中 X 必须包含候选关键字，则 R 为 BCNF。<span class="red"> 即 R中每一函数依赖的决定因素X（可为单一属性或组合属性） 都包含 候选关键字，则 R 为 BCNF。</span></p><p>当所有属性集合为候选关键字时依然会存在操作异常和数据冗余等问题<br><strong>Example：</strong></p><p><strong>表  T5</strong></p><table><thead><tr><th style="text-align:center">SNO</th><th style="text-align:center">CTITLE</th><th style="text-align:center">TNAME</th></tr></thead><tbody><tr><td style="text-align:center">S01</td><td style="text-align:center">操作系统</td><td style="text-align:center">王五</td></tr><tr><td style="text-align:center">S02</td><td style="text-align:center">人工智能</td><td style="text-align:center">曹操</td></tr><tr><td style="text-align:center">S02</td><td style="text-align:center">数据库</td><td style="text-align:center">刘备</td></tr><tr><td style="text-align:center">S03</td><td style="text-align:center">数据库</td><td style="text-align:center">孙权</td></tr></tbody></table><p>T5中新增一门课程和一位老师的数据时，须至少有一位学生选修该课且指导老师已被分配才能插入T5中。</p><p><span class="skyblue">此时可通过公共的函数依赖将 T5分解位为 T5.1 和 T5.2</span></p><p><strong>T5.1</strong></p><table><thead><tr><th style="text-align:center">SNO</th><th style="text-align:center">TNAME</th></tr></thead><tbody><tr><td style="text-align:center">S01</td><td style="text-align:center">王五</td></tr><tr><td style="text-align:center">S02</td><td style="text-align:center">曹操</td></tr><tr><td style="text-align:center">S02</td><td style="text-align:center">刘备</td></tr><tr><td style="text-align:center">S03</td><td style="text-align:center">孙权</td></tr></tbody></table><p><strong>T5.2</strong></p><table><thead><tr><th style="text-align:center">TNAME</th><th style="text-align:center">CTITLE</th></tr></thead><tbody><tr><td style="text-align:center">王五</td><td style="text-align:center">操作系统</td></tr><tr><td style="text-align:center">曹操</td><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">刘备</td><td style="text-align:center">人工智能</td></tr><tr><td style="text-align:center">孙权</td><td style="text-align:center">C语言</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概叙&quot;&gt;&lt;a href=&quot;#概叙&quot; class=&quot;headerlink&quot; title=&quot;概叙&quot;&gt;&lt;/a&gt;概叙&lt;/h2&gt;&lt;p&gt;规范化理论研究的是关系模式中各属性间的依赖关系及对其概念性模式性能的影响，它提供了判断关系模式优劣的理论标准，能帮助数据库设计人员预测可能出
      
    
    </summary>
    
      <category term="Database basis" scheme="https://owen027.github.io/categories/Database-basis/"/>
    
    
      <category term="normalization theroy" scheme="https://owen027.github.io/tags/normalization-theroy/"/>
    
  </entry>
  
  <entry>
    <title>关系数据模型要素三 关系完整性约束</title>
    <link href="https://owen027.github.io/2019/09/19/integrity_constraint_of_relational/"/>
    <id>https://owen027.github.io/2019/09/19/integrity_constraint_of_relational/</id>
    <published>2019-09-19T11:18:07.000Z</published>
    <updated>2019-12-25T13:34:08.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> 数据完整性指数据库中数据的<strong>正确性、相容性和一致性</strong>。包括现实世界中的应用需求的完整性。数据的完整性由完整性规则来定义。</p><p>关系模型的完整性规则是对关系的某种约束，提供一种手段来保证用户对数据库的修改时不会破坏数据库中数据的完整性。保证数据是有意义的。</p><p>关系模型分三类约束：实体完整性约束、参照完整性约束和用户自定义完整性约束。 <strong>前两者是必须满足的条件，称作关系的两个不变性</strong>。由DBMS自动支持</p><h3 id="实体完整性约束（Entity-Integrity-Constraint）"><a href="#实体完整性约束（Entity-Integrity-Constraint）" class="headerlink" title="实体完整性约束（Entity Integrity Constraint）"></a>实体完整性约束（Entity Integrity Constraint）</h3><p>此约束指关系的主属性，主码不能为空，在关系数据库系统中，一个关系对应一张表，实体完整性指在数据存储数据的表中，主键/码不能取控值 NULL</p><h3 id="参照完整性约束-（Referential-Integrity-Constraint）"><a href="#参照完整性约束-（Referential-Integrity-Constraint）" class="headerlink" title="参照完整性约束 （Referential Integrity Constraint）"></a>参照完整性约束 （Referential Integrity Constraint）</h3><p>现实世界中实体之间往往存在某种联系，在关系模型中这种联系通过关系来描述</p><blockquote><p>参照完整性约束就说定义外码和主码之间的引用规则，是对关系间引用数据的一种限制。若属性（属性组）X 是基本关系 R 的外码，它与基本关系 S 的主码 Y 对应，那么 R 中每个元组在 F 上的值要么取 NULL，要么等于 S中对应元组的主码值。 R 和 S 可以是不同的关系，也可以是同一关系。</p></blockquote><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">教师（职工号，姓名，性别，系编号）</span><br><span class="line">系（系编号，系名，办公地点）</span><br></pre></td></tr></table></figure></p><p>上述两个关系之间存在属性的引用，系编码既是 <code>系</code> 关系的主码又是<code>教师</code>关系的外部码。那么<code>教师</code> 关系中系编码属性的取值需要参照 <code>系</code>关系中系编码的值或为 NULL。</p><h3 id="用户定义完整性约束-（User-defined-Integrity-constraint）"><a href="#用户定义完整性约束-（User-defined-Integrity-constraint）" class="headerlink" title="用户定义完整性约束 （User-defined Integrity constraint）"></a>用户定义完整性约束 （User-defined Integrity constraint）</h3><p>此约束针对某一应用环境的完整性约束条件，反映了某一具体应用所涉及的数据应满足的要求。关系模型提供定义和检验的机制，此类规则一般在建立数据库表的同时进行定义，如果某些条件未建立在库表一级，则应在各个模块的具体编程中通过程序进行检查和控制。</p><h3 id="关系模型完整性约束检验-重点"><a href="#关系模型完整性约束检验-重点" class="headerlink" title="关系模型完整性约束检验   重点"></a>关系模型完整性约束检验   <label style="color:red; ">重点</label></h3><p>在对数据库进行修改时须检验是否满足对上述三类完整性约束</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>首先检查实体完整性约束，检查插入行在主码属性上的值是否已存在，不存在，可以执行插入，否则不可插入。再检查参照完整性约束，如果是向被参照关系插入，则不需要考虑此约束；如果向参照关系插入，则检查插入行在外码属性上的值是否已在相应被参照关系的主码属性中存在，存在，可插入，否则不可插入，或者将插入行的外码属性的值改为NULL，再插入，最后检查自定义完整性约束，包括数据的类性、精度、取值范围、是否允许空值、是否有默认值等，满足即可执行插入操作，否则给出错误信息。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>一般只需对被参照关系检查参照完整性约束。如果主键被引用则不可删，或将参照关系中对应行的外码属性改为为NULL，再删除</p><h4 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h4><p>结合删除 和 插入操作，先删除再插入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt; 数据完整性指数据库中数据的&lt;strong&gt;正确性、相容性和一致性&lt;/strong&gt;。包括现实世界中的应用需求的完整性。数据的完整性由完整性
      
    
    </summary>
    
      <category term="Database basis" scheme="https://owen027.github.io/categories/Database-basis/"/>
    
    
      <category term="integrity constraint of relational" scheme="https://owen027.github.io/tags/integrity-constraint-of-relational/"/>
    
  </entry>
  
  <entry>
    <title>关系数据模型要素二 （关系操作集合）</title>
    <link href="https://owen027.github.io/2019/09/18/relational_operation/"/>
    <id>https://owen027.github.io/2019/09/18/relational_operation/</id>
    <published>2019-09-18T11:15:49.000Z</published>
    <updated>2019-12-25T13:34:08.625Z</updated>
    
    <content type="html"><![CDATA[ <link href="/static/css/relation_data_model.css" rel="stylesheet" type="text/css"><h3 id="基本的关系操作"><a href="#基本的关系操作" class="headerlink" title="基本的关系操作"></a>基本的关系操作</h3><p>增（插入 Insert）、删(Delete)、改(Update)、查（Query）。关系的查询表达能力是关系操作最主要的部分。查又可分为选择、投影、连接、除、并、差、交、笛卡尔积。集合操作方式（操作的对象和结果都是集合）。又称为一次一集合（set-at-a-time）</p><h3 id="关系数据语言的分类"><a href="#关系数据语言的分类" class="headerlink" title="关系数据语言的分类"></a>关系数据语言的分类</h3><p>通过关系语言实现关系操作。<label>它高度非过程化</label>用户不必请求DBM为其建立特殊的存取路径，由 DBMS 的优化机制来完成。</p><ol><li>代数方式：主要有关系代数，通过对关系的操作来表达查询要求</li><li>逻辑方式：主要有关系演算，是用谓词来表达查询要求，关系演算又按谓词变元的基本对象（元组变量或域变量），分为元组关系演算和域关系演算。</li><li>介于前两者之间的结构化查询语言（Structured Query Language,SQL）：SQL具有丰富的查询功能、数据定义和数据控制功能。集查询、数据定义语言（DDL）、数据操作语言（DML）和数据控制语言（Data Control Language, DCL）于一体；是关系数据库的标准语言。</li></ol><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>关系代数是关系操作语言中的传统表示方式，以集合代数为基础发展而来。任何一种操作都是将一定的操作符作用域一定的操作对象上，得到预期的操作结果。</p><p><label>操作包含三大要素：操作对象、操作符、操作结果。</label>而对象和结果均为关系。关系代数直接应用关系的运算来表达操作的目的，运算符包括集合运算符和专门的关系运算符。</p><table cellpadding="5" id="operator"><caption>关系代数的运算符</caption><thead><th colspan="2">运算符</th><th>含义</th></thead><tbody><tr><td rowspan="4">集合运算符</td><td>∪</td><td>并</td></tr><tr><td>−</td><td>差</td></tr><tr><td>∩</td><td>交</td></tr><tr><td>×</td><td>笛卡尔积</td></tr><tr><td rowspan="4">专门的关系运算符</td><td>σ</td><td>选择</td></tr><tr><td>π</td><td>投影</td></tr><tr><td>⋈</td><td>连接</td></tr><tr><td>÷</td><td>除</td></tr><tr><td rowspan="6">比较操作符</td><td> > </td><td>大于</td></tr><tr><td>≥</td><td>大于等于</td></tr><tr><td> < </td><td>小于</td></tr><tr><td>≤</td><td>小于等于</td></tr><tr><td>＝</td><td>等于</td></tr><tr><td>≠</td><td>不等于</td></tr><tr><td rowspan="3">比较操作符</td><td> ¬ </td><td>非</td></tr><tr><td>∧</td><td>与</td></tr><tr><td> ∨ </td><td>或</td></tr></tbody></table><p>关系代数操作经过有限次复合的式子称为关系代数操作表达式（关系代数表达式），可使用表达式表示所需要执行的各种数据查询和修改处理，所有关系代数是一种抽象的查询语言，通过对关系的操作来表达查询。</p><p>按运算符分类，关系代数操作可分为：传统的集合运算和专门的关系运算</p><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>传统集合运算是二目运算，将关系看成元组集合，运算从行的角度来进行，具有 并、差、交、迪卡尔积四种运算。</p><p><strong>Example：</strong></p><p><strong>表 T1</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">李梅</td><td style="text-align:center">女</td><td style="text-align:center">C101</td></tr></tbody></table><p><strong>表 T2</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0004</td><td style="text-align:center">刘八</td><td style="text-align:center">男</td><td style="text-align:center">D101</td></tr><tr><td style="text-align:center">0005</td><td style="text-align:center">赵二</td><td style="text-align:center">男</td><td style="text-align:center">B201</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">李梅</td><td style="text-align:center">女</td><td style="text-align:center">C101</td></tr></tbody></table><h4 id="并（UNION）"><a href="#并（UNION）" class="headerlink" title="并（UNION）"></a>并（UNION）</h4><p>表T1 和 表T2 使用并运算产生一个新表T3，（T3 = T1 ∪ T2）它是由T1和T2所有不同元组所组成，且 T1和T2属性个数、值域相同。下表为 T1 ∪ T2的结果<br><strong>表 T3</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">李梅</td><td style="text-align:center">女</td><td style="text-align:center">C101</td></tr><tr><td style="text-align:center">0004</td><td style="text-align:center">刘八</td><td style="text-align:center">男</td><td style="text-align:center">D101</td></tr><tr><td style="text-align:center">0005</td><td style="text-align:center">赵二</td><td style="text-align:center">男</td><td style="text-align:center">B201</td></tr></tbody></table><h4 id="差（DIFFERENCE）"><a href="#差（DIFFERENCE）" class="headerlink" title="差（DIFFERENCE）"></a>差（DIFFERENCE）</h4><p>表T1 和 表T2 使用差运算产生一个新表T4，（T4 = T1 - T2）它有T1的所有元组但不包含T2的元组，且 T1和T2属性个数、值域必须相同。下表为 T1 - T2的结果</p><p><strong>表 T4</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">男</td><td style="text-align:center">N101</td></tr></tbody></table><h4 id="交（INTERSECTION）"><a href="#交（INTERSECTION）" class="headerlink" title="交（INTERSECTION）"></a>交（INTERSECTION）</h4><p>表T1 和 表T2 使用交运算产生一个新表T5，（T5 = T1 ∩ T2）它同时包含T1和T2相同的所有元组，且 T1和T2属性个数、值域必须相同，交运算可由差运算表示（T1∩T2 = T1-(T1-T2)）。下表为 T1 ∩ T2的结果</p><p><strong>表 T5</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">性别(SSEX)</th><th style="text-align:center">宿舍(SROOM)</th></tr></thead><tbody><tr><td style="text-align:center">0003</td><td style="text-align:center">李梅</td><td style="text-align:center">女</td><td style="text-align:center">C101</td></tr></tbody></table><h5 id="笛卡尔积（CARTESIAN-PRODUCT）"><a href="#笛卡尔积（CARTESIAN-PRODUCT）" class="headerlink" title="笛卡尔积（CARTESIAN PRODUCT）"></a>笛卡尔积（CARTESIAN PRODUCT）</h5><p>表T6 和 表T7 使用笛卡尔积运算产生一个新表T8，（T8 = T6 × T7）它是T6和T7的所有元组连接而成，即将两张表的元关系合并，且T6的每一元组都对应T7所有的元组<br>下表为 T6 × T7的结果</p><p><strong>表 T6</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td></tr></tbody></table><p><strong>表 T7</strong></p><table><thead><tr><th style="text-align:center">课程号（CNO）</th><th style="text-align:center">课程名（CNAME）</th><th style="text-align:center">教室(SSEX)</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">数据库</td><td style="text-align:center">C-101</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">操作系统</td><td style="text-align:center">C-102</td></tr></tbody></table><p><strong>表 T8</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">课程号（CNO）</th><th style="text-align:center">课程名（CNAME）</th><th style="text-align:center">教室(SSEX)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">1</td><td style="text-align:center">数据库</td><td style="text-align:center">C-101</td></tr><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">2</td><td style="text-align:center">操作系统</td><td style="text-align:center">C-102</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">1</td><td style="text-align:center">数据库</td><td style="text-align:center">C-101</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">王二</td><td style="text-align:center">2</td><td style="text-align:center">操作系统</td><td style="text-align:center">C-102</td></tr></tbody></table><h3 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h3><p>此运算即涉及行，又涉及列，分为一元专门关系操作和二元专门关系操作</p><ul><li>一元关系操作：对单个关系进行垂直分解的投影运算和进行水平分解选择运算</li><li>二元关系操作：对两个关系进行操作，包括连运算和除运算</li></ul><h4 id="选择（SELECT）"><a href="#选择（SELECT）" class="headerlink" title="选择（SELECT）"></a>选择（SELECT）</h4><p>选择运算( $σ_F(R)$ )，F为条件表达式，R为指定的被运算关系名。 从指定关系中选取满足条件的若干元组组成一个新关系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 关系名 <span class="keyword">WHERE</span> 条件语句（表达式）</span><br></pre></td></tr></table></figure></p><p>条件语句：由常数、属性名或列名、比较操作符及逻辑操作符组成</p><p><strong>Example：</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T8 <span class="keyword">WHERE</span> 姓名 = <span class="string">"张三"</span></span><br></pre></td></tr></table></figure></p><p><strong>表 T9</strong></p><table><thead><tr><th style="text-align:center">学号（SNO）</th><th style="text-align:center">姓名（SNAME）</th><th style="text-align:center">课程号（CNO）</th><th style="text-align:center">课程名（CNAME）</th><th style="text-align:center">教室(SSEX)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">1</td><td style="text-align:center">数据库</td><td style="text-align:center">C-101</td></tr><tr><td style="text-align:center">0001</td><td style="text-align:center">张三</td><td style="text-align:center">2</td><td style="text-align:center">操作系统</td><td style="text-align:center">C-102</td></tr></tbody></table><h4 id="投影（PROJECTION）"><a href="#投影（PROJECTION）" class="headerlink" title="投影（PROJECTION）"></a>投影（PROJECTION）</h4><p>投影运算( $π_A(R)$ ), R为被运算关系，A为属性序列，从指定关系中选取指定的若干属性值组成新关系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROJECTION 关系名 ( 属性名1, 属性名2 ,... )</span><br></pre></td></tr></table></figure></p><p>组成的新关系自动去重</p><p><strong>Example：</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROJECTION T8 (课程号,课程名)</span><br></pre></td></tr></table></figure></p><p><strong>表 T10</strong></p><table><thead><tr><th style="text-align:center">课程号（CNO）</th><th style="text-align:center">课程名（CNAME）</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">操作系统</td></tr></tbody></table><h4 id="θ连接（JOIN）"><a href="#θ连接（JOIN）" class="headerlink" title="θ连接（JOIN）"></a>θ连接（JOIN）</h4><p>连接运算（$R\cfrac{⋈}{xθy}S$）,其中，R和S 代表两个不同的关系；x 和 y 分别表示R中的第x列和S中的第y列属性；θ表示比较运算符，从笛卡尔积R×S中选取R的第x列属性值与S的第y列属性值满足θ的那些元组组成一个新关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JOIN 关系1 AND 关系2 WHERE 条件语句</span><br></pre></td></tr></table></figure><p>条件语句：由比较操作符和属性名或列名组成的表达式</p><ul><li>等值连接：θ值为 “=”，从R和S的笛卡尔积中选取 x、y 属性值相等的元组</li></ul><p><strong>Example：</strong></p><p><strong>表 T11</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">e</td><td style="text-align:center">f</td></tr></tbody></table><p><strong>表 T12</strong></p><table><thead><tr><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">A</th></tr></thead><tbody><tr><td style="text-align:center">g</td><td style="text-align:center">h</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JOIN  T11 AND T12 WHERE B= A</span><br></pre></td></tr></table></figure><p><strong>T11 × T12</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">A</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">g</td><td style="text-align:center">h</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">g</td><td style="text-align:center">h</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td></tr></tbody></table><p>等值结果为：</p><p><strong>表 T13</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">A</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td></tr></tbody></table><ul><li>自然连接：是一种特殊的等值连接，要求两个关系中比较的分量必须是 <span style="color:red">相同的属性组，且结果中去除重复的属性列</span></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JOIN  T11 AND T12 WHERE A = A</span><br></pre></td></tr></table></figure><p><strong>表 T14</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">g</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">b</td><td style="text-align:center">c</td></tr></tbody></table><p>自然连接是构造新关系的有效方法，投影和选择是分解关系的有效方法，自然连接中如果两个关系没有公共属性则变成笛卡尔积</p><h4 id="除（DIVISION）"><a href="#除（DIVISION）" class="headerlink" title="除（DIVISION）"></a>除（DIVISION）</h4><p>除运算（R÷S） R和S代表两个不同的关系。<br>假如被除关系R 为 m 元关系，除关系S 为 n 元关系，则运算结果的新关系为 m-n元关系。</p><p><strong>Example 1：</strong></p><p><strong>表 T15</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">F</th><th style="text-align:center">G</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">j</td><td style="text-align:center">k</td><td style="text-align:center">l</td><td style="text-align:center">m</td><td style="text-align:center">n</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">c</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">b</td><td style="text-align:center">m</td><td style="text-align:center">n</td></tr></tbody></table><p><strong>表 T16</strong></p><table><thead><tr><th style="text-align:center">F</th><th style="text-align:center">G</th></tr></thead><tbody><tr><td style="text-align:center">f</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">n</td></tr></tbody></table><p>运算步骤：</p><ol><li>被除关系R对除关系S不同的属性 X 进行投影</li></ol><p><strong>X 投影</strong></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">d</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">j</td><td style="text-align:center">k</td><td style="text-align:center">l</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">c</td><td style="text-align:center">e</td><td style="text-align:center">f</td><td style="text-align:center">b</td></tr></tbody></table><p>待续。。。</p><ol start="2"><li>提取每个属性集值对应S元关系的象集</li></ol><p>2.1 |a|b|c|d|e| 值的象集</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">f</td><td style="text-align:center">g</td></tr></tbody></table><p>2.2 |h|i|j|k|l| 值的象集</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">m</td><td style="text-align:center">n</td></tr></tbody></table><p>2.3 |a|b|c|a|b| 值的象集</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">c</td><td style="text-align:center">d</td></tr></tbody></table><p>2.4 |a|c|e|f|b| 值的象集</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">m</td><td style="text-align:center">n</td></tr></tbody></table><ol start="3"><li>S 关系在公共属性 F G 的投影</li></ol><table><thead><tr><th style="text-align:center">F</th><th style="text-align:center">G</th></tr></thead><tbody><tr><td style="text-align:center">f</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">n</td></tr></tbody></table><p>通过 3 和 2 的对比 R÷S 为空</p><p><strong>Example 2：</strong><br>待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
         &lt;link href=&quot;/static/css/relation_data_model.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;

&lt;h3 id=&quot;基本的关系操作&quot;&gt;&lt;a href=&quot;#基本的关系操作&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Database basis" scheme="https://owen027.github.io/categories/Database-basis/"/>
    
    
      <category term="relational operation" scheme="https://owen027.github.io/tags/relational-operation/"/>
    
  </entry>
  
  <entry>
    <title>关系数据模型要素一 （关系数据结构）</title>
    <link href="https://owen027.github.io/2019/09/09/relation_data_model/"/>
    <id>https://owen027.github.io/2019/09/09/relation_data_model/</id>
    <published>2019-09-09T13:37:35.000Z</published>
    <updated>2019-12-25T13:34:08.624Z</updated>
    
    <content type="html"><![CDATA[<link href="/static/css/relation_data_model.css" rel="stylesheet" type="text/css"><h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><p>关系数据库的基本特征是使用关系模型的组织数据，20世纪80年代以后，在商用DBMS中，关系模型逐步取代早期的网状模型和层次模型。</p><h2 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h2><p>作为数据模型，关系模型包含三个组成要素：关系数据结构、关系操作集合和关系完整性约束。</p><h3 id="关系数据结构-重点"><a href="#关系数据结构-重点" class="headerlink" title="关系数据结构  重点"></a>关系数据结构  <label style="color:red; ">重点</label></h3><p> 结构只包含单一的数据结构（关系），现实世界的实体与实体间的各种联系均用关系来表示。关系模型是把数据库表示为关系的集合，并以二维表格的形式组织数据。</p><p> 录入一张二维表格如：</p><table><thead><tr><th>学号</th><th>姓名</th><th>性别</th><th>籍贯</th><th>民族</th><th>…</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>男</td><td>陕西</td><td>汉</td><td>…</td></tr><tr><td>002</td><td>李四</td><td>男</td><td>湘西</td><td>苗</td><td>…</td></tr><tr><td>003</td><td>王五</td><td>男</td><td>河北</td><td>汉</td><td>…</td></tr><tr><td>004</td><td>赵六</td><td>男</td><td>东北</td><td>汉</td><td>…</td></tr><tr><td>…</td></tr></tbody></table><h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><ol><li>表(Table)：也称为关系，是二维数据结构，由表名、构成表的各列及若干行数据组成，每个表由唯一的表名，每一行数据描述一条具体的记录值。</li><li>关系（Relation）：一个关系逻辑上对应一张二维表，可以为每个关系取一个名称来标识。关系有三种类型：基本关系（基表，实际存在的表，是实际存储数据的逻辑表示）、查询表（查询结构对应的表）和视图表（由基本表或其他视图导出的表，不对应实际存储的数据）。</li><li>列（Column）：称为字段（Field）或属性（Attribute）。每一列有一个名称，表示实体属性，具有相同数据类型。在一个数据库中，表名，字段名必须唯一，不同的表可以有相同的字段名，且命名须有意义，简单。</li><li>属性（Attribute）：表列即属性，给属性起名即属性名。属性的个数称为关系的元或度。列值为属性值；取值范围为值域。</li><li>行（Row）：称为元组（Tuple）或记录（Record）。表中的数据按行存储，一行数据即一条记录或元组，每行又若干个字段值组成。</li><li>分量（Component）：元组的属性值为分量</li><li>码/键（key）：在一个关系中，有一个属性或属性组，能用来标识该关系的元组，则为该关系的码或键。</li><li>超码或超键（Super Key）：从码中去除某个属性，它仍然是对应关系的码，则为超码；每个关系至少有一个默认的超码（所有属性的集合）。</li><li>候选码或键（Candidate Key）：关系中的一个码或键中，不能去除任何一个属性，否则它就不是对应关系表的码或键，则此码为候选码（键），它是关系表中最小的超码或超键。</li><li>主键/码(Primary Key)：在一张关系表中的若干候选键中指定一个用来唯一标识该关系的元组，则该候选键为主键。</li><li>全键/码（All-Key）：一个关系中所有的属性集合是是这个关系是主键/码，则为全键/码。</li><li>主/非属性（Primary Attribute/Nonprimary Attribute）：关系中包含任何一个候选键/码的属性为主/码属性，不包含任何一个候选码的属性为非主/码属性。</li><li>外键/码（Foreign Key）：关系中的某个属性或属性组不是这个关系的主键或候选键，而是另一个关系的主键，则该属性（属性组）为关系的外键/码。</li><li>参照关系(Referencing Relation)/被参照关系（Referenced Relation）：参照关系也称从关系，被参照关系又称主关系，它们指以外码相关联的两个关系。而以外码为主码的关系为被参照关系；外码所在的关系为参照关系，这种联系通常是一对多关联。</li><li>域（Domain）：指属性取值范围。</li><li>数据类型（Data Type）：每列（元关系）都有相应的数据类型，用于限制该列中存储的数据。</li><li>关系模式（Relation Schema）：通数据模型一样，数据库也有型和值，在关系数据库中关系模式是型，关系是值，关系模式是对关系的描述。</li></ol><table><thead><tr><th style="text-align:center">中文字段名</th><th style="text-align:center">数据类型</th><th style="text-align:center">宽度</th><th style="text-align:center">…</th></tr></thead><tbody><tr><td style="text-align:center">学号</td><td style="text-align:center">字符类型</td><td style="text-align:center">8</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">姓名</td><td style="text-align:center">字符类型</td><td style="text-align:center">10</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">身份证</td><td style="text-align:center">字符类型</td><td style="text-align:center">18</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>上表是学生基本星系登记表关系的结构定义，关系则是元组的集合，是关系模式在某一时刻的状态或内容</p><p><label>关系模式是静态的、稳定的，而关系是动态的、随时间不断变化，因为关系操作在不断地更新着数据库的数据</label>实际工作中关系模式和关系统称为关系。</p><ol start="18"><li>关系数据库（Relation Database）：以关系模型作为数据的逻辑模型，并采用关系作为数据组织方式的一类数据库，其数据库操作建立在关系代数的基础上。在给定的应用领域中，所以关系的集合构成一个关系数据库。</li></ol><p>在实际的数据库应用系统中，一般使用英文作为表名、字段名等。因为在编写数据库应用程序时，表名、字段名会作为变量名，使用中文不方便标识，且有些DBMS不能很好的兼容中文。 <label style="color:red; ">重点</label><br>因此上表应该变更为：</p><table><thead><tr><th style="text-align:center">含义</th><th style="text-align:center">字段名</th><th style="text-align:center">数据类型</th><th style="text-align:center">宽度</th><th style="text-align:center">…</th></tr></thead><tbody><tr><td style="text-align:center">学号</td><td style="text-align:center">studentNo</td><td style="text-align:center">字符类型</td><td style="text-align:center">8</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">姓名</td><td style="text-align:center">sutdentName</td><td style="text-align:center">字符类型</td><td style="text-align:center">10</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">身份证</td><td style="text-align:center">studentId</td><td style="text-align:center">字符类型</td><td style="text-align:center">18</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p><strong>关系数据库对关系的限定：</strong></p><ul><li>每个属性都不可分解，是关系数据库对关系的最基本的限定，要求关系的每个分量必须是一个不可分的数据项，即不允许表中有表</li><li>一个关系对应一种关系模式，模式中的属性的数据类型及属性的个数是相对固定的</li><li>每个关系模式中的属性必须命名，在同一模式中，属性名必须是不同的</li><li>同一关系中不允许出现候选码或键值完全相同的元组</li><li>关系中的元组顺序是可任意交换</li><li>关系中的属性顺序可以任意交换</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link href=&quot;/static/css/relation_data_model.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;

&lt;h2 id=&quot;概叙&quot;&gt;&lt;a href=&quot;#概叙&quot; class=&quot;headerlink&quot; title=&quot;概叙&quot;&gt;
      
    
    </summary>
    
      <category term="Database basis" scheme="https://owen027.github.io/categories/Database-basis/"/>
    
    
      <category term="relationDataModel" scheme="https://owen027.github.io/tags/relationDataModel/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础（Database Basis) (二)</title>
    <link href="https://owen027.github.io/2019/09/05/database_basis_2/"/>
    <id>https://owen027.github.io/2019/09/05/database_basis_2/</id>
    <published>2019-09-05T10:50:56.000Z</published>
    <updated>2019-09-24T12:33:09.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><blockquote><p>注：数据库（ DB ）数据库系统（DBS）数据库管理系统（DBMS） 数据库管理员（DBA）<br>在一个DBS中有着不同类型的用户，每个用户都从不同的角度以各自的观点看待数据库，从而形成了DBS不同的视图结构。因此DBS的结构可以有多种不同的层次或不同的视角。</p></blockquote><label>从数据库管理员（DBA）视角来看，DBS分为内部系统结构和外部体系结构，其中内部系统结构通常采用<code>三级模式结构</code>，外部体系结构通常表现为 <code>集中式结构</code>、<code>分布式结构</code>和<code>并行结构</code>等；</label><label>从数据库用户角度分为客户/服务器结构和浏览器/服务器结构，也就是DBS整体的运行与应用结构</label><h3 id="三级模式结构（DBA视角）"><a href="#三级模式结构（DBA视角）" class="headerlink" title="三级模式结构（DBA视角）"></a>三级模式结构（DBA视角）</h3><p>从DBA角度审视数据库系统，其内部基本遵循美国 <code>ANSI/SPAPRC</code> DBMS研究组提出的三体系结构（用户、概念级和物理级）。各个DBMS产品在体系结构上通常具有相同的特征（三级模式结构），并提供两层映像功能。DBS三模式结构是指 模式（Schema）、外模式（External Schema）和 内模式（Internal Schema）。</p><pre class="mermaid">graph LRA(数据库) --> B(内模式)B --内模式/模式映像--> C(模式)C -->  C1(外模式1)C --外模式/模式映像-->  C2(外模式2)C -->  C3(外模式3)C1 --> D1(应用1)C1 --> D2(应用2)C2 --> D3(应用3)C2 --> D4(应用4)C3 --> D5(应用5)C3 --> D6(应用6)</pre><p>外模式的描述向客户提供数据，内模式的描述存储数据，模式是两者的中间层，机不涉及数据的物理存储和硬件环境，也与具体应用程序、开发工具及设计语言无关。</p><p></p><h4>模式</h4><p></p><label>模式也称为概念模式或逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图，即数据在逻辑上的视图（又称概念视图）</label><p>DBA必须考虑整个数据库的全局概念视图，它不包含任何的数据库实现细节，如何种D是BMS、文件组织、存取方法及设备特征等；而是定义数据库的逻辑结构、数据之间的联系，及数据相关的安全性、完整性等要求（由DBMS提供模式描述语言（Schema DDL）），同时一个数据库只有有个模式，且相对稳定。</p><h4 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h4><label>  外模式也称为子模式（Subschema）或用户模式,是数据库用户能看见和使用的局部数据的逻辑结构和特征的描述，是与某一应用有关数据的逻辑表示。（DBMS提供子模式描述语言（Subschema DDL）来严格定义子模式）<br>通常其用于满足不同数据库用户需求的数据视图（用户视图），是模式的子集，对数据库整体数据的局部重构。<br>不同用户在看待数据的方式、应用需求、对数据保密的要求等方面存在差异，对应外模式描述就不同，且模式中同样的数据，在外模式中的结构、类型、长度、保密级别等都可以不同</label><p>外模式是保证数据库安全的重要措施，每个用户只能看见和访问所对应的外模式中的数据，简化了DBS的用户接口，便于用户使用，并有效支持数据独立性和共享性。</p><h4 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h4><p>内模式也称存储模式（Storage Schema）, 是对数据库中的物理结构和存储方式的描述，是数据在数据库内部的表现形式。是整个数据库的最底层表示，它不同于物理层，是DBA所见到的，特定的DBMS所处理的数据库的内部结构（内部视图或存储视图）。</p><label>和模式一样，内模式在一个数据库中只有一个，它不存储设备上的物理记录或物理快，也不涉及任何具体设备限制。</label><h4 id="两层映像与数据独立性-重点"><a href="#两层映像与数据独立性-重点" class="headerlink" title="两层映像与数据独立性 重点"></a>两层映像与数据独立性 <label style="color:red; ">重点</label></h4><p>总体而言，三个模式的对数据的三级抽象，其特点如下：</p><ul><li>一个数据库的整理逻辑结构和特征的描述（概念模式）是独立于数据库其他层次结构（内/外模式）的描述，其是数据库的核心，也是数据库设计的关键。</li><li>一个数据库的内部存储模式依赖于概念模式，并且独立于外部模式和具体的存储设备。</li><li>用户逻辑结构（外模式）是在全局逻辑结构描述的基础上定义的，它面向具体的应用程序，独立于内部模式和存储设备。</li><li>应用程序是在外模式的逻辑结构上编写，依赖于特定的外模式，与数据库的模式和存储结构独立。</li></ul><label>用户不必考虑数据的物理存储细节，将其交给DBMS负责管理，同时为有效支撑数据库的三级抽象及它们之前的联系和相互转换，DBMS通过提供两层映像来实现（外模式/模式 和 模式/内模式）</label><h5 id="映像"><a href="#映像" class="headerlink" title="映像"></a>映像</h5><p>映像是指一种对应规则，指出映像双方如何进行转换。</p><ul><li>外模式/模式映像：定义各个外模式与概念模式之间的映像关系，这些定义通常在各自的外模式中加以描述。DBS的模式如若发生改变（增加新的关系、属性、改变数据类型等)，DBA会对各个映像做出相应改变，使那些对用户可见的外模式保持不变，从而使程序员不必去修改那些依据数据的外模式所编写的程序，这样外模式就不受模式的影响，保证数据与程序的独立性。</li><li>模式/内模式：定义数据库全局逻辑结构与物理存储之间的关系，通常在模式中加以描述。而DB只有一个模式，所以此映像是唯一的。同样，DBS 的物理存储如若发生改变（选用另一个存储结构或更换存储位置），DBA会的此映像做出相应调整，使DBS 的模式保持不变，不必修改应用程序，保证的物理独立性</li></ul><p>因此，两层映像保证了DBS中的数据具有较高的逻辑独立性和物理独立性，使数据的定义和描述可以从应用程序中分离，简化数据库应用程序的开发，减少维护工作量。</p><h3 id="DBS-的运行与应用结构（用户视角）"><a href="#DBS-的运行与应用结构（用户视角）" class="headerlink" title="DBS 的运行与应用结构（用户视角）"></a>DBS 的运行与应用结构（用户视角）</h3><h4 id="客户-服务器结构"><a href="#客户-服务器结构" class="headerlink" title="客户/服务器结构"></a>客户/服务器结构</h4><p>在DBMS中，DB的使用者（程序员，DBA等）可以使用命令行客户端、图形化界面管理工具、应用程序等连接DBMS，通过DBMS查询和处理存储在底层数据库中的各种数据。<label>那些不与DBMS直接联系的工具和程序被称为<code>客户端</code>、<code>前台</code>或<code>表示层</code>，主要完成交互任务，而DBMS称为<code>服务器</code>、<code>后台</code>或<code>数据层</code>，主要负责数据管理。</label> 这种工作模式就是客户/服务器结构(Client/Server,C/S).</p><h4 id="浏览器-服务器结构"><a href="#浏览器-服务器结构" class="headerlink" title="浏览器/服务器结构"></a>浏览器/服务器结构</h4><p>此结构基于Web应用的客户/服务器结构，或者三层客户/服务器结构。<br>在DBS中，它将与DBMS交互的客户端进一步细分为<code>表示层</code>和<code>处理层</code>。</p><p>表示层：指数据库使用者的操作和展示界面，通常由各种浏览器构成<br>处理层（中间层）：负责处理数据库使用者的具体应用逻辑，与后台的DBMS共同组成功能丰富的<code>胖服务器</code> 。</p><p>这种工作模式就是浏览器/服务器结构（Browser/Server，B/S）</p><hr><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><blockquote><p>模型是现实世界特征的模拟和抽象表达，帮助人们更好的认识和理解客观事物、对象和过程等感兴趣的内容（飞机航模、建筑图纸、军事沙盘等）。而数据模型是用来模拟和抽象现实世界中的数据特征，描述的是数据的共性内容。</p></blockquote><h3 id="数据特征与数据模型组成要素"><a href="#数据特征与数据模型组成要素" class="headerlink" title="数据特征与数据模型组成要素"></a>数据特征与数据模型组成要素</h3><p>数据具有静态和动态两种特征。<br>静态特征：数据的基本结构、数据间的联系及对数据取值范围的约束。<br>动态特征：指对数据可以进行符合一定规则的操作。<br><strong>数据模型通常由数据结构、数据操作和数据约束三要素组成：</strong></p><ul><li>数据结构：是描述系统的静态特性，数据对象的类型、内容、属性及数据对象之间的联系。如层次结构、网状结构、关系结构的数据模型分别命名为层次模型、网站模型、关系模型及面向对象模型。</li><li>数据操作：描述的是系统动态特性，是对各种对象的实例允许执行的操作集合，包括操作及相关的操作规则。主要分为更新（增、删、改）和检索两大类。数据模型必须定义这些操作的确切含义、操作符号、操作规则（优先级等）及实现操作的语言。</li><li>数据约束：描述数据结构中国数据间的语法和语义关联，包括相互制约与依存关系及数据动态变化规则，保证数据正确性、有效性与相容性。约束包含数据完整性约束、数据安全性及并发控制约束；数据约束既刻画了数据静态特征，也表示了数据动态行为规则。</li></ul><h3 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h3><p><strong>数据模型应满足三个要求：</strong></p><ol><li>能比较真实的模拟现实世界</li><li>容易使人们理解</li><li>便于在计算机上实现</li></ol><p>目前一种数据模型要完全满足三个要求，很困难，因此需针对不同对象和应用，采取逐步抽象的方法，在不同抽象层使用不同的数据模型。</p><h4 id="概念层数据模型（数据的概念模型-（Conceptual-Model）-信息模型）"><a href="#概念层数据模型（数据的概念模型-（Conceptual-Model）-信息模型）" class="headerlink" title="概念层数据模型（数据的概念模型 （Conceptual Model）,信息模型）"></a>概念层数据模型（数据的概念模型 （Conceptual Model）,信息模型）</h4><p>概念层是数据抽象级别的最高层，目的是按照用户的观点对世界建模。概念层模型用来描述现实世界的事物，是对信息世界建模，与具体的计算机系统无关，独立于任何DBMS，容易向DBMS所支持的逻辑数据库模型转换，此类模型主要用于数据库的设计阶段，表示现实世界的各个事物及其联系。</p><h5 id="信息世界中的基本概念（类似于对象）重点"><a href="#信息世界中的基本概念（类似于对象）重点" class="headerlink" title="信息世界中的基本概念（类似于对象）重点"></a>信息世界中的基本概念（类似于对象）<label style="color:red;">重点</label></h5><p>概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具，是设计人员和用户之间交流的语言，因此概念模型具有较强的语义表达能力，能够方便、直接地表达应用中的各种语义知识，它简单、清晰、易于理解。</p><ul><li>实体（Entity）：客观存在并可相互区别的事物，既可以是实体事物，也可以说抽象的概念或联系（学生、商品、部门、课程、比赛等都可以是实体）</li><li>属性（Attribute）：实体所具有的某种特性，一个实体可以由多个属性描述（性别，名称、日期，年龄等等）</li><li>码或键（Key）：可唯一标识实体的属性集。如学生的学号</li><li>域（Domain）：一个属性的取值范围。如学生实体中姓名的域</li><li>实体型（Entity Type）：具有相同属性的实体必然具有共同的特征和性质。用实体名于属性名集合抽象和刻画同类实体即实体型。（学号，姓名，性别）</li><li>实体集（Entity Set）：同实体的集合。（每个学生是一个实体，所以学生组成实体集）</li><li>联系（Relatinship）：现实世界中，事物内部及事物之间是有联系的，反应到信息世界中即实体（型）内部的联系和实体（型）之间的联系。实体内部的联系通常指各属性之间的联系。如确定学号，即知道对应的姓名，学号与姓名两个属性之间有联系。实体之间的联系指不同实体间的联系。如一个班有许多学生，一个学生只属于一个班级，这是学生与班级两个实体间的联系。</li></ul><p>数据模型中有<code>型【type】</code>（某一类数据的结构和属性说明）和<code>值【value】</code>（对型的赋值）的概念</p><h5 id="概念模型的表示方法"><a href="#概念模型的表示方法" class="headerlink" title="概念模型的表示方法"></a>概念模型的表示方法</h5><p>概念模型的表示方法有很多种，最常用的是实体-联系方法（Entity-Relationship approach）也称E-R模型，它是抽象和描述现实世界的有力工具，它独立于具体的DBMS所支持的逻辑模型，是各种逻辑模型的共同基础。</p><h4 id="逻辑层数据模型"><a href="#逻辑层数据模型" class="headerlink" title="逻辑层数据模型"></a>逻辑层数据模型</h4><p>逻辑层是数据抽象的中间层，描述数据整体逻辑结构；这层的数据抽象被称为逻辑模型，是用户通过DBMS看到的现实世界，基于计算机系统的观点来对数据进行建模和表示。因此，它既要让用户易于理解，又要便于DBMS实现。<br>主要的逻辑数据模型有 层次模型（Hierarchical）、网站模型（Network Model）、关系模型（Relational Model）和面向对象模型（Object Oriented Model）等</p><h5 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h5><p>此模型是数据库最早的一种数据模型，它的数据结构是一颗“有向树”，数的每个结点对应一个记录集。特点：有且仅有一个结点没有父结点（根结点）；其他结点有且仅有一个父结点。</p><h5 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h5><p>此模型以网状结构表示实体与实体之间的联系。是层次模型的扩展，允许结点又多个父结点，且可以有多个节点没有父结点。此模型可以方便的表示实体间各种类型的联系，但结构复杂，实现的算法难以规范化。</p><h5 id="关系模型-重点"><a href="#关系模型-重点" class="headerlink" title="关系模型 重点"></a>关系模型 <label style="color:red;">重点</label></h5><p>此模型用二维表结构来表示实体及实体间联系的模型，并以二维表格的形式组织数据库中的数据。<br><strong>特点：</strong></p><ul><li>建立在严格的数学概念基础之上</li><li>概念单一，统一用关系表示实体及实体间的联系，对数据的检索与更新结果同样也用关系（即表）表示。</li><li>关系模型的存取路径对用户透明，这样就具有更高的数据独立性、更好的安全保密性，简化了程序员的开发工作。目前流行的商用数据库大多基于关系模型（关系数据库管理系统）。</li></ul><h5 id="面向对象模型"><a href="#面向对象模型" class="headerlink" title="面向对象模型"></a>面向对象模型</h5><p>此模型是面向对象方法与数据库相结合所构成的数据模型。它既是概念模型又是逻辑模型。用面向对象观点描述现实世界实体逻辑组织、对象间的联系。</p><h4 id="物理层数据模型"><a href="#物理层数据模型" class="headerlink" title="物理层数据模型"></a>物理层数据模型</h4><p>此模型又叫数据的物理模型，描述数据在存储介质上的组织结构，是逻辑模型的物理实现，每一种逻辑模型在实现时都有与其对应的物理模型。物理模型是数据库最底层的抽象，它确定数据的物理存储结构、数据存取路径及调整、优化数据库的性能。<br>物理数据结构一般向用户屏蔽，用户不必了解其细节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库系统的结构&quot;&gt;&lt;a href=&quot;#数据库系统的结构&quot; class=&quot;headerlink&quot; title=&quot;数据库系统的结构&quot;&gt;&lt;/a&gt;数据库系统的结构&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;注：数据库（ DB ）数据库系统（DBS）数据库管理系统（DBMS
      
    
    </summary>
    
      <category term="Database basis" scheme="https://owen027.github.io/categories/Database-basis/"/>
    
    
      <category term="Database_basis_2" scheme="https://owen027.github.io/tags/Database-basis-2/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础（Database Basis) (一)</title>
    <link href="https://owen027.github.io/2019/09/04/database_basis_1/"/>
    <id>https://owen027.github.io/2019/09/04/database_basis_1/</id>
    <published>2019-09-04T13:50:21.000Z</published>
    <updated>2019-12-25T13:34:08.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h2><p>数据库技术是对数据进行管理的技术，能有科学地管理各类信息资源。数据、数据库、数据库管理系统和数据库系统是数据库常用的基本概念。</p><h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><h3 id="数据（Data）"><a href="#数据（Data）" class="headerlink" title="数据（Data）"></a>数据（Data）</h3><label>数据是描述事物的符号记录，指用物理符号记录下来的、可鉴别的信息。</label><p><strong>数据有多种表现类型：</strong></p><ul><li>文本数据：数字、字母、特殊字母、文字等组成</li><li>多媒体数据：图像、图形、动画、影像、声音、语言等组成</li></ul><p>各种类型的数据经过数字化处理后存入计算机，便于进一步加工、处理、使用</p><p>人们通常只抽取感兴趣的事物特征或属性来描述事物。例如，人们关注客户的姓名、性别、年龄、籍贯、所在地区、联系方式等特征，（张三，男，26，北京，上海，1383838444；）这些具体的特征值就构成一组数据，就是一条记录</p><label> 数据记录往往不能完全表达其内容的含义，还需经过解释才能表达明确含义;</label>如： 张三，男，26岁，北京人，住在上海，联系电话是1383838444；而不了解数据含义的人难以从北京、上海的地名上理解所表达的意思<br>因此数据及关于该数据的解释密切相关，数据的解释是对数据的含义说明，也称数据的语义，即数据所蕴含的信息，没有语义的数据是没有意义和不完整的。<br><br>数据是信息存在的一直形式，只有通过解释或处理的数据才能成为有用的信息。<br><br><br> <h3> 数据库（Database）</h3><br><label>数据库是存储数据的仓库，是有组织的、可共享的数据集合，且数据库中的数据按一定的数据模型组织、描述和永久存储，具有较小的冗余度、较高的数据独立性，系统易于扩展，并可以被多个用户共享</label><h3 id="数据库管理系统（Database-Management-System，DBMS）"><a href="#数据库管理系统（Database-Management-System，DBMS）" class="headerlink" title="数据库管理系统（Database Management System，DBMS）"></a>数据库管理系统（Database Management System，DBMS）</h3><label><br>是一套建立和管理数据库的软件，介于应用程序和操作系统之间。负责科学有效地组织和存储数据，并帮助使用者从大量的数据中快速地获取所需数据，提供必要的安全性和完整性等</label><p><strong>主要功能：</strong></p><ul><li>数据定义功能：通过系统提供的数据定义语言（Data Definition Language, DDL），定义数据库中的数据对象，包括表、视图、存储过程、触发器等</li><li>数据操纵功能：通过系统提供的数据操作语言（Data Manipulation Language, DML），对数据库增、删、改、查等</li><li>数据库运行管理功能：由于数据库具有共享性，为保证数据的安全性、可靠性，系统提供了统一的控制和管理机制，实现数据在不被相互干扰的情况下并发使用，并且发生故障时能对数据库进行正确的恢复</li><li>数据库建立和维护功能：主要包括创建数据库及对数据库空间的维护、数据库的备份与回复功能、数据库的重组织功能和性能监视、分析等，一般通过系统提供的一些实用工具实现。</li><li>数据组织、存储和管理功能：为提高数据的存取效率，系统需对数据进行分类存储和管理，根据具体组织和存储方式提供多种数据存取方法，如索引查找、顺序查找等</li><li>其他功能：主要于其他软件的网络通信、不同数据库管理系统之间的数据传输及相互访问功能等。</li></ul><h3 id="数据库系统（Database-System，-DBS）"><a href="#数据库系统（Database-System，-DBS）" class="headerlink" title="数据库系统（Database System， DBS）"></a>数据库系统（Database System， DBS）</h3><p>指计算机中引入数据库技术之后的系统。通常一个完成的数据库系统包括 数据库、数据库管理系统及相关实用工具、应用程序、数据库管理员和用户。</p><p>数据库管理员（Database Administrator, DBA）不同于普通数据库用户，他们专门负责对数据库进行维护，并保证数据库正常、高效运行</p><p>用户则是数据库系统的服务对象，通常包括程序员和数据库终端用户，程序员通过高级程序设计语言（JAVA,PHP等）和数据库语言（SQL）编写数据库应用程序。</p><p>一般不引起混淆，常将数据库系统简称数据库。</p><hr><p></p><h2 style="text-align:center">数据库管理技术的发展</h2><br><strong>数据库管理可从两方面理解：</strong><p></p><ul><li>针对组织业务管理：负责制定并执行整个组织中关于数据的定义、组织、保护与有效使用的策略、过程和计划</li><li>依靠技术：负责实现数据作为一种资源的集中控制管理</li></ul><p><strong>数据组织：</strong>以便于处理的某种方式收集数据，并将记录在纸介文件上的数据转换成计算机可处理的形式；然后将收集的数据进行适当的构造</p><p><strong>数据组织分为两种：</strong></p><ul><li>逻辑组织：用户或应用程序所使用的数据结构形式</li><li>物理组织：数据在物理存储设备上的结构形式</li></ul><p>检索：存储的数据能方便的被选择提取</p><label>数据管理的任务是进行数据的收集、组织、控制、存储、选取、维护，实现在适当的时候，以适当的形式，给适当的人提供适当的数据；是数据处理的中心问题</label><p><strong>数据处理：</strong>指对各种数据进行收集、存储、加工、和传播的一系列活动的总和</p><h3 id="管理技术的发展阶段"><a href="#管理技术的发展阶段" class="headerlink" title="管理技术的发展阶段"></a>管理技术的发展阶段</h3><h4 id="人工管理阶段"><a href="#人工管理阶段" class="headerlink" title="人工管理阶段"></a>人工管理阶段</h4><p>20世纪50年代中期以前，计算机主要用于科学计算，所涉及的数据处理工作基本上都是靠手工方式进行</p><p><strong>主要特点：</strong></p><ul><li>数据不会保存：由于计算机软件和硬件发展刚刚起步，存储容量有限且价格昂贵，通常一组数据对应一个程序，数据随程序一起输入计算机，处理完毕后即将出结果，数据空间随着程序空间一起被释放</li><li>应用程序管理数据：当时没有专门的数据管理软件，应用程序的数据由程序自行负责，因而数据的组织方式必须由程序员自己设计、定义和管理。所有包括逻辑结构、物理结构、存取方法等数据库设计工作都由应用程序的编写人员来完成，程序员的工作负担十分繁重</li><li>数据面向应用：一组数据对应一个程序，多个应用程序涉及某些相同的数据时必须各自定义，不能共享，因此程序与程序之前存在大量冗余数据，数据独立性差</li></ul><h4 id="文件系统阶段"><a href="#文件系统阶段" class="headerlink" title="文件系统阶段"></a>文件系统阶段</h4><p>20世纪50年代中期到60年代中期，计算机软、硬件发展到一定阶段。其中，硬件方面配置了磁盘、磁鼓等直接存储设备；软件则在操作系统中配备了专门的数据管理软件，即文件系统</p><p>文件系统是将数据的逻辑结构和物理结构分离，由“存放方法”实现逻辑结构与物理结构执行的映射。应用程序只涉及数据的逻辑结构，系统决定数据的物理结构，两者直接可以由差别，这样不会相互影响（数据的物理独立性），使得使用性提高，同时程序员不必关心数据的物理存储细节，生产效率大大提高</p><p><strong>主要特点：</strong></p><ul><li>数据可长期保存和专门管理：磁盘、磁鼓等直接存储设备；软件则在操作系统中配备了专门的数据管理软件</li><li>物理数据独立性：应用程序与数据的具体物理存储结构分离</li><li>文件级数据共享：通过数据的抽取、排序、合并等为应用提供新的文件，不能实现数据项级的普通共享；文件的逻辑结构是根据它的应用而设计，数据的逻辑结构与应用程序之间相互依赖。不同应用程序必须构造各自的文件，数据项大部分相同时还是存在大量的数据冗余。</li></ul><h4 id="数据库系统阶段"><a href="#数据库系统阶段" class="headerlink" title="数据库系统阶段"></a>数据库系统阶段</h4><p>数据库技术是应数据管理任务的需要而产生。20世纪60年代末以来，计算机技术与工业迅速发展，计算机开始广泛应用于企业管理，并对计算机数据管理提出更高的<strong>要求：</strong></p><ul><li>数据作为企业组织的公共资源而集中管理控制，能为企业各类用户共享，须大量地消除数据冗余，节省存储空间；</li><li>当数据变更时，能节省对多个数据副本的多次变更操作，从而缩小计算机运算时间，不会遗漏某些副本的变更而使系统出现不一致的数据</li><li>数据要具有更高的独立性，不但具有物理独立性，而且具有逻辑独立性，当数据逻辑结构改变时，不影响那些不须改变的用户应用程序，节省开发和维护的代价</li></ul><p><strong>数据库系统的特点</strong></p><ul><li>数据集成：数据库管理系统的主要目的就说数据集成。在数据库中，通过相关联数据间定义的逻辑联系，数据被组成统一的逻辑结构，与数据的物理组织与定位分离，应用的修改、增加只与数据的逻辑结构发生关系。</li><li>数据共享性高：在数据库中，一个数据可为多个不同用户共同使用，各个用户可以为了不同的目的来存取相同的数据，他们从各种不同的角度来看待数据库，即<label>一个数据库有多种不同的用户视图</label>。这些用户视图简化了数据的共享，它们可以给每个用户提供执行其业务职能所要求的数据的准确视图，使用户无须知道数据库的全部复杂组成。<label>共享不仅是同一数据被不同用户存取，还包含并发共享，不同用户可同时存取同一的数据</label></li><li>数据冗余小：将独立而又冗余的数据文件集成为单一的逻辑结构，每个数据项的值可以理想地只存储一次，从而节约空间，避免数据的重复存储。<label>并非所有的冗余都可以被消除，有时业务或技术上的原因，如数据的合法性检验、数据存储效率等方法，同一数据可能在数据库种保持多个副本，因此数据库系统种，冗余是受控的，系统知道冗余，保留必要的冗余是系统预定的</label></li><li>数据一致性：通过消除或控制数据冗余，可在一定范围内避免数据的不一致性。</li><li>数据独立性高：数据定义与使用数据的应用程序分离，一方的修改不会影响另一方的修改。<br><strong>数据库提供了两层数据独立：</strong></li></ul><ol><li><strong>逻辑独立：</strong>不同的应用程序对同样的数据可以使用不同的视图，即应用程序一定范围内修改它的数据库视图，而不修改数据本身的定义；而数据定义的修改，在一定范围内不会引起应用的修改</li><li><strong>物理独立：</strong>改变数据的存储结构或存取方法以响应变化的需求而无需修改现有的应用程序</li></ol><ul><li><p>实施统一管理与控制：主要包括数据的安全性、完整性、并发控制与故障恢复等（数据库包含）</p><ol><li>数据安全性（Security）：指保护数据，防止非法使用造成数据泄密和破坏，每个用户只能按规定对某些数据以某些方式进行使用和处理，保证数据只有赋予权限的用户才能访问数据。</li><li>数据完整性（Integrity）：对数据的正确性、有效性和相容性的校验，即控制数据在一定范围内有效或要求数据之前满足一定的关系，保证输入到数据库中的数据满足相应的约束条件，确保数据<label>有效、正确</label></li><li>并发控制（Concurrency）：多个用户的并发进程同时存储、修改数据库时，可能发生相互干扰，而得到错误结果，使得数据库的完整性糟到破坏，因此对多用户的并发操作加以控制和协调。如用户网上订购火车票，系统必须确保不会由于多个用户同时购买相同的车票而造成冲突。</li><li>故障恢复：计算机产生的硬件故障、操作员的失误以及人为的破坏都会影响数据库中数据的正确性，DBMS必须具有将数据库从错误状态恢复到某一已知的正确状态的功能。</li></ol></li><li><p>减少应用程序开发与维护的工作量：<label>由于数据库中的数据具有共享性、独立性，使得程序员不在需要承担基本数据文件的设计、建造与维护等繁重负担</label></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概叙&quot;&gt;&lt;a href=&quot;#概叙&quot; class=&quot;headerlink&quot; title=&quot;概叙&quot;&gt;&lt;/a&gt;概叙&lt;/h2&gt;&lt;p&gt;数据库技术是对数据进行管理的技术，能有科学地管理各类信息资源。数据、数据库、数据库管理系统和数据库系统是数据库常用的基本概念。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="Database basis" scheme="https://owen027.github.io/categories/Database-basis/"/>
    
    
      <category term="Database_basis_1" scheme="https://owen027.github.io/tags/Database-basis-1/"/>
    
  </entry>
  
  <entry>
    <title>访问媒体设备</title>
    <link href="https://owen027.github.io/2019/08/12/mediaDevices/"/>
    <id>https://owen027.github.io/2019/08/12/mediaDevices/</id>
    <published>2019-08-12T07:54:16.000Z</published>
    <updated>2019-09-06T14:33:47.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><blockquote><p>mediaDevices 是 Navigator 对象的只读属性，一个单列对象，可以连接访问相机和麦克风，屏幕共享等媒体输入设备</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="enumerateDevices"><a href="#enumerateDevices" class="headerlink" title="enumerateDevices"></a>enumerateDevices</h3><blockquote><p>请求一个可用的媒体输入和输出设备列表，如麦克风、相机、耳机等。返回的 <code>Promise</code>完成状态中是一个带有 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo">MediaDeviceInfo</a> 的数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mediaDevices = navigator.mediaDevices</span><br><span class="line"><span class="keyword">if</span>(!mediaDevices || !mediaDevices.enumerateDevices) <span class="keyword">return</span> <span class="built_in">console</span>.erorr(<span class="string">'浏览器不支持enumerateDevices API'</span>)</span><br><span class="line">navigator.mediaDevices.enumerateDevices()</span><br><span class="line">.then(<span class="function">(<span class="params">devices</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> device <span class="keyword">of</span> devices)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(device.kind + <span class="string">': '</span> +device.lable + <span class="string">' id = '</span>+ device.deviceId );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">audioinput: undefined id = default</span></span><br><span class="line"><span class="comment">audioinput: undefined id = communications</span></span><br><span class="line"><span class="comment">audioinput: undefined id = ac67d348685a08c75e5017f9a449b3d85f08dcb774c88ab95de82bbf2c0fc820</span></span><br><span class="line"><span class="comment">videoinput: undefined id = e41039bcfbc84d926a0b73cdc1d8b1daf3d67d36c62588202191d918fb076426</span></span><br><span class="line"><span class="comment">audiooutput: undefined id = default</span></span><br><span class="line"><span class="comment">audiooutput: undefined id = communications</span></span><br><span class="line"><span class="comment">audiooutput: undefined id = 015d73652e57bffb21679b937675d32c4d4a43862aba3774aaf0b5f1e983151f</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p><img src="/static/img/enumerateDevices.png" alt="enumerateDevices"></p><h3 id="getSupportedConstraints"><a href="#getSupportedConstraints" class="headerlink" title="getSupportedConstraints"></a>getSupportedConstraints</h3><blockquote><p>返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaTrackSupportedConstraints">MediaTrackSupportedConstraints</a> 对象，其属性都是客户端所支持约束的属性,值为 Boolean 类型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> supportedConstraints = navigator.mediaDevices.getSupportedConstraints()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> constraint <span class="keyword">of</span> <span class="built_in">Object</span>.keys(supportedConstraints))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(constraint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">aspectRatio</span></span><br><span class="line"><span class="comment">autoGainControl</span></span><br><span class="line"><span class="comment">brightness</span></span><br><span class="line"><span class="comment">channelCount</span></span><br><span class="line"><span class="comment">colorTemperature</span></span><br><span class="line"><span class="comment">contrast</span></span><br><span class="line"><span class="comment">deviceId</span></span><br><span class="line"><span class="comment">echoCancellation</span></span><br><span class="line"><span class="comment">exposureCompensation</span></span><br><span class="line"><span class="comment">exposureMode</span></span><br><span class="line"><span class="comment">exposureTime</span></span><br><span class="line"><span class="comment">facingMode</span></span><br><span class="line"><span class="comment">focusDistance</span></span><br><span class="line"><span class="comment">focusMode</span></span><br><span class="line"><span class="comment">frameRate</span></span><br><span class="line"><span class="comment">groupId</span></span><br><span class="line"><span class="comment">height</span></span><br><span class="line"><span class="comment">iso</span></span><br><span class="line"><span class="comment">latency</span></span><br><span class="line"><span class="comment">noiseSuppression</span></span><br><span class="line"><span class="comment">pointsOfInterest</span></span><br><span class="line"><span class="comment">resizeMode</span></span><br><span class="line"><span class="comment">sampleRate</span></span><br><span class="line"><span class="comment">sampleSize</span></span><br><span class="line"><span class="comment">saturation</span></span><br><span class="line"><span class="comment">sharpness</span></span><br><span class="line"><span class="comment">torch</span></span><br><span class="line"><span class="comment">volume</span></span><br><span class="line"><span class="comment">whiteBalanceMode</span></span><br><span class="line"><span class="comment">width</span></span><br><span class="line"><span class="comment">zoom</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h4><p><img src="/static/img/supportedConstraints.png" alt="supportedConstraints"></p><h3 id="getDisplayMedia"><a href="#getDisplayMedia" class="headerlink" title="getDisplayMedia"></a>getDisplayMedia</h3><blockquote><p>提示用户选择和授予权限来捕获显示或部分的内容，(如分屏共享时分享哪一屏的内容)然后使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_Recording_API">medieaStream Recording API</a> 记录生成的 stream，或作为 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API">webRTC</a> 会话的一部分进行传输。</p></blockquote><p>可以传递一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints">MediaStreamConstraints</a> 对象指定返回要求的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream">mediaStream</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startCapture</span>(<span class="params">displayMediaOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> captureStream = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    captureStream = <span class="keyword">await</span> navigator.mediaDevices.getDisplayMedia(displayMediaOptions);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Error: "</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> captureStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="兼容性-2"><a href="#兼容性-2" class="headerlink" title="兼容性"></a>兼容性</h4><p><img src="/static/img/displayMedia.png" alt="displayMedia"></p><h3 id="getUserMedia"><a href="#getUserMedia" class="headerlink" title="getUserMedia"></a>getUserMedia</h3><blockquote><p>提示用户给予使用媒体输入的许可（如麦克风，摄像机）,当媒体输入时产生一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream">mediaStream</a>包含所请求的媒体类型的轨道。该流可以包括视频轨道（摄像机，视频记录设备，共屏等硬件或虚拟视频流源）、音频轨道（来自麦克风、A/D转换器等硬件或虚拟音频源），也可能是其它轨道类型</p></blockquote><p>该方法返回一个<code>Promise</code>对象,成功时 <code>resolve</code> 回调函数带有<code>mediaStream</code>对象。如果用户拒绝授予使用权限，或是媒体源不可用，则返回 <code>reject</code>回调</p><p><strong> <code>Promise</code> 可能既不会 <code>resolve</code> 也不会<code>reject</code>,因为用户不必做出选择，可能只是忽略请求</strong></p><p><img src="/static/img/microphone.png" alt="microphone"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想要获取一个最接近 1280x720 的相机分辨率</span></span><br><span class="line"><span class="keyword">let</span> constraints = &#123; <span class="attr">audio</span>: <span class="literal">true</span>, <span class="attr">video</span>: &#123; <span class="attr">width</span>: <span class="number">1280</span>, <span class="attr">height</span>: <span class="number">720</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">navigator.mediaDevices.getUserMedia(constraints)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">mediaStream</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line">  video.srcObject = mediaStream;</span><br><span class="line">  video.onloadedmetadata = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    video.play();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123; <span class="built_in">console</span>.log(err.name + <span class="string">": "</span> + err.message); &#125;);</span><br></pre></td></tr></table></figure><h4 id="参数-constraints"><a href="#参数-constraints" class="headerlink" title="参数 constraints"></a>参数 constraints</h4><blockquote><p>一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaStreamConstraints">mediaStreamConstraints</a>对象指定请求的媒体类型和相对应参数，该对象包含 <code>video</code> 和 <code>audio</code> 两个属性，必须一个或两个同时被指定，如果无法找到指定的媒体类型或无法满足对于的参数要求，<code>Promise</code>将返回 <code>rejected</code></p></blockquote><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">audio</span>:<span class="literal">true</span>,<span class="attr">video</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>属性设置为 Truthy 则生成的<code>stream</code> 必须具有该类型的轨道，否则调用 <code>getUserMedia</code>会抛出错误</strong></p><h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  audio: <span class="literal">true</span>,</span><br><span class="line">  video: &#123; <span class="attr">width</span>: <span class="number">1280</span>, <span class="attr">height</span>: <span class="number">720</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>表示<code>video</code>的分辨率应为 1280x720 浏览器将试着满足这个请求参数，如果无法满足要求或选择覆盖，则可能返回其它的分辨率</strong></p><h5 id="3"><a href="#3" class="headerlink" title="3"></a>3</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  audio: <span class="literal">true</span>,</span><br><span class="line">  video: &#123;</span><br><span class="line">    width: &#123; <span class="attr">min</span>: <span class="number">1280</span> &#125;,</span><br><span class="line">    height: &#123; <span class="attr">min</span>: <span class="number">720</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此配置要求了最低分辨率，如果达不到要求，<code>promise</code> 将返回 <code>reject</code>;还可配置 max、exact(min == max),而且用户将不会得到要求授权的提示</strong></p><h5 id="4"><a href="#4" class="headerlink" title="4"></a>4</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  audio: <span class="literal">true</span>,</span><br><span class="line">  video: &#123;</span><br><span class="line">    width: &#123; <span class="attr">min</span>: <span class="number">1024</span>, <span class="attr">ideal</span>: <span class="number">1280</span>, <span class="attr">max</span>: <span class="number">1920</span> &#125;,</span><br><span class="line">    height: &#123; <span class="attr">min</span>: <span class="number">776</span>, <span class="attr">ideal</span>: <span class="number">720</span>, <span class="attr">max</span>: <span class="number">1080</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果使用<code>ideal</code>,浏览器将尝试找到（如果相机有多个的话）最接近指定值的理想值的设备或相机</strong><br>意味着上方的第一个分辨率例子可简写为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  audio: <span class="literal">true</span>,</span><br><span class="line">  video: &#123;</span><br><span class="line">    width: &#123; <span class="attr">ideal</span>: <span class="number">1280</span> &#125;,</span><br><span class="line">    height: &#123; <span class="attr">ideal</span>: <span class="number">720</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><p><strong>并不是所有的 <code>constraint</code> 都说数字，如在移动设备上优先使用前置相机</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">audio</span>: <span class="literal">true</span>, <span class="attr">video</span>: &#123; <span class="attr">facingMode</span>: <span class="string">"user"</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p><p><strong>强制使用后置相机</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">audio</span>: <span class="literal">true</span>,</span><br><span class="line"> video: &#123;</span><br><span class="line">  facingMode: &#123; <span class="attr">exact</span>: <span class="string">"environment"</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="APP权限配置"><a href="#APP权限配置" class="headerlink" title="APP权限配置"></a>APP权限配置</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"permissions": &#123;</span><br><span class="line">  "audio-capture": &#123;</span><br><span class="line">    "description": "Required to capture audio using getUserMedia()"</span><br><span class="line">  &#125;,</span><br><span class="line">  "video-capture": &#123;</span><br><span class="line">    "description": "Required to capture video using getUserMedia()"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作为可能涉及重大隐私问题的API，getUserMedia()规范规定了浏览器有义务满足的各种隐私和安全要求。</strong><br>getUserMedia()是一个强大的功能，只能在安全的环境中使用; 在不安全的情境中，<code>navigator.mediaDevices</code> 是undefined，阻止访问<code>getUserMedia()</code>。<br><strong>简而言之，安全上下文是使用<code>HTTPS</code>或 <code>file:///URL</code> 方案加载的页面，或者是从中加载的页面<code>localhost</code>。</strong></p><h4 id="在旧的浏览器中使用新的API"><a href="#在旧的浏览器中使用新的API" class="headerlink" title="在旧的浏览器中使用新的API"></a>在旧的浏览器中使用新的API</h4><p><strong>推荐使用处理了约束的 <a href="https://github.com/webrtc/adapter">adapter.js</a><code>polyfill</code>  来替代。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象</span></span><br><span class="line"><span class="keyword">let</span> mediaDevices = navigator.mediaDevices</span><br><span class="line"><span class="keyword">if</span> (mediaDevices === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  mediaDevices = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一些浏览器部分支持 mediaDevices。我们不能直接给对象设置 getUserMedia</span></span><br><span class="line"><span class="comment">// 因为这样可能会覆盖已有的属性。这里我们只会在没有getUserMedia属性的时候添加它。</span></span><br><span class="line"><span class="keyword">if</span> (mediaDevices.getUserMedia === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  mediaDevices.getUserMedia = <span class="function"><span class="keyword">function</span>(<span class="params">constraints</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，如果有getUserMedia的话，就获得它</span></span><br><span class="line">    <span class="keyword">var</span> getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些浏览器根本没实现它 - 那么就返回一个error到promise的reject来保持一个统一的接口</span></span><br><span class="line">    <span class="keyword">if</span> (!getUserMedia) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'getUserMedia is not implemented in this browser'</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，为老的navigator.getUserMedia方法包裹一个Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      getUserMedia.call(navigator, constraints, resolve, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">mediaDevices.getUserMedia(&#123; <span class="attr">audio</span>: <span class="literal">true</span>, <span class="attr">video</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line">  <span class="comment">// 旧的浏览器可能没有srcObject</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"srcObject"</span> <span class="keyword">in</span> video) &#123;</span><br><span class="line">    video.srcObject = stream;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 防止在新的浏览器里使用它，应为它已经不再支持了</span></span><br><span class="line">    video.src = <span class="built_in">window</span>.URL.createObjectURL(stream);</span><br><span class="line">  &#125;</span><br><span class="line">  video.onloadedmetadata = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    video.play();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err.name + <span class="string">": "</span> + err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="兼容性-3"><a href="#兼容性-3" class="headerlink" title="兼容性"></a>兼容性</h4><p><img src="/static/img/getUserMedia.png" alt="getUserMedia"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;mediaDevices 是 Navigator 对象的只读属性，一个单列对象，可以连接访问相机和麦克风，屏幕共享
      
    
    </summary>
    
    
      <category term="mediaDevices" scheme="https://owen027.github.io/tags/mediaDevices/"/>
    
  </entry>
  
  <entry>
    <title>Redux 学习</title>
    <link href="https://owen027.github.io/2019/08/04/redux/"/>
    <id>https://owen027.github.io/2019/08/04/redux/</id>
    <published>2019-08-04T04:22:58.000Z</published>
    <updated>2019-09-06T14:33:47.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>Redux 是一个可以预测的JavaScript 状态控制器，专注于状态管理，有store,state, action,reducer 等API（类似 vue 中的 vux）</p></blockquote><p>Redux 可编写构建行为状态一致的应用，可运行在客户端、服务的 和 原生应用 环境中，并且容易测试。 最重要的是，它提供很好的开发体验，编译后的代码可通过devtools实时预览调试。</p><p>Redux 可以和 React 一起使用，也可以和其他视图库（如 <a href="https://cn.vuejs.org/v2/guide/installation.html">Vue</a>）使用。它很小（2K大小 包含依赖 ），并且有一个庞大的插件生态系统。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 npm<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux -S</span><br></pre></td></tr></table></figure></p><p>使用 yarn</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add redux -P</span><br></pre></td></tr></table></figure><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 redux</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ADD_NUM = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> SUB_NUM = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 redecer</span></span><br><span class="line"><span class="keyword">const</span> counter = <span class="function">(<span class="params">state = <span class="number">6</span>,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> ADD_NUM:</span><br><span class="line">            <span class="keyword">return</span> ++state</span><br><span class="line">        <span class="keyword">case</span> SUB_NUM:</span><br><span class="line">            <span class="keyword">return</span> --state</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="comment">// 获取state</span></span><br><span class="line"><span class="keyword">const</span> num = store.getState()</span><br><span class="line"><span class="comment">// 发布信息更改state</span></span><br><span class="line">store.dispatch(&#123;<span class="attr">type</span>:<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅 获取state</span></span><br><span class="line">store.subscrible(lister)  <span class="comment">// 没执行一次dispatch （改变state) 就执行一次 lister 方法</span></span><br><span class="line"><span class="comment">// 设置每次state变化 后的行为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lister</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">&#125;</span><br><span class="line">store.dispatch(&#123;<span class="attr">type</span>:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote><p>更新state中的数据，须通过action（就是一个普通对象） 来更改,这样可清晰的知道应用中发生了什么，数据为什么变动，怎样变动。而核心想法是如何根据这些 action 对象来更新 state。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">type</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#123;<span class="attr">type</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>将state和action结合成函数，这就是reducer。它只接受 state和action 两个参数，并返回新的state函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">console</span>.log(store.getState())<span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然一个应用不单单只有一个reducer,我们可以通过redux来将它们合并。</p><h2 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h2><h3 id="单一数据源-（Single-source-of-truth）"><a href="#单一数据源-（Single-source-of-truth）" class="headerlink" title="单一数据源 （Single source of truth）"></a>单一数据源 （Single source of truth）</h3><blockquote><p>整个应用程序的 state 存储在一个单一 store 的对象树（object tree）中</p></blockquote><p>这样更容易创建创建通用应用，来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。这样单一的 state 树更容易调试和检查。它还能在开发过程中保持应用程序的状态，从而加快开发周期。一些在传统上难以实现的功能（撤销/重做），将其state 存储在树中，从而变得更加简单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="State-是只读的-（State-is-read-only）"><a href="#State-是只读的-（State-is-read-only）" class="headerlink" title="State 是只读的 （State is read-only）"></a>State 是只读的 （State is read-only）</h3><blockquote><p>改变state的唯一方法是触发 action, action是描述发生什么事件的对象</p></blockquote><p>这样确保视图和网络请求不会直接修改state，反而，它们明确表达想要修改的意图。因为所有的变化都被集中处理，且按照严格的顺序一个接一个执行。所以没有细微的竞争条件需要注意。 Action是一个普通对象，所以可以对它们进行打印、序列化、存储，然后后期调试和测试。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="使用纯函数进行更改"><a href="#使用纯函数进行更改" class="headerlink" title="使用纯函数进行更改"></a>使用纯函数进行更改</h3><blockquote><p>要如何通过 action改变指定的state tree ,需要编写 Reducers 函数</p></blockquote><p>Reducer 只是一些纯函数，他接收 state 和 action 两个参数，并且返回新的state ,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers, createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// 创建 redecer</span></span><br><span class="line"><span class="keyword">const</span> counter = <span class="function">(<span class="params">state = <span class="number">6</span>,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> ADD_NUM:</span><br><span class="line">            <span class="keyword">return</span> ++state</span><br><span class="line">        <span class="keyword">case</span> SUB_NUM:</span><br><span class="line">            <span class="keyword">return</span> --state</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter1 = <span class="function">(<span class="params">state = <span class="number">6</span>,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> ADD_NUM:</span><br><span class="line">            <span class="keyword">return</span> ++state</span><br><span class="line">        <span class="keyword">case</span> SUB_NUM:</span><br><span class="line">            <span class="keyword">return</span> --state</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reducers = combineReducers(&#123; counter, counter1 &#125;) <span class="comment">// 通过 combineReducers 合并reducer</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducers)</span><br></pre></td></tr></table></figure></p><h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><blockquote><p>Actions 是将数据从应用程序发送到 store 的有效负载。它们是store 的唯一数据来源，通过 <code>store.dispatch()</code> 传递给 store<br>example:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: ADD_TODO,</span><br><span class="line">  text: <span class="string">'Build my first Redux app'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actions 本质上是普通对象。并且该对象必须有一个<code>type</code> 属性来表示将要执行的动作，通常 <code>type</code> 被定义成字符串常量。当规模变大时，可以存放到单独的文件种管理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ADD_TODO, REMOVE_TODO &#125; <span class="keyword">from</span> <span class="string">'../actionTypes'</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意：使用单独的模块或文件定义 常量<code>type</code>不是必须的，对于小应用来说，使用字符串<code>type</code>方便。而在大型项目种定义常量利大于弊。</p></blockquote><p>出了<code>type</code>属性外其他属性可自行定义，对于规范参考<a href="https://github.com/redux-utilities/flux-standard-action">Flux Standard Action</a></p><h4 id="创建-Action-的生产函数"><a href="#创建-Action-的生产函数" class="headerlink" title="创建 Action 的生产函数"></a>创建 Action 的生产函数</h4><blockquote><p>即生成action 的方法，函数返回一个 action 对象这样更容易被移植和测试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type:ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在<a href="http://facebook.github.io/flux/">传统的Flux</a>实现中调用 action 实现方法时，一般会触发一个<code>dispatch</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> action= &#123;</span><br><span class="line">        type:ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Redux 中只需把action 函数传递给<code>dispatch()</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type:ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.dispatch(addTodo(text))</span><br></pre></td></tr></table></figure></p><h4 id="异步-Action"><a href="#异步-Action" class="headerlink" title="异步 Action"></a>异步 Action</h4><blockquote><p>当调用异步 API时，发送请求和响应（可能超时），都可能会更改 state；因此需要 同步地 <code>dispatch</code> 由<code>reduce</code> 处理的操作<br>通常需要对应三种 action:</p><ul><li>通知 reducer 请求开始的action：reducer 可能会切换state中的 <code>flag</code>,来更改UI状态。</li><li>通知 reducer 请求成功的action：reducer 可能会将接收到的数据合并到 state 中，并更改 <code>flag</code>,控制 UI。</li><li>通知 reducer 请求失败的action：reducer 可能会重置 <code>flag</code>,并将一些失败在UI中信息显示出来</li></ul></blockquote><p>至于<code>flag</code>如何定义完全取决于开发者，使用多个type会降低出错几率。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS_REQUEST'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS_FAILURE'</span>, <span class="attr">error</span>: <span class="string">'Oops'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS_SUCCESS'</span>, <span class="attr">response</span>: &#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意：在实际应用中，网络请求失败时也需要 dispatch action。</strong></p><p>待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Redux 是一个可以预测的JavaScript 状态控制器，专注于状态管理，有store,state, acti
      
    
    </summary>
    
      <category term="React" scheme="https://owen027.github.io/categories/React/"/>
    
    
      <category term="Redux" scheme="https://owen027.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>ReactDOM API</title>
    <link href="https://owen027.github.io/2019/08/02/reactDomAPI/"/>
    <id>https://owen027.github.io/2019/08/02/reactDomAPI/</id>
    <published>2019-08-02T11:15:12.000Z</published>
    <updated>2019-09-06T14:33:47.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-dom"><a href="#react-dom" class="headerlink" title="react-dom"></a>react-dom</h2><ul><li><code>react-dom</code> 的 <code>package</code> 提供了可在应用顶层使用的DOM方法，所有的顶层 API 都可调用</li></ul><p><code>React</code> 支持所有的现代浏览器，IE9及以上版本，但是需要引用相关 <a href="https://zh-hans.reactjs.org/docs/javascript-environment-requirements.html">polyfills</a>,那些在不兼容ES5语法的浏览器中奋斗的同志需要孤军奋战了。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line">ReactDOM.render(element,container[, callback])</span><br></pre></td></tr></table></figure><p>在提供的<code>container</code>里渲染一个 <code>React 元素</code>，并返回该组件的<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">引用</a>, 对于 <a href="https://zh-hans.reactjs.org/docs/components-and-props.html#functional-and-class-components">无状态组件</a>返回 null。<br>如果 <code>React 元素</code> 已经在 <code>container</code>中渲染过，那么将会更新里面的元素，并仅会在必要的时候改变DOM 映射新的 React 元素。<br>callback将在组件被渲染或更新后执行</p><blockquote><p>当首次调用时，container节点中所有DOM元素都会被替换，后续的调用则使用 React 的 DOM diff 算法 进行高效更新。<br><code>rend()</code>不会修改container节点，之后修改子节点，可以在不覆盖现有子节点的情况下，将组件插入已有的DOM节点中。对服务端渲染容器进行 <code>hydrate</code>操作的方式已被废弃，且会在 1<br><code>rend()</code>目前会返回对根组件 <code>ReactComponent</code> 实例的引用。但应该避免使用它，因为历史遗留下来的内容，在未来版本中，组件渲染某些情况下可能会是异步的。对服务端渲染容器进行 <code>hydrate</code>操作的方式已被废弃，且会在 1<br>如果需要根组件 <code>ReactComponent</code> 实例的引用，推荐使用<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">callback ref</a>。<br>使用<code>rend()</code>对服务端渲染容器进行 <code>hydrate</code>操作的方式已被废弃，且会在 17版中被 <a href="https://zh-hans.reactjs.org/docs/react-dom.html#hydrate">hydrate()</a></p></blockquote><h3 id="hydrate"><a href="#hydrate" class="headerlink" title="hydrate()"></a>hydrate()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.hydrate(element,container[, callback])</span><br></pre></td></tr></table></figure><p>此方法和 <code>render()</code>相同，区别在于 <a href="https://zh-hans.reactjs.org/docs/react-dom-server.html">ReactDOMServer</a> 渲染的容器中对HTML的内容进行 <code>hydrate</code> 操作。React 会尝试在已有的标记上绑定事件监听器。</p><h3 id="unmountComponentAtNode"><a href="#unmountComponentAtNode" class="headerlink" title="unmountComponentAtNode()"></a>unmountComponentAtNode()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.unmountComponentAtNode(container)</span><br></pre></td></tr></table></figure><p>此方法将卸载 DOM 中的组件，会将事件处理器和 state 一并清除。如果指定的 container 中没有对应已挂在的组件，那么此方法什么也不会做，如果组件被移除将会返回 true，如果未移除将返回false</p><h3 id="findDOMNode"><a href="#findDOMNode" class="headerlink" title="findDOMNode()"></a>findDOMNode()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.findDOMNode(component)</span><br></pre></td></tr></table></figure><p>如果组件已被挂载到DOM上，此方法会返回浏览器中x相应的原生DOM，不能用于函数组件，对于在未挂载的组件中调用将发生异常。对于读取DOM中的值很有用，一般<strong>推荐使用 <code>ref</code>来获取DOM元素</strong></p><p><strong>此方法是访问底层DOM节点的应急方案，严格模式中被弃用</strong></p><h3 id="createPortal"><a href="#createPortal" class="headerlink" title="createPortal()"></a>createPortal()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.createPortal(child,container)</span><br></pre></td></tr></table></figure><p>创建<a href="https://zh-hans.reactjs.org/docs/portals.html">portal</a>，它提供一种将子节点渲染到DOM节点中的方式，该节点存在于DOM组件的乘此结构之外。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react-dom&quot;&gt;&lt;a href=&quot;#react-dom&quot; class=&quot;headerlink&quot; title=&quot;react-dom&quot;&gt;&lt;/a&gt;react-dom&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;react-dom&lt;/code&gt; 的 &lt;code&gt;packa
      
    
    </summary>
    
      <category term="React" scheme="https://owen027.github.io/categories/React/"/>
    
    
      <category term="ReactDOM API" scheme="https://owen027.github.io/tags/ReactDOM-API/"/>
    
  </entry>
  
  <entry>
    <title>React API</title>
    <link href="https://owen027.github.io/2019/07/31/reactAPI/"/>
    <id>https://owen027.github.io/2019/07/31/reactAPI/</id>
    <published>2019-07-31T09:44:31.000Z</published>
    <updated>2019-09-06T14:33:47.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement()"></a>createElement()</h2><blockquote><p>创基并返回指定类型的 <a href="https://zh-hans.reactjs.org/docs/rendering-elements.html">React元素</a>。其中类型参数既可以是DOM标签字符串，也可以是<a href="https://zh-hans.reactjs.org/docs/components-and-props.html">React组件类型</a>,或是<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactfragment">React fragment</a>类型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(type,[props],[...children])</span><br></pre></td></tr></table></figure><p> JSX 编写的代码将会被转换成使用 React.createElement() 的形式。</p><h2 id="cloneElement"><a href="#cloneElement" class="headerlink" title="cloneElement()"></a>cloneElement()</h2><blockquote><p>以 element 元素为样板克隆并返回新的React元素，返回元素的props将新的props与原始的prosp浅合并。新的子元素取代现有的子元素，原始元素的 key 和 ref 将被保留</p></blockquote><p>通过 ref 获取子节点时，将不会意外地从祖先节点上窃取它。相同的 ref 将添加到克隆后的新元素中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.cloneElement(element,[props],[...children])</span><br></pre></td></tr></table></figure></p><h2 id="isValidElement"><a href="#isValidElement" class="headerlink" title="isValidElement()"></a>isValidElement()</h2><blockquote><p>验证对象是否为React元素，返回值为 true or false</p></blockquote><h2 id="React-children"><a href="#React-children" class="headerlink" title="React.children"></a>React.children</h2><blockquote><p>提供用于处理 <code>this.props.children</code> 不透明数据结构的方用方法。</p></blockquote><h3 id="React-Children-map"><a href="#React-Children-map" class="headerlink" title="React.Children.map"></a>React.Children.map</h3><ul><li>在每个直接子节点上调用一个函数，并将 <code>this</code>(执行期上下文) 设置为 <code>thisArg</code>。</li><li>如果<code>Children</code> 是一个数值，它将被遍历并为数组中的每个子节点调用该函数。</li><li>如果子节点为<code>null</code> 或 <code>undefined</code>,则返回对应的 null 或 undefined。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">React.Children.map(children,function[(thisArg)])</span><br></pre></td></tr></table></figure><p><strong>如果children 是一个Frgment对象，它将被视为单一子节点的情况处理，不被遍历</strong></p><h3 id="React-Children-forEach"><a href="#React-Children-forEach" class="headerlink" title="React.Children.forEach"></a>React.Children.forEach</h3><blockquote><p>和 <code>React.Children.map</code> 类似，但是不会返回数组<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">React.Children.forEach(children,function[(thisArg)] )</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="React-Children-count"><a href="#React-Children-count" class="headerlink" title="React.Children.count"></a>React.Children.count</h3><blockquote><p>返回 children 中组件总数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">React.Children.count(children)</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="React-Children-only"><a href="#React-Children-only" class="headerlink" title="React.Children.only"></a>React.Children.only</h3><blockquote><p>验证children是否只有一个React元素，有则返回它，无则抛出错误</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">React.Children.only(children)</span><br></pre></td></tr></table></figure><p>**此方法不接受<code>React.Children.map</code>的返回值，因为它是一个数组</p><h3 id="React-Children-toArray"><a href="#React-Children-toArray" class="headerlink" title="React.Children.toArray"></a>React.Children.toArray</h3><blockquote><p>将children 这个复杂的数据结构以数组的形式扁平展开并返回，且为每个子节点分配一个key.想要在渲染函数中操作子节点的集合时，非常实用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">React.Children.toArray(children)</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>注意：此方法在拉平展开节点列表时，更改key值以保留嵌套数组的语言。即 toArray 会为返回数组中的每个key添加前缀，使每个元素key的范围都限定在此函数入参数组的对象内</strong></p><h2 id="React-Fragment"><a href="#React-Fragment" class="headerlink" title="React.Fragment"></a>React.Fragment</h2><blockquote><p><code>React.Fragment</code> 能在不额外创建DOM元素情况下，让 render方法返回多个元素</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">          &lt;ChildA /&gt;</span><br><span class="line">          &lt;ChildB /&gt;</span><br><span class="line">          &lt;ChildC /&gt;</span><br><span class="line">        &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 简写</span></span><br><span class="line"><span class="regexp">render()&#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ChildA /</span>&gt;</span><br><span class="line">          &lt;ChildB /&gt;</span><br><span class="line">          &lt;ChildC /&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://zh-hans.reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html">更多信息</a></p><h2 id="React-createRef"><a href="#React-createRef" class="headerlink" title="React.createRef"></a>React.createRef</h2><blockquote><p>创建一个能通过 ref 属性附加到 React元素的 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">ref</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Componet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">this</span>.inputRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    reder()&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;input type="text" ref= &#123;this.inputRef&#125; /&gt;；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        this.inputRef.current.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-forwardRef"><a href="#React-forwardRef" class="headerlink" title="React.forwardRef"></a>React.forwardRef</h2><blockquote><p><code>React.forwardRef</code> 会创建一个React组件，能将其接受的<code>ref</code> 属性转发到其组件树下的另一个组件中。</p><ul><li><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components">转发refs到DOM组件</a></li><li><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components">在高阶组件中转发 refs</a></li></ul></blockquote><p><strong><code>React.forwardRef</code>接受渲染函数作为参数。使用props和ref z作为参数调用此函数，返回 React节点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = React.forwardRef(<span class="function">(<span class="params">props,ref</span>)=&gt;</span> ( &lt;button ref=&#123;ref&#125; className="FancyButton"&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;/button&gt;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can now get a ref directly to the DOM button:</span></span><br><span class="line"><span class="keyword">const</span> ref = React.createRef();</span><br><span class="line">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure><h2 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy"></a>React.lazy</h2><blockquote><p>React.lazy()允许你定义一个动态加载组件。有助于减少 bundle的体积，并提高首屏加载效率</p></blockquote><p><strong>此特性需要支持 <code>promise</code></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'./component'</span>)) <span class="comment">// 动态加载</span></span><br></pre></td></tr></table></figure></p><p><a href="https://zh-hans.reactjs.org/docs/code-splitting.html#reactlazy">参考文章</a></p><h2 id="React-Suspense"><a href="#React-Suspense" class="headerlink" title="React.Suspense"></a>React.Suspense</h2><blockquote><p>React.Suspense 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。目前，懒加载组件是 &lt;React.Suspense&gt; 支持的唯一用例：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该组件是动态加载的</span></span><br><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 显示 &lt;Spinner&gt; 组件直至 OtherComponent 加载完成</span></span><br><span class="line">    &lt;React.Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;OtherComponent /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>React.Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>lazy</code> 组件可以位于 <code>Suspense</code> 组件树的深处——它不必包装树中的每一个延迟加载组件。最佳实践是将 <code>&lt;Suspense&gt;</code> 置于你想展示加载指示器（loading indicator）的位置，而 <code>lazy()</code> 则可被放置于任何你想要做代码分割的地方。</p><p>虽然目前尚未支持其它特性，但未来我们计划让 Suspense 支持包括数据获取在内的更多场景。可以在<a href="https://zh-hans.reactjs.org/blog/2018/11/27/react-16-roadmap.html">roadmap</a> 中了解相关信息。</p><p><strong><code>React.lazy()</code> 和 <code>&lt;React.Suspense&gt;</code> 尚未在 <code>ReactDOMServer</code> 中支持。这是已知问题，将会在未来解决。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;createElement&quot;&gt;&lt;a href=&quot;#createElement&quot; class=&quot;headerlink&quot; title=&quot;createElement()&quot;&gt;&lt;/a&gt;createElement()&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;创基并返回指定类型
      
    
    </summary>
    
      <category term="React" scheme="https://owen027.github.io/categories/React/"/>
    
    
      <category term="React API" scheme="https://owen027.github.io/tags/React-API/"/>
    
  </entry>
  
</feed>
